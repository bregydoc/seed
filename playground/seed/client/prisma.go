// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "https://us1.prisma.sh/bregy-malpartida-2d1dcf/xxx/dev"
var Secret = ""

func (client *Client) ActionTicket(params ActionTicketWhereUniqueInput) *ActionTicketExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ActionTicketWhereUniqueInput!", "ActionTicket"},
		"actionTicket",
		[]string{"id", "createdAt", "updatedAt", "type", "token", "available", "used"})

	return &ActionTicketExec{ret}
}

type ActionTicketsParams struct {
	Where   *ActionTicketWhereInput   `json:"where,omitempty"`
	OrderBy *ActionTicketOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) ActionTickets(params *ActionTicketsParams) *ActionTicketExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ActionTicketWhereInput", "ActionTicketOrderByInput", "ActionTicket"},
		"actionTickets",
		[]string{"id", "createdAt", "updatedAt", "type", "token", "available", "used"})

	return &ActionTicketExecArray{ret}
}

type ActionTicketsConnectionParams struct {
	Where   *ActionTicketWhereInput   `json:"where,omitempty"`
	OrderBy *ActionTicketOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) ActionTicketsConnection(params *ActionTicketsConnectionParams) *ActionTicketConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ActionTicketWhereInput", "ActionTicketOrderByInput", "ActionTicket"},
		"actionTicketsConnection",
		[]string{"edges", "pageInfo"})

	return &ActionTicketConnectionExec{ret}
}

func (client *Client) Attraction(params AttractionWhereUniqueInput) *AttractionExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AttractionWhereUniqueInput!", "Attraction"},
		"attraction",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionExec{ret}
}

type AttractionsParams struct {
	Where   *AttractionWhereInput   `json:"where,omitempty"`
	OrderBy *AttractionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) Attractions(params *AttractionsParams) *AttractionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AttractionWhereInput", "AttractionOrderByInput", "Attraction"},
		"attractions",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionExecArray{ret}
}

type AttractionsConnectionParams struct {
	Where   *AttractionWhereInput   `json:"where,omitempty"`
	OrderBy *AttractionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) AttractionsConnection(params *AttractionsConnectionParams) *AttractionConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AttractionWhereInput", "AttractionOrderByInput", "Attraction"},
		"attractionsConnection",
		[]string{"edges", "pageInfo"})

	return &AttractionConnectionExec{ret}
}

func (client *Client) Cost(params CostWhereUniqueInput) *CostExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CostWhereUniqueInput!", "Cost"},
		"cost",
		[]string{"id", "value"})

	return &CostExec{ret}
}

type CostsParams struct {
	Where   *CostWhereInput   `json:"where,omitempty"`
	OrderBy *CostOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Costs(params *CostsParams) *CostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CostWhereInput", "CostOrderByInput", "Cost"},
		"costs",
		[]string{"id", "value"})

	return &CostExecArray{ret}
}

type CostsConnectionParams struct {
	Where   *CostWhereInput   `json:"where,omitempty"`
	OrderBy *CostOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) CostsConnection(params *CostsConnectionParams) *CostConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CostWhereInput", "CostOrderByInput", "Cost"},
		"costsConnection",
		[]string{"edges", "pageInfo"})

	return &CostConnectionExec{ret}
}

func (client *Client) Credential(params CredentialWhereUniqueInput) *CredentialExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CredentialWhereUniqueInput!", "Credential"},
		"credential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

type CredentialsParams struct {
	Where   *CredentialWhereInput   `json:"where,omitempty"`
	OrderBy *CredentialOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) Credentials(params *CredentialsParams) *CredentialExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CredentialWhereInput", "CredentialOrderByInput", "Credential"},
		"credentials",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExecArray{ret}
}

type CredentialsConnectionParams struct {
	Where   *CredentialWhereInput   `json:"where,omitempty"`
	OrderBy *CredentialOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) CredentialsConnection(params *CredentialsConnectionParams) *CredentialConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CredentialWhereInput", "CredentialOrderByInput", "Credential"},
		"credentialsConnection",
		[]string{"edges", "pageInfo"})

	return &CredentialConnectionExec{ret}
}

func (client *Client) CreditCard(params CreditCardWhereUniqueInput) *CreditCardExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CreditCardWhereUniqueInput!", "CreditCard"},
		"creditCard",
		[]string{"id", "createdAt", "updatedAt", "customerToken", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

type CreditCardsParams struct {
	Where   *CreditCardWhereInput   `json:"where,omitempty"`
	OrderBy *CreditCardOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) CreditCards(params *CreditCardsParams) *CreditCardExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CreditCardWhereInput", "CreditCardOrderByInput", "CreditCard"},
		"creditCards",
		[]string{"id", "createdAt", "updatedAt", "customerToken", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExecArray{ret}
}

type CreditCardsConnectionParams struct {
	Where   *CreditCardWhereInput   `json:"where,omitempty"`
	OrderBy *CreditCardOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) CreditCardsConnection(params *CreditCardsConnectionParams) *CreditCardConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CreditCardWhereInput", "CreditCardOrderByInput", "CreditCard"},
		"creditCardsConnection",
		[]string{"edges", "pageInfo"})

	return &CreditCardConnectionExec{ret}
}

func (client *Client) Currency(params CurrencyWhereUniqueInput) *CurrencyExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CurrencyWhereUniqueInput!", "Currency"},
		"currency",
		[]string{"id", "code", "symbol"})

	return &CurrencyExec{ret}
}

type CurrenciesParams struct {
	Where   *CurrencyWhereInput   `json:"where,omitempty"`
	OrderBy *CurrencyOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Currencies(params *CurrenciesParams) *CurrencyExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CurrencyWhereInput", "CurrencyOrderByInput", "Currency"},
		"currencies",
		[]string{"id", "code", "symbol"})

	return &CurrencyExecArray{ret}
}

type CurrenciesConnectionParams struct {
	Where   *CurrencyWhereInput   `json:"where,omitempty"`
	OrderBy *CurrencyOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) CurrenciesConnection(params *CurrenciesConnectionParams) *CurrencyConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CurrencieWhereInput", "CurrencieOrderByInput", "Currencie"},
		"currenciesConnection",
		[]string{"edges", "pageInfo"})

	return &CurrencyConnectionExec{ret}
}

func (client *Client) EmailChannel(params EmailChannelWhereUniqueInput) *EmailChannelExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"EmailChannelWhereUniqueInput!", "EmailChannel"},
		"emailChannel",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

type EmailChannelsParams struct {
	Where   *EmailChannelWhereInput   `json:"where,omitempty"`
	OrderBy *EmailChannelOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) EmailChannels(params *EmailChannelsParams) *EmailChannelExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EmailChannelWhereInput", "EmailChannelOrderByInput", "EmailChannel"},
		"emailChannels",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "value", "extras"})

	return &EmailChannelExecArray{ret}
}

type EmailChannelsConnectionParams struct {
	Where   *EmailChannelWhereInput   `json:"where,omitempty"`
	OrderBy *EmailChannelOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) EmailChannelsConnection(params *EmailChannelsConnectionParams) *EmailChannelConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EmailChannelWhereInput", "EmailChannelOrderByInput", "EmailChannel"},
		"emailChannelsConnection",
		[]string{"edges", "pageInfo"})

	return &EmailChannelConnectionExec{ret}
}

func (client *Client) EntryTicket(params EntryTicketWhereUniqueInput) *EntryTicketExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"EntryTicketWhereUniqueInput!", "EntryTicket"},
		"entryTicket",
		[]string{"id", "createdAt", "updatedAt", "at"})

	return &EntryTicketExec{ret}
}

type EntryTicketsParams struct {
	Where   *EntryTicketWhereInput   `json:"where,omitempty"`
	OrderBy *EntryTicketOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) EntryTickets(params *EntryTicketsParams) *EntryTicketExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EntryTicketWhereInput", "EntryTicketOrderByInput", "EntryTicket"},
		"entryTickets",
		[]string{"id", "createdAt", "updatedAt", "at"})

	return &EntryTicketExecArray{ret}
}

type EntryTicketsConnectionParams struct {
	Where   *EntryTicketWhereInput   `json:"where,omitempty"`
	OrderBy *EntryTicketOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) EntryTicketsConnection(params *EntryTicketsConnectionParams) *EntryTicketConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"EntryTicketWhereInput", "EntryTicketOrderByInput", "EntryTicket"},
		"entryTicketsConnection",
		[]string{"edges", "pageInfo"})

	return &EntryTicketConnectionExec{ret}
}

func (client *Client) Error(params ErrorWhereUniqueInput) *ErrorExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ErrorWhereUniqueInput!", "Error"},
		"error",
		[]string{"id", "createdAt", "updatedAt", "code", "internal", "explain", "location"})

	return &ErrorExec{ret}
}

type ErrorsParams struct {
	Where   *ErrorWhereInput   `json:"where,omitempty"`
	OrderBy *ErrorOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Errors(params *ErrorsParams) *ErrorExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ErrorWhereInput", "ErrorOrderByInput", "Error"},
		"errors",
		[]string{"id", "createdAt", "updatedAt", "code", "internal", "explain", "location"})

	return &ErrorExecArray{ret}
}

type ErrorsConnectionParams struct {
	Where   *ErrorWhereInput   `json:"where,omitempty"`
	OrderBy *ErrorOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) ErrorsConnection(params *ErrorsConnectionParams) *ErrorConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ErrorWhereInput", "ErrorOrderByInput", "Error"},
		"errorsConnection",
		[]string{"edges", "pageInfo"})

	return &ErrorConnectionExec{ret}
}

func (client *Client) Expert(params ExpertWhereUniqueInput) *ExpertExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ExpertWhereUniqueInput!", "Expert"},
		"expert",
		[]string{"id", "createdAt", "updatedAt", "alias"})

	return &ExpertExec{ret}
}

type ExpertsParams struct {
	Where   *ExpertWhereInput   `json:"where,omitempty"`
	OrderBy *ExpertOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Experts(params *ExpertsParams) *ExpertExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ExpertWhereInput", "ExpertOrderByInput", "Expert"},
		"experts",
		[]string{"id", "createdAt", "updatedAt", "alias"})

	return &ExpertExecArray{ret}
}

type ExpertsConnectionParams struct {
	Where   *ExpertWhereInput   `json:"where,omitempty"`
	OrderBy *ExpertOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) ExpertsConnection(params *ExpertsConnectionParams) *ExpertConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ExpertWhereInput", "ExpertOrderByInput", "Expert"},
		"expertsConnection",
		[]string{"edges", "pageInfo"})

	return &ExpertConnectionExec{ret}
}

func (client *Client) Faq(params FaqWhereUniqueInput) *FaqExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"FaqWhereUniqueInput!", "Faq"},
		"faq",
		[]string{"id", "createdAt", "updatedAt"})

	return &FaqExec{ret}
}

type FaqsParams struct {
	Where   *FaqWhereInput   `json:"where,omitempty"`
	OrderBy *FaqOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

func (client *Client) Faqs(params *FaqsParams) *FaqExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FaqWhereInput", "FaqOrderByInput", "Faq"},
		"faqs",
		[]string{"id", "createdAt", "updatedAt"})

	return &FaqExecArray{ret}
}

type FaqsConnectionParams struct {
	Where   *FaqWhereInput   `json:"where,omitempty"`
	OrderBy *FaqOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

func (client *Client) FaqsConnection(params *FaqsConnectionParams) *FaqConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FaqWhereInput", "FaqOrderByInput", "Faq"},
		"faqsConnection",
		[]string{"edges", "pageInfo"})

	return &FaqConnectionExec{ret}
}

func (client *Client) FaqEntry(params FaqEntryWhereUniqueInput) *FaqEntryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"FaqEntryWhereUniqueInput!", "FaqEntry"},
		"faqEntry",
		[]string{"id"})

	return &FaqEntryExec{ret}
}

type FaqEntriesParams struct {
	Where   *FaqEntryWhereInput   `json:"where,omitempty"`
	OrderBy *FaqEntryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) FaqEntries(params *FaqEntriesParams) *FaqEntryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FaqEntryWhereInput", "FaqEntryOrderByInput", "FaqEntry"},
		"faqEntries",
		[]string{"id"})

	return &FaqEntryExecArray{ret}
}

type FaqEntriesConnectionParams struct {
	Where   *FaqEntryWhereInput   `json:"where,omitempty"`
	OrderBy *FaqEntryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) FaqEntriesConnection(params *FaqEntriesConnectionParams) *FaqEntryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FaqEntrieWhereInput", "FaqEntrieOrderByInput", "FaqEntrie"},
		"faqEntriesConnection",
		[]string{"edges", "pageInfo"})

	return &FaqEntryConnectionExec{ret}
}

func (client *Client) Feature(params FeatureWhereUniqueInput) *FeatureExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"FeatureWhereUniqueInput!", "Feature"},
		"feature",
		[]string{"id", "image"})

	return &FeatureExec{ret}
}

type FeaturesParams struct {
	Where   *FeatureWhereInput   `json:"where,omitempty"`
	OrderBy *FeatureOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Features(params *FeaturesParams) *FeatureExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FeatureWhereInput", "FeatureOrderByInput", "Feature"},
		"features",
		[]string{"id", "image"})

	return &FeatureExecArray{ret}
}

type FeaturesConnectionParams struct {
	Where   *FeatureWhereInput   `json:"where,omitempty"`
	OrderBy *FeatureOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) FeaturesConnection(params *FeaturesConnectionParams) *FeatureConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FeatureWhereInput", "FeatureOrderByInput", "Feature"},
		"featuresConnection",
		[]string{"edges", "pageInfo"})

	return &FeatureConnectionExec{ret}
}

func (client *Client) IDDocument(params IDDocumentWhereUniqueInput) *IDDocumentExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"IDDocumentWhereUniqueInput!", "IDDocument"},
		"iDDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDDocumentExec{ret}
}

type IDDocumentsParams struct {
	Where   *IDDocumentWhereInput   `json:"where,omitempty"`
	OrderBy *IDDocumentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) IDDocuments(params *IDDocumentsParams) *IDDocumentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"IDDocumentWhereInput", "IDDocumentOrderByInput", "IDDocument"},
		"iDDocuments",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDDocumentExecArray{ret}
}

type IDDocumentsConnectionParams struct {
	Where   *IDDocumentWhereInput   `json:"where,omitempty"`
	OrderBy *IDDocumentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) IDDocumentsConnection(params *IDDocumentsConnectionParams) *IDDocumentConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"IDDocumentWhereInput", "IDDocumentOrderByInput", "IDDocument"},
		"iDDocumentsConnection",
		[]string{"edges", "pageInfo"})

	return &IDDocumentConnectionExec{ret}
}

func (client *Client) Lima(params LimaWhereUniqueInput) *LimaExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"LimaWhereUniqueInput!", "Lima"},
		"lima",
		[]string{"id", "createdAt", "updatedAt", "version", "available"})

	return &LimaExec{ret}
}

type LimasParams struct {
	Where   *LimaWhereInput   `json:"where,omitempty"`
	OrderBy *LimaOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Limas(params *LimasParams) *LimaExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LimaWhereInput", "LimaOrderByInput", "Lima"},
		"limas",
		[]string{"id", "createdAt", "updatedAt", "version", "available"})

	return &LimaExecArray{ret}
}

type LimasConnectionParams struct {
	Where   *LimaWhereInput   `json:"where,omitempty"`
	OrderBy *LimaOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) LimasConnection(params *LimasConnectionParams) *LimaConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LimaWhereInput", "LimaOrderByInput", "Lima"},
		"limasConnection",
		[]string{"edges", "pageInfo"})

	return &LimaConnectionExec{ret}
}

func (client *Client) LimaContact(params LimaContactWhereUniqueInput) *LimaContactExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"LimaContactWhereUniqueInput!", "LimaContact"},
		"limaContact",
		[]string{"id", "email", "phoneNumber"})

	return &LimaContactExec{ret}
}

type LimaContactsParams struct {
	Where   *LimaContactWhereInput   `json:"where,omitempty"`
	OrderBy *LimaContactOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) LimaContacts(params *LimaContactsParams) *LimaContactExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LimaContactWhereInput", "LimaContactOrderByInput", "LimaContact"},
		"limaContacts",
		[]string{"id", "email", "phoneNumber"})

	return &LimaContactExecArray{ret}
}

type LimaContactsConnectionParams struct {
	Where   *LimaContactWhereInput   `json:"where,omitempty"`
	OrderBy *LimaContactOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) LimaContactsConnection(params *LimaContactsConnectionParams) *LimaContactConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LimaContactWhereInput", "LimaContactOrderByInput", "LimaContact"},
		"limaContactsConnection",
		[]string{"edges", "pageInfo"})

	return &LimaContactConnectionExec{ret}
}

func (client *Client) Location(params LocationWhereUniqueInput) *LocationExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"LocationWhereUniqueInput!", "Location"},
		"location",
		[]string{"id", "createdAt", "updatedAt", "longitude", "latitude"})

	return &LocationExec{ret}
}

type LocationsParams struct {
	Where   *LocationWhereInput   `json:"where,omitempty"`
	OrderBy *LocationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Locations(params *LocationsParams) *LocationExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LocationWhereInput", "LocationOrderByInput", "Location"},
		"locations",
		[]string{"id", "createdAt", "updatedAt", "longitude", "latitude"})

	return &LocationExecArray{ret}
}

type LocationsConnectionParams struct {
	Where   *LocationWhereInput   `json:"where,omitempty"`
	OrderBy *LocationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) LocationsConnection(params *LocationsConnectionParams) *LocationConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"LocationWhereInput", "LocationOrderByInput", "Location"},
		"locationsConnection",
		[]string{"edges", "pageInfo"})

	return &LocationConnectionExec{ret}
}

func (client *Client) OpeningHours(params OpeningHoursWhereUniqueInput) *OpeningHoursExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"OpeningHoursWhereUniqueInput!", "OpeningHours"},
		"openingHours",
		[]string{"id", "mon", "tue", "wed", "thu", "fri", "sat", "sun"})

	return &OpeningHoursExec{ret}
}

type OpeningHoursesParams struct {
	Where   *OpeningHoursWhereInput   `json:"where,omitempty"`
	OrderBy *OpeningHoursOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) OpeningHourses(params *OpeningHoursesParams) *OpeningHoursExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OpeningHoursWhereInput", "OpeningHoursOrderByInput", "OpeningHours"},
		"openingHourses",
		[]string{"id", "mon", "tue", "wed", "thu", "fri", "sat", "sun"})

	return &OpeningHoursExecArray{ret}
}

type OpeningHoursesConnectionParams struct {
	Where   *OpeningHoursWhereInput   `json:"where,omitempty"`
	OrderBy *OpeningHoursOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) OpeningHoursesConnection(params *OpeningHoursesConnectionParams) *OpeningHoursConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OpeningHourseWhereInput", "OpeningHourseOrderByInput", "OpeningHourse"},
		"openingHoursesConnection",
		[]string{"edges", "pageInfo"})

	return &OpeningHoursConnectionExec{ret}
}

func (client *Client) Partner(params PartnerWhereUniqueInput) *PartnerExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PartnerWhereUniqueInput!", "Partner"},
		"partner",
		[]string{"id", "createdAt", "updatedAt", "brandName", "logo", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

type PartnersParams struct {
	Where   *PartnerWhereInput   `json:"where,omitempty"`
	OrderBy *PartnerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Partners(params *PartnersParams) *PartnerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PartnerWhereInput", "PartnerOrderByInput", "Partner"},
		"partners",
		[]string{"id", "createdAt", "updatedAt", "brandName", "logo", "socialReason", "ruc", "address"})

	return &PartnerExecArray{ret}
}

type PartnersConnectionParams struct {
	Where   *PartnerWhereInput   `json:"where,omitempty"`
	OrderBy *PartnerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) PartnersConnection(params *PartnersConnectionParams) *PartnerConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PartnerWhereInput", "PartnerOrderByInput", "Partner"},
		"partnersConnection",
		[]string{"edges", "pageInfo"})

	return &PartnerConnectionExec{ret}
}

func (client *Client) Pass(params PassWhereUniqueInput) *PassExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PassWhereUniqueInput!", "Pass"},
		"pass",
		[]string{"id", "createdAt", "updatedAt", "expireAt", "state"})

	return &PassExec{ret}
}

type PassesParams struct {
	Where   *PassWhereInput   `json:"where,omitempty"`
	OrderBy *PassOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Passes(params *PassesParams) *PassExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PassWhereInput", "PassOrderByInput", "Pass"},
		"passes",
		[]string{"id", "createdAt", "updatedAt", "expireAt", "state"})

	return &PassExecArray{ret}
}

type PassesConnectionParams struct {
	Where   *PassWhereInput   `json:"where,omitempty"`
	OrderBy *PassOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) PassesConnection(params *PassesConnectionParams) *PassConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PasseWhereInput", "PasseOrderByInput", "Passe"},
		"passesConnection",
		[]string{"edges", "pageInfo"})

	return &PassConnectionExec{ret}
}

func (client *Client) PassType(params PassTypeWhereUniqueInput) *PassTypeExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PassTypeWhereUniqueInput!", "PassType"},
		"passType",
		[]string{"id", "createdAt", "updatedAt", "gallery", "creatorID", "duration"})

	return &PassTypeExec{ret}
}

type PassTypesParams struct {
	Where   *PassTypeWhereInput   `json:"where,omitempty"`
	OrderBy *PassTypeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) PassTypes(params *PassTypesParams) *PassTypeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PassTypeWhereInput", "PassTypeOrderByInput", "PassType"},
		"passTypes",
		[]string{"id", "createdAt", "updatedAt", "gallery", "creatorID", "duration"})

	return &PassTypeExecArray{ret}
}

type PassTypesConnectionParams struct {
	Where   *PassTypeWhereInput   `json:"where,omitempty"`
	OrderBy *PassTypeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) PassTypesConnection(params *PassTypesConnectionParams) *PassTypeConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PassTypeWhereInput", "PassTypeOrderByInput", "PassType"},
		"passTypesConnection",
		[]string{"edges", "pageInfo"})

	return &PassTypeConnectionExec{ret}
}

func (client *Client) PaymentMethod(params PaymentMethodWhereUniqueInput) *PaymentMethodExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PaymentMethodWhereUniqueInput!", "PaymentMethod"},
		"paymentMethod",
		[]string{"id", "type", "value", "cardNumber", "code"})

	return &PaymentMethodExec{ret}
}

type PaymentMethodsParams struct {
	Where   *PaymentMethodWhereInput   `json:"where,omitempty"`
	OrderBy *PaymentMethodOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) PaymentMethods(params *PaymentMethodsParams) *PaymentMethodExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PaymentMethodWhereInput", "PaymentMethodOrderByInput", "PaymentMethod"},
		"paymentMethods",
		[]string{"id", "type", "value", "cardNumber", "code"})

	return &PaymentMethodExecArray{ret}
}

type PaymentMethodsConnectionParams struct {
	Where   *PaymentMethodWhereInput   `json:"where,omitempty"`
	OrderBy *PaymentMethodOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) PaymentMethodsConnection(params *PaymentMethodsConnectionParams) *PaymentMethodConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PaymentMethodWhereInput", "PaymentMethodOrderByInput", "PaymentMethod"},
		"paymentMethodsConnection",
		[]string{"edges", "pageInfo"})

	return &PaymentMethodConnectionExec{ret}
}

func (client *Client) Person(params PersonWhereUniqueInput) *PersonExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PersonWhereUniqueInput!", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

type PersonsParams struct {
	Where   *PersonWhereInput   `json:"where,omitempty"`
	OrderBy *PersonOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Persons(params *PersonsParams) *PersonExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PersonWhereInput", "PersonOrderByInput", "Person"},
		"persons",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExecArray{ret}
}

type PersonsConnectionParams struct {
	Where   *PersonWhereInput   `json:"where,omitempty"`
	OrderBy *PersonOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) PersonsConnection(params *PersonsConnectionParams) *PersonConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PersonWhereInput", "PersonOrderByInput", "Person"},
		"personsConnection",
		[]string{"edges", "pageInfo"})

	return &PersonConnectionExec{ret}
}

func (client *Client) PersonReviews(params PersonReviewsWhereUniqueInput) *PersonReviewsExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PersonReviewsWhereUniqueInput!", "PersonReviews"},
		"personReviews",
		[]string{"id", "createdAt", "updatedAt", "approveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

type PersonReviewsesParams struct {
	Where   *PersonReviewsWhereInput   `json:"where,omitempty"`
	OrderBy *PersonReviewsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) PersonReviewses(params *PersonReviewsesParams) *PersonReviewsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PersonReviewsWhereInput", "PersonReviewsOrderByInput", "PersonReviews"},
		"personReviewses",
		[]string{"id", "createdAt", "updatedAt", "approveNumber", "declineNumber"})

	return &PersonReviewsExecArray{ret}
}

type PersonReviewsesConnectionParams struct {
	Where   *PersonReviewsWhereInput   `json:"where,omitempty"`
	OrderBy *PersonReviewsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) PersonReviewsesConnection(params *PersonReviewsesConnectionParams) *PersonReviewsConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PersonReviewseWhereInput", "PersonReviewseOrderByInput", "PersonReviewse"},
		"personReviewsesConnection",
		[]string{"edges", "pageInfo"})

	return &PersonReviewsConnectionExec{ret}
}

func (client *Client) PhoneChannel(params PhoneChannelWhereUniqueInput) *PhoneChannelExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PhoneChannelWhereUniqueInput!", "PhoneChannel"},
		"phoneChannel",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

type PhoneChannelsParams struct {
	Where   *PhoneChannelWhereInput   `json:"where,omitempty"`
	OrderBy *PhoneChannelOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) PhoneChannels(params *PhoneChannelsParams) *PhoneChannelExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PhoneChannelWhereInput", "PhoneChannelOrderByInput", "PhoneChannel"},
		"phoneChannels",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExecArray{ret}
}

type PhoneChannelsConnectionParams struct {
	Where   *PhoneChannelWhereInput   `json:"where,omitempty"`
	OrderBy *PhoneChannelOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) PhoneChannelsConnection(params *PhoneChannelsConnectionParams) *PhoneChannelConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PhoneChannelWhereInput", "PhoneChannelOrderByInput", "PhoneChannel"},
		"phoneChannelsConnection",
		[]string{"edges", "pageInfo"})

	return &PhoneChannelConnectionExec{ret}
}

func (client *Client) Place(params PlaceWhereUniqueInput) *PlaceExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PlaceWhereUniqueInput!", "Place"},
		"place",
		[]string{"id", "createdAt", "updatedAt", "name", "shortName", "address", "googleLink", "website", "type", "extraTypes", "tags", "popularity", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &PlaceExec{ret}
}

type PlacesParams struct {
	Where   *PlaceWhereInput   `json:"where,omitempty"`
	OrderBy *PlaceOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Places(params *PlacesParams) *PlaceExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PlaceWhereInput", "PlaceOrderByInput", "Place"},
		"places",
		[]string{"id", "createdAt", "updatedAt", "name", "shortName", "address", "googleLink", "website", "type", "extraTypes", "tags", "popularity", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &PlaceExecArray{ret}
}

type PlacesConnectionParams struct {
	Where   *PlaceWhereInput   `json:"where,omitempty"`
	OrderBy *PlaceOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) PlacesConnection(params *PlacesConnectionParams) *PlaceConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PlaceWhereInput", "PlaceOrderByInput", "Place"},
		"placesConnection",
		[]string{"edges", "pageInfo"})

	return &PlaceConnectionExec{ret}
}

func (client *Client) ProductEntry(params ProductEntryWhereUniqueInput) *ProductEntryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ProductEntryWhereUniqueInput!", "ProductEntry"},
		"productEntry",
		[]string{"id", "parentID", "name", "description", "quantity", "cost", "currencyCode"})

	return &ProductEntryExec{ret}
}

type ProductEntriesParams struct {
	Where   *ProductEntryWhereInput   `json:"where,omitempty"`
	OrderBy *ProductEntryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) ProductEntries(params *ProductEntriesParams) *ProductEntryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProductEntryWhereInput", "ProductEntryOrderByInput", "ProductEntry"},
		"productEntries",
		[]string{"id", "parentID", "name", "description", "quantity", "cost", "currencyCode"})

	return &ProductEntryExecArray{ret}
}

type ProductEntriesConnectionParams struct {
	Where   *ProductEntryWhereInput   `json:"where,omitempty"`
	OrderBy *ProductEntryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) ProductEntriesConnection(params *ProductEntriesConnectionParams) *ProductEntryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ProductEntrieWhereInput", "ProductEntrieOrderByInput", "ProductEntrie"},
		"productEntriesConnection",
		[]string{"edges", "pageInfo"})

	return &ProductEntryConnectionExec{ret}
}

func (client *Client) Purchase(params PurchaseWhereUniqueInput) *PurchaseExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PurchaseWhereUniqueInput!", "Purchase"},
		"purchase",
		[]string{"id", "createdAt", "updatedAt", "chargeToken", "gatewayResponse", "discountID", "discount"})

	return &PurchaseExec{ret}
}

type PurchasesParams struct {
	Where   *PurchaseWhereInput   `json:"where,omitempty"`
	OrderBy *PurchaseOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Purchases(params *PurchasesParams) *PurchaseExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PurchaseWhereInput", "PurchaseOrderByInput", "Purchase"},
		"purchases",
		[]string{"id", "createdAt", "updatedAt", "chargeToken", "gatewayResponse", "discountID", "discount"})

	return &PurchaseExecArray{ret}
}

type PurchasesConnectionParams struct {
	Where   *PurchaseWhereInput   `json:"where,omitempty"`
	OrderBy *PurchaseOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) PurchasesConnection(params *PurchasesConnectionParams) *PurchaseConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PurchaseWhereInput", "PurchaseOrderByInput", "Purchase"},
		"purchasesConnection",
		[]string{"edges", "pageInfo"})

	return &PurchaseConnectionExec{ret}
}

func (client *Client) Route(params RouteWhereUniqueInput) *RouteExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"RouteWhereUniqueInput!", "Route"},
		"route",
		[]string{"id", "createdAt", "updatedAt", "name", "image", "type", "extraTypes", "popularity", "color"})

	return &RouteExec{ret}
}

type RoutesParams struct {
	Where   *RouteWhereInput   `json:"where,omitempty"`
	OrderBy *RouteOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Routes(params *RoutesParams) *RouteExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RouteWhereInput", "RouteOrderByInput", "Route"},
		"routes",
		[]string{"id", "createdAt", "updatedAt", "name", "image", "type", "extraTypes", "popularity", "color"})

	return &RouteExecArray{ret}
}

type RoutesConnectionParams struct {
	Where   *RouteWhereInput   `json:"where,omitempty"`
	OrderBy *RouteOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) RoutesConnection(params *RoutesConnectionParams) *RouteConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RouteWhereInput", "RouteOrderByInput", "Route"},
		"routesConnection",
		[]string{"edges", "pageInfo"})

	return &RouteConnectionExec{ret}
}

func (client *Client) Story(params StoryWhereUniqueInput) *StoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"StoryWhereUniqueInput!", "Story"},
		"story",
		[]string{"id", "createdAt", "updatedAt", "type", "tags", "podcastLink", "audioStream", "principalImage", "likes", "views"})

	return &StoryExec{ret}
}

type StoriesParams struct {
	Where   *StoryWhereInput   `json:"where,omitempty"`
	OrderBy *StoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Stories(params *StoriesParams) *StoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"StoryWhereInput", "StoryOrderByInput", "Story"},
		"stories",
		[]string{"id", "createdAt", "updatedAt", "type", "tags", "podcastLink", "audioStream", "principalImage", "likes", "views"})

	return &StoryExecArray{ret}
}

type StoriesConnectionParams struct {
	Where   *StoryWhereInput   `json:"where,omitempty"`
	OrderBy *StoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) StoriesConnection(params *StoriesConnectionParams) *StoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"StorieWhereInput", "StorieOrderByInput", "Storie"},
		"storiesConnection",
		[]string{"edges", "pageInfo"})

	return &StoryConnectionExec{ret}
}

func (client *Client) Text(params TextWhereUniqueInput) *TextExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TextWhereUniqueInput!", "Text"},
		"text",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

type TextsParams struct {
	Where   *TextWhereInput   `json:"where,omitempty"`
	OrderBy *TextOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Texts(params *TextsParams) *TextExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TextWhereInput", "TextOrderByInput", "Text"},
		"texts",
		[]string{"id", "english", "spanish"})

	return &TextExecArray{ret}
}

type TextsConnectionParams struct {
	Where   *TextWhereInput   `json:"where,omitempty"`
	OrderBy *TextOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) TextsConnection(params *TextsConnectionParams) *TextConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TextWhereInput", "TextOrderByInput", "Text"},
		"textsConnection",
		[]string{"edges", "pageInfo"})

	return &TextConnectionExec{ret}
}

func (client *Client) Ticket(params TicketWhereUniqueInput) *TicketExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TicketWhereUniqueInput!", "Ticket"},
		"ticket",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "visited", "finished", "state"})

	return &TicketExec{ret}
}

type TicketsParams struct {
	Where   *TicketWhereInput   `json:"where,omitempty"`
	OrderBy *TicketOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Tickets(params *TicketsParams) *TicketExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TicketWhereInput", "TicketOrderByInput", "Ticket"},
		"tickets",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "visited", "finished", "state"})

	return &TicketExecArray{ret}
}

type TicketsConnectionParams struct {
	Where   *TicketWhereInput   `json:"where,omitempty"`
	OrderBy *TicketOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) TicketsConnection(params *TicketsConnectionParams) *TicketConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TicketWhereInput", "TicketOrderByInput", "Ticket"},
		"ticketsConnection",
		[]string{"edges", "pageInfo"})

	return &TicketConnectionExec{ret}
}

func (client *Client) Traveler(params TravelerWhereUniqueInput) *TravelerExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TravelerWhereUniqueInput!", "Traveler"},
		"traveler",
		[]string{"id", "createdAt", "updatedAt", "unregistered", "username"})

	return &TravelerExec{ret}
}

type TravelersParams struct {
	Where   *TravelerWhereInput   `json:"where,omitempty"`
	OrderBy *TravelerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Travelers(params *TravelersParams) *TravelerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TravelerWhereInput", "TravelerOrderByInput", "Traveler"},
		"travelers",
		[]string{"id", "createdAt", "updatedAt", "unregistered", "username"})

	return &TravelerExecArray{ret}
}

type TravelersConnectionParams struct {
	Where   *TravelerWhereInput   `json:"where,omitempty"`
	OrderBy *TravelerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) TravelersConnection(params *TravelersConnectionParams) *TravelerConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TravelerWhereInput", "TravelerOrderByInput", "Traveler"},
		"travelersConnection",
		[]string{"edges", "pageInfo"})

	return &TravelerConnectionExec{ret}
}

func (client *Client) CreateActionTicket(params ActionTicketCreateInput) *ActionTicketExec {
	ret := client.Client.Create(
		params,
		[2]string{"ActionTicketCreateInput!", "ActionTicket"},
		"createActionTicket",
		[]string{"id", "createdAt", "updatedAt", "type", "token", "available", "used"})

	return &ActionTicketExec{ret}
}

type ActionTicketUpdateParams struct {
	Data  ActionTicketUpdateInput      `json:"data"`
	Where ActionTicketWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateActionTicket(params ActionTicketUpdateParams) *ActionTicketExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ActionTicketUpdateInput!", "ActionTicketWhereUniqueInput!", "ActionTicket"},
		"updateActionTicket",
		[]string{"id", "createdAt", "updatedAt", "type", "token", "available", "used"})

	return &ActionTicketExec{ret}
}

type ActionTicketUpdateManyParams struct {
	Data  ActionTicketUpdateManyMutationInput `json:"data"`
	Where *ActionTicketWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyActionTickets(params ActionTicketUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ActionTicketUpdateManyMutationInput!", "ActionTicketWhereInput"},
		"updateManyActionTickets")
	return &BatchPayloadExec{exec}
}

type ActionTicketUpsertParams struct {
	Where  ActionTicketWhereUniqueInput `json:"where"`
	Create ActionTicketCreateInput      `json:"create"`
	Update ActionTicketUpdateInput      `json:"update"`
}

func (client *Client) UpsertActionTicket(params ActionTicketUpsertParams) *ActionTicketExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ActionTicketWhereUniqueInput!", "ActionTicketCreateInput!", "ActionTicketUpdateInput!", "ActionTicket"},
		"upsertActionTicket",
		[]string{"id", "createdAt", "updatedAt", "type", "token", "available", "used"})

	return &ActionTicketExec{ret}
}

func (client *Client) DeleteActionTicket(params ActionTicketWhereUniqueInput) *ActionTicketExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ActionTicketWhereUniqueInput!", "ActionTicket"},
		"deleteActionTicket",
		[]string{"id", "createdAt", "updatedAt", "type", "token", "available", "used"})

	return &ActionTicketExec{ret}
}

func (client *Client) DeleteManyActionTickets(params *ActionTicketWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ActionTicketWhereInput", "deleteManyActionTickets")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateAttraction(params AttractionCreateInput) *AttractionExec {
	ret := client.Client.Create(
		params,
		[2]string{"AttractionCreateInput!", "Attraction"},
		"createAttraction",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionExec{ret}
}

type AttractionUpdateParams struct {
	Data  AttractionUpdateInput      `json:"data"`
	Where AttractionWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAttraction(params AttractionUpdateParams) *AttractionExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AttractionUpdateInput!", "AttractionWhereUniqueInput!", "Attraction"},
		"updateAttraction",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionExec{ret}
}

type AttractionUpdateManyParams struct {
	Data  AttractionUpdateManyMutationInput `json:"data"`
	Where *AttractionWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAttractions(params AttractionUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AttractionUpdateManyMutationInput!", "AttractionWhereInput"},
		"updateManyAttractions")
	return &BatchPayloadExec{exec}
}

type AttractionUpsertParams struct {
	Where  AttractionWhereUniqueInput `json:"where"`
	Create AttractionCreateInput      `json:"create"`
	Update AttractionUpdateInput      `json:"update"`
}

func (client *Client) UpsertAttraction(params AttractionUpsertParams) *AttractionExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AttractionWhereUniqueInput!", "AttractionCreateInput!", "AttractionUpdateInput!", "Attraction"},
		"upsertAttraction",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionExec{ret}
}

func (client *Client) DeleteAttraction(params AttractionWhereUniqueInput) *AttractionExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AttractionWhereUniqueInput!", "Attraction"},
		"deleteAttraction",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionExec{ret}
}

func (client *Client) DeleteManyAttractions(params *AttractionWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AttractionWhereInput", "deleteManyAttractions")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCost(params CostCreateInput) *CostExec {
	ret := client.Client.Create(
		params,
		[2]string{"CostCreateInput!", "Cost"},
		"createCost",
		[]string{"id", "value"})

	return &CostExec{ret}
}

type CostUpdateParams struct {
	Data  CostUpdateInput      `json:"data"`
	Where CostWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCost(params CostUpdateParams) *CostExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CostUpdateInput!", "CostWhereUniqueInput!", "Cost"},
		"updateCost",
		[]string{"id", "value"})

	return &CostExec{ret}
}

type CostUpdateManyParams struct {
	Data  CostUpdateManyMutationInput `json:"data"`
	Where *CostWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCosts(params CostUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CostUpdateManyMutationInput!", "CostWhereInput"},
		"updateManyCosts")
	return &BatchPayloadExec{exec}
}

type CostUpsertParams struct {
	Where  CostWhereUniqueInput `json:"where"`
	Create CostCreateInput      `json:"create"`
	Update CostUpdateInput      `json:"update"`
}

func (client *Client) UpsertCost(params CostUpsertParams) *CostExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CostWhereUniqueInput!", "CostCreateInput!", "CostUpdateInput!", "Cost"},
		"upsertCost",
		[]string{"id", "value"})

	return &CostExec{ret}
}

func (client *Client) DeleteCost(params CostWhereUniqueInput) *CostExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CostWhereUniqueInput!", "Cost"},
		"deleteCost",
		[]string{"id", "value"})

	return &CostExec{ret}
}

func (client *Client) DeleteManyCosts(params *CostWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CostWhereInput", "deleteManyCosts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCredential(params CredentialCreateInput) *CredentialExec {
	ret := client.Client.Create(
		params,
		[2]string{"CredentialCreateInput!", "Credential"},
		"createCredential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

type CredentialUpdateParams struct {
	Data  CredentialUpdateInput      `json:"data"`
	Where CredentialWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCredential(params CredentialUpdateParams) *CredentialExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CredentialUpdateInput!", "CredentialWhereUniqueInput!", "Credential"},
		"updateCredential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

type CredentialUpdateManyParams struct {
	Data  CredentialUpdateManyMutationInput `json:"data"`
	Where *CredentialWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCredentials(params CredentialUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CredentialUpdateManyMutationInput!", "CredentialWhereInput"},
		"updateManyCredentials")
	return &BatchPayloadExec{exec}
}

type CredentialUpsertParams struct {
	Where  CredentialWhereUniqueInput `json:"where"`
	Create CredentialCreateInput      `json:"create"`
	Update CredentialUpdateInput      `json:"update"`
}

func (client *Client) UpsertCredential(params CredentialUpsertParams) *CredentialExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CredentialWhereUniqueInput!", "CredentialCreateInput!", "CredentialUpdateInput!", "Credential"},
		"upsertCredential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

func (client *Client) DeleteCredential(params CredentialWhereUniqueInput) *CredentialExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CredentialWhereUniqueInput!", "Credential"},
		"deleteCredential",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

func (client *Client) DeleteManyCredentials(params *CredentialWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CredentialWhereInput", "deleteManyCredentials")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCreditCard(params CreditCardCreateInput) *CreditCardExec {
	ret := client.Client.Create(
		params,
		[2]string{"CreditCardCreateInput!", "CreditCard"},
		"createCreditCard",
		[]string{"id", "createdAt", "updatedAt", "customerToken", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

type CreditCardUpdateParams struct {
	Data  CreditCardUpdateInput      `json:"data"`
	Where CreditCardWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCreditCard(params CreditCardUpdateParams) *CreditCardExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CreditCardUpdateInput!", "CreditCardWhereUniqueInput!", "CreditCard"},
		"updateCreditCard",
		[]string{"id", "createdAt", "updatedAt", "customerToken", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

type CreditCardUpdateManyParams struct {
	Data  CreditCardUpdateManyMutationInput `json:"data"`
	Where *CreditCardWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCreditCards(params CreditCardUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CreditCardUpdateManyMutationInput!", "CreditCardWhereInput"},
		"updateManyCreditCards")
	return &BatchPayloadExec{exec}
}

type CreditCardUpsertParams struct {
	Where  CreditCardWhereUniqueInput `json:"where"`
	Create CreditCardCreateInput      `json:"create"`
	Update CreditCardUpdateInput      `json:"update"`
}

func (client *Client) UpsertCreditCard(params CreditCardUpsertParams) *CreditCardExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CreditCardWhereUniqueInput!", "CreditCardCreateInput!", "CreditCardUpdateInput!", "CreditCard"},
		"upsertCreditCard",
		[]string{"id", "createdAt", "updatedAt", "customerToken", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (client *Client) DeleteCreditCard(params CreditCardWhereUniqueInput) *CreditCardExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CreditCardWhereUniqueInput!", "CreditCard"},
		"deleteCreditCard",
		[]string{"id", "createdAt", "updatedAt", "customerToken", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (client *Client) DeleteManyCreditCards(params *CreditCardWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CreditCardWhereInput", "deleteManyCreditCards")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCurrency(params CurrencyCreateInput) *CurrencyExec {
	ret := client.Client.Create(
		params,
		[2]string{"CurrencyCreateInput!", "Currency"},
		"createCurrency",
		[]string{"id", "code", "symbol"})

	return &CurrencyExec{ret}
}

type CurrencyUpdateParams struct {
	Data  CurrencyUpdateInput      `json:"data"`
	Where CurrencyWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCurrency(params CurrencyUpdateParams) *CurrencyExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CurrencyUpdateInput!", "CurrencyWhereUniqueInput!", "Currency"},
		"updateCurrency",
		[]string{"id", "code", "symbol"})

	return &CurrencyExec{ret}
}

type CurrencyUpdateManyParams struct {
	Data  CurrencyUpdateManyMutationInput `json:"data"`
	Where *CurrencyWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCurrencies(params CurrencyUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CurrencyUpdateManyMutationInput!", "CurrencyWhereInput"},
		"updateManyCurrencies")
	return &BatchPayloadExec{exec}
}

type CurrencyUpsertParams struct {
	Where  CurrencyWhereUniqueInput `json:"where"`
	Create CurrencyCreateInput      `json:"create"`
	Update CurrencyUpdateInput      `json:"update"`
}

func (client *Client) UpsertCurrency(params CurrencyUpsertParams) *CurrencyExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CurrencyWhereUniqueInput!", "CurrencyCreateInput!", "CurrencyUpdateInput!", "Currency"},
		"upsertCurrency",
		[]string{"id", "code", "symbol"})

	return &CurrencyExec{ret}
}

func (client *Client) DeleteCurrency(params CurrencyWhereUniqueInput) *CurrencyExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CurrencyWhereUniqueInput!", "Currency"},
		"deleteCurrency",
		[]string{"id", "code", "symbol"})

	return &CurrencyExec{ret}
}

func (client *Client) DeleteManyCurrencies(params *CurrencyWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CurrencyWhereInput", "deleteManyCurrencies")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateEmailChannel(params EmailChannelCreateInput) *EmailChannelExec {
	ret := client.Client.Create(
		params,
		[2]string{"EmailChannelCreateInput!", "EmailChannel"},
		"createEmailChannel",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

type EmailChannelUpdateParams struct {
	Data  EmailChannelUpdateInput      `json:"data"`
	Where EmailChannelWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateEmailChannel(params EmailChannelUpdateParams) *EmailChannelExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"EmailChannelUpdateInput!", "EmailChannelWhereUniqueInput!", "EmailChannel"},
		"updateEmailChannel",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

type EmailChannelUpdateManyParams struct {
	Data  EmailChannelUpdateManyMutationInput `json:"data"`
	Where *EmailChannelWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyEmailChannels(params EmailChannelUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"EmailChannelUpdateManyMutationInput!", "EmailChannelWhereInput"},
		"updateManyEmailChannels")
	return &BatchPayloadExec{exec}
}

type EmailChannelUpsertParams struct {
	Where  EmailChannelWhereUniqueInput `json:"where"`
	Create EmailChannelCreateInput      `json:"create"`
	Update EmailChannelUpdateInput      `json:"update"`
}

func (client *Client) UpsertEmailChannel(params EmailChannelUpsertParams) *EmailChannelExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"EmailChannelWhereUniqueInput!", "EmailChannelCreateInput!", "EmailChannelUpdateInput!", "EmailChannel"},
		"upsertEmailChannel",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

func (client *Client) DeleteEmailChannel(params EmailChannelWhereUniqueInput) *EmailChannelExec {
	ret := client.Client.Delete(
		params,
		[2]string{"EmailChannelWhereUniqueInput!", "EmailChannel"},
		"deleteEmailChannel",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

func (client *Client) DeleteManyEmailChannels(params *EmailChannelWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "EmailChannelWhereInput", "deleteManyEmailChannels")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateEntryTicket(params EntryTicketCreateInput) *EntryTicketExec {
	ret := client.Client.Create(
		params,
		[2]string{"EntryTicketCreateInput!", "EntryTicket"},
		"createEntryTicket",
		[]string{"id", "createdAt", "updatedAt", "at"})

	return &EntryTicketExec{ret}
}

type EntryTicketUpdateParams struct {
	Data  EntryTicketUpdateInput      `json:"data"`
	Where EntryTicketWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateEntryTicket(params EntryTicketUpdateParams) *EntryTicketExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"EntryTicketUpdateInput!", "EntryTicketWhereUniqueInput!", "EntryTicket"},
		"updateEntryTicket",
		[]string{"id", "createdAt", "updatedAt", "at"})

	return &EntryTicketExec{ret}
}

type EntryTicketUpdateManyParams struct {
	Data  EntryTicketUpdateManyMutationInput `json:"data"`
	Where *EntryTicketWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyEntryTickets(params EntryTicketUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"EntryTicketUpdateManyMutationInput!", "EntryTicketWhereInput"},
		"updateManyEntryTickets")
	return &BatchPayloadExec{exec}
}

type EntryTicketUpsertParams struct {
	Where  EntryTicketWhereUniqueInput `json:"where"`
	Create EntryTicketCreateInput      `json:"create"`
	Update EntryTicketUpdateInput      `json:"update"`
}

func (client *Client) UpsertEntryTicket(params EntryTicketUpsertParams) *EntryTicketExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"EntryTicketWhereUniqueInput!", "EntryTicketCreateInput!", "EntryTicketUpdateInput!", "EntryTicket"},
		"upsertEntryTicket",
		[]string{"id", "createdAt", "updatedAt", "at"})

	return &EntryTicketExec{ret}
}

func (client *Client) DeleteEntryTicket(params EntryTicketWhereUniqueInput) *EntryTicketExec {
	ret := client.Client.Delete(
		params,
		[2]string{"EntryTicketWhereUniqueInput!", "EntryTicket"},
		"deleteEntryTicket",
		[]string{"id", "createdAt", "updatedAt", "at"})

	return &EntryTicketExec{ret}
}

func (client *Client) DeleteManyEntryTickets(params *EntryTicketWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "EntryTicketWhereInput", "deleteManyEntryTickets")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateError(params ErrorCreateInput) *ErrorExec {
	ret := client.Client.Create(
		params,
		[2]string{"ErrorCreateInput!", "Error"},
		"createError",
		[]string{"id", "createdAt", "updatedAt", "code", "internal", "explain", "location"})

	return &ErrorExec{ret}
}

type ErrorUpdateParams struct {
	Data  ErrorUpdateInput      `json:"data"`
	Where ErrorWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateError(params ErrorUpdateParams) *ErrorExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ErrorUpdateInput!", "ErrorWhereUniqueInput!", "Error"},
		"updateError",
		[]string{"id", "createdAt", "updatedAt", "code", "internal", "explain", "location"})

	return &ErrorExec{ret}
}

type ErrorUpdateManyParams struct {
	Data  ErrorUpdateManyMutationInput `json:"data"`
	Where *ErrorWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyErrors(params ErrorUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ErrorUpdateManyMutationInput!", "ErrorWhereInput"},
		"updateManyErrors")
	return &BatchPayloadExec{exec}
}

type ErrorUpsertParams struct {
	Where  ErrorWhereUniqueInput `json:"where"`
	Create ErrorCreateInput      `json:"create"`
	Update ErrorUpdateInput      `json:"update"`
}

func (client *Client) UpsertError(params ErrorUpsertParams) *ErrorExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ErrorWhereUniqueInput!", "ErrorCreateInput!", "ErrorUpdateInput!", "Error"},
		"upsertError",
		[]string{"id", "createdAt", "updatedAt", "code", "internal", "explain", "location"})

	return &ErrorExec{ret}
}

func (client *Client) DeleteError(params ErrorWhereUniqueInput) *ErrorExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ErrorWhereUniqueInput!", "Error"},
		"deleteError",
		[]string{"id", "createdAt", "updatedAt", "code", "internal", "explain", "location"})

	return &ErrorExec{ret}
}

func (client *Client) DeleteManyErrors(params *ErrorWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ErrorWhereInput", "deleteManyErrors")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateExpert(params ExpertCreateInput) *ExpertExec {
	ret := client.Client.Create(
		params,
		[2]string{"ExpertCreateInput!", "Expert"},
		"createExpert",
		[]string{"id", "createdAt", "updatedAt", "alias"})

	return &ExpertExec{ret}
}

type ExpertUpdateParams struct {
	Data  ExpertUpdateInput      `json:"data"`
	Where ExpertWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateExpert(params ExpertUpdateParams) *ExpertExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ExpertUpdateInput!", "ExpertWhereUniqueInput!", "Expert"},
		"updateExpert",
		[]string{"id", "createdAt", "updatedAt", "alias"})

	return &ExpertExec{ret}
}

type ExpertUpdateManyParams struct {
	Data  ExpertUpdateManyMutationInput `json:"data"`
	Where *ExpertWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyExperts(params ExpertUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ExpertUpdateManyMutationInput!", "ExpertWhereInput"},
		"updateManyExperts")
	return &BatchPayloadExec{exec}
}

type ExpertUpsertParams struct {
	Where  ExpertWhereUniqueInput `json:"where"`
	Create ExpertCreateInput      `json:"create"`
	Update ExpertUpdateInput      `json:"update"`
}

func (client *Client) UpsertExpert(params ExpertUpsertParams) *ExpertExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ExpertWhereUniqueInput!", "ExpertCreateInput!", "ExpertUpdateInput!", "Expert"},
		"upsertExpert",
		[]string{"id", "createdAt", "updatedAt", "alias"})

	return &ExpertExec{ret}
}

func (client *Client) DeleteExpert(params ExpertWhereUniqueInput) *ExpertExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ExpertWhereUniqueInput!", "Expert"},
		"deleteExpert",
		[]string{"id", "createdAt", "updatedAt", "alias"})

	return &ExpertExec{ret}
}

func (client *Client) DeleteManyExperts(params *ExpertWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ExpertWhereInput", "deleteManyExperts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateFaq(params FaqCreateInput) *FaqExec {
	ret := client.Client.Create(
		params,
		[2]string{"FaqCreateInput!", "Faq"},
		"createFaq",
		[]string{"id", "createdAt", "updatedAt"})

	return &FaqExec{ret}
}

type FaqUpdateParams struct {
	Data  FaqUpdateInput      `json:"data"`
	Where FaqWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateFaq(params FaqUpdateParams) *FaqExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"FaqUpdateInput!", "FaqWhereUniqueInput!", "Faq"},
		"updateFaq",
		[]string{"id", "createdAt", "updatedAt"})

	return &FaqExec{ret}
}

type FaqUpsertParams struct {
	Where  FaqWhereUniqueInput `json:"where"`
	Create FaqCreateInput      `json:"create"`
	Update FaqUpdateInput      `json:"update"`
}

func (client *Client) UpsertFaq(params FaqUpsertParams) *FaqExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"FaqWhereUniqueInput!", "FaqCreateInput!", "FaqUpdateInput!", "Faq"},
		"upsertFaq",
		[]string{"id", "createdAt", "updatedAt"})

	return &FaqExec{ret}
}

func (client *Client) DeleteFaq(params FaqWhereUniqueInput) *FaqExec {
	ret := client.Client.Delete(
		params,
		[2]string{"FaqWhereUniqueInput!", "Faq"},
		"deleteFaq",
		[]string{"id", "createdAt", "updatedAt"})

	return &FaqExec{ret}
}

func (client *Client) DeleteManyFaqs(params *FaqWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "FaqWhereInput", "deleteManyFaqs")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateFaqEntry(params FaqEntryCreateInput) *FaqEntryExec {
	ret := client.Client.Create(
		params,
		[2]string{"FaqEntryCreateInput!", "FaqEntry"},
		"createFaqEntry",
		[]string{"id"})

	return &FaqEntryExec{ret}
}

type FaqEntryUpdateParams struct {
	Data  FaqEntryUpdateInput      `json:"data"`
	Where FaqEntryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateFaqEntry(params FaqEntryUpdateParams) *FaqEntryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"FaqEntryUpdateInput!", "FaqEntryWhereUniqueInput!", "FaqEntry"},
		"updateFaqEntry",
		[]string{"id"})

	return &FaqEntryExec{ret}
}

type FaqEntryUpsertParams struct {
	Where  FaqEntryWhereUniqueInput `json:"where"`
	Create FaqEntryCreateInput      `json:"create"`
	Update FaqEntryUpdateInput      `json:"update"`
}

func (client *Client) UpsertFaqEntry(params FaqEntryUpsertParams) *FaqEntryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"FaqEntryWhereUniqueInput!", "FaqEntryCreateInput!", "FaqEntryUpdateInput!", "FaqEntry"},
		"upsertFaqEntry",
		[]string{"id"})

	return &FaqEntryExec{ret}
}

func (client *Client) DeleteFaqEntry(params FaqEntryWhereUniqueInput) *FaqEntryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"FaqEntryWhereUniqueInput!", "FaqEntry"},
		"deleteFaqEntry",
		[]string{"id"})

	return &FaqEntryExec{ret}
}

func (client *Client) DeleteManyFaqEntries(params *FaqEntryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "FaqEntryWhereInput", "deleteManyFaqEntries")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateFeature(params FeatureCreateInput) *FeatureExec {
	ret := client.Client.Create(
		params,
		[2]string{"FeatureCreateInput!", "Feature"},
		"createFeature",
		[]string{"id", "image"})

	return &FeatureExec{ret}
}

type FeatureUpdateParams struct {
	Data  FeatureUpdateInput      `json:"data"`
	Where FeatureWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateFeature(params FeatureUpdateParams) *FeatureExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"FeatureUpdateInput!", "FeatureWhereUniqueInput!", "Feature"},
		"updateFeature",
		[]string{"id", "image"})

	return &FeatureExec{ret}
}

type FeatureUpdateManyParams struct {
	Data  FeatureUpdateManyMutationInput `json:"data"`
	Where *FeatureWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyFeatures(params FeatureUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"FeatureUpdateManyMutationInput!", "FeatureWhereInput"},
		"updateManyFeatures")
	return &BatchPayloadExec{exec}
}

type FeatureUpsertParams struct {
	Where  FeatureWhereUniqueInput `json:"where"`
	Create FeatureCreateInput      `json:"create"`
	Update FeatureUpdateInput      `json:"update"`
}

func (client *Client) UpsertFeature(params FeatureUpsertParams) *FeatureExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"FeatureWhereUniqueInput!", "FeatureCreateInput!", "FeatureUpdateInput!", "Feature"},
		"upsertFeature",
		[]string{"id", "image"})

	return &FeatureExec{ret}
}

func (client *Client) DeleteFeature(params FeatureWhereUniqueInput) *FeatureExec {
	ret := client.Client.Delete(
		params,
		[2]string{"FeatureWhereUniqueInput!", "Feature"},
		"deleteFeature",
		[]string{"id", "image"})

	return &FeatureExec{ret}
}

func (client *Client) DeleteManyFeatures(params *FeatureWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "FeatureWhereInput", "deleteManyFeatures")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateIdDocument(params IDDocumentCreateInput) *IDDocumentExec {
	ret := client.Client.Create(
		params,
		[2]string{"IDDocumentCreateInput!", "IDDocument"},
		"createIDDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDDocumentExec{ret}
}

type IDDocumentUpdateParams struct {
	Data  IDDocumentUpdateInput      `json:"data"`
	Where IDDocumentWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateIdDocument(params IDDocumentUpdateParams) *IDDocumentExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"IDDocumentUpdateInput!", "IDDocumentWhereUniqueInput!", "IDDocument"},
		"updateIDDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDDocumentExec{ret}
}

type IDDocumentUpdateManyParams struct {
	Data  IDDocumentUpdateManyMutationInput `json:"data"`
	Where *IDDocumentWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyIdDocuments(params IDDocumentUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"IDDocumentUpdateManyMutationInput!", "IDDocumentWhereInput"},
		"updateManyIDDocuments")
	return &BatchPayloadExec{exec}
}

type IDDocumentUpsertParams struct {
	Where  IDDocumentWhereUniqueInput `json:"where"`
	Create IDDocumentCreateInput      `json:"create"`
	Update IDDocumentUpdateInput      `json:"update"`
}

func (client *Client) UpsertIdDocument(params IDDocumentUpsertParams) *IDDocumentExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"IDDocumentWhereUniqueInput!", "IDDocumentCreateInput!", "IDDocumentUpdateInput!", "IDDocument"},
		"upsertIDDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDDocumentExec{ret}
}

func (client *Client) DeleteIdDocument(params IDDocumentWhereUniqueInput) *IDDocumentExec {
	ret := client.Client.Delete(
		params,
		[2]string{"IDDocumentWhereUniqueInput!", "IDDocument"},
		"deleteIDDocument",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDDocumentExec{ret}
}

func (client *Client) DeleteManyIdDocuments(params *IDDocumentWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "IDDocumentWhereInput", "deleteManyIDDocuments")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateLima(params LimaCreateInput) *LimaExec {
	ret := client.Client.Create(
		params,
		[2]string{"LimaCreateInput!", "Lima"},
		"createLima",
		[]string{"id", "createdAt", "updatedAt", "version", "available"})

	return &LimaExec{ret}
}

type LimaUpdateParams struct {
	Data  LimaUpdateInput      `json:"data"`
	Where LimaWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateLima(params LimaUpdateParams) *LimaExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"LimaUpdateInput!", "LimaWhereUniqueInput!", "Lima"},
		"updateLima",
		[]string{"id", "createdAt", "updatedAt", "version", "available"})

	return &LimaExec{ret}
}

type LimaUpdateManyParams struct {
	Data  LimaUpdateManyMutationInput `json:"data"`
	Where *LimaWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyLimas(params LimaUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"LimaUpdateManyMutationInput!", "LimaWhereInput"},
		"updateManyLimas")
	return &BatchPayloadExec{exec}
}

type LimaUpsertParams struct {
	Where  LimaWhereUniqueInput `json:"where"`
	Create LimaCreateInput      `json:"create"`
	Update LimaUpdateInput      `json:"update"`
}

func (client *Client) UpsertLima(params LimaUpsertParams) *LimaExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"LimaWhereUniqueInput!", "LimaCreateInput!", "LimaUpdateInput!", "Lima"},
		"upsertLima",
		[]string{"id", "createdAt", "updatedAt", "version", "available"})

	return &LimaExec{ret}
}

func (client *Client) DeleteLima(params LimaWhereUniqueInput) *LimaExec {
	ret := client.Client.Delete(
		params,
		[2]string{"LimaWhereUniqueInput!", "Lima"},
		"deleteLima",
		[]string{"id", "createdAt", "updatedAt", "version", "available"})

	return &LimaExec{ret}
}

func (client *Client) DeleteManyLimas(params *LimaWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "LimaWhereInput", "deleteManyLimas")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateLimaContact(params LimaContactCreateInput) *LimaContactExec {
	ret := client.Client.Create(
		params,
		[2]string{"LimaContactCreateInput!", "LimaContact"},
		"createLimaContact",
		[]string{"id", "email", "phoneNumber"})

	return &LimaContactExec{ret}
}

type LimaContactUpdateParams struct {
	Data  LimaContactUpdateInput      `json:"data"`
	Where LimaContactWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateLimaContact(params LimaContactUpdateParams) *LimaContactExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"LimaContactUpdateInput!", "LimaContactWhereUniqueInput!", "LimaContact"},
		"updateLimaContact",
		[]string{"id", "email", "phoneNumber"})

	return &LimaContactExec{ret}
}

type LimaContactUpdateManyParams struct {
	Data  LimaContactUpdateManyMutationInput `json:"data"`
	Where *LimaContactWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyLimaContacts(params LimaContactUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"LimaContactUpdateManyMutationInput!", "LimaContactWhereInput"},
		"updateManyLimaContacts")
	return &BatchPayloadExec{exec}
}

type LimaContactUpsertParams struct {
	Where  LimaContactWhereUniqueInput `json:"where"`
	Create LimaContactCreateInput      `json:"create"`
	Update LimaContactUpdateInput      `json:"update"`
}

func (client *Client) UpsertLimaContact(params LimaContactUpsertParams) *LimaContactExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"LimaContactWhereUniqueInput!", "LimaContactCreateInput!", "LimaContactUpdateInput!", "LimaContact"},
		"upsertLimaContact",
		[]string{"id", "email", "phoneNumber"})

	return &LimaContactExec{ret}
}

func (client *Client) DeleteLimaContact(params LimaContactWhereUniqueInput) *LimaContactExec {
	ret := client.Client.Delete(
		params,
		[2]string{"LimaContactWhereUniqueInput!", "LimaContact"},
		"deleteLimaContact",
		[]string{"id", "email", "phoneNumber"})

	return &LimaContactExec{ret}
}

func (client *Client) DeleteManyLimaContacts(params *LimaContactWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "LimaContactWhereInput", "deleteManyLimaContacts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateLocation(params LocationCreateInput) *LocationExec {
	ret := client.Client.Create(
		params,
		[2]string{"LocationCreateInput!", "Location"},
		"createLocation",
		[]string{"id", "createdAt", "updatedAt", "longitude", "latitude"})

	return &LocationExec{ret}
}

type LocationUpdateParams struct {
	Data  LocationUpdateInput      `json:"data"`
	Where LocationWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateLocation(params LocationUpdateParams) *LocationExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"LocationUpdateInput!", "LocationWhereUniqueInput!", "Location"},
		"updateLocation",
		[]string{"id", "createdAt", "updatedAt", "longitude", "latitude"})

	return &LocationExec{ret}
}

type LocationUpdateManyParams struct {
	Data  LocationUpdateManyMutationInput `json:"data"`
	Where *LocationWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyLocations(params LocationUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"LocationUpdateManyMutationInput!", "LocationWhereInput"},
		"updateManyLocations")
	return &BatchPayloadExec{exec}
}

type LocationUpsertParams struct {
	Where  LocationWhereUniqueInput `json:"where"`
	Create LocationCreateInput      `json:"create"`
	Update LocationUpdateInput      `json:"update"`
}

func (client *Client) UpsertLocation(params LocationUpsertParams) *LocationExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"LocationWhereUniqueInput!", "LocationCreateInput!", "LocationUpdateInput!", "Location"},
		"upsertLocation",
		[]string{"id", "createdAt", "updatedAt", "longitude", "latitude"})

	return &LocationExec{ret}
}

func (client *Client) DeleteLocation(params LocationWhereUniqueInput) *LocationExec {
	ret := client.Client.Delete(
		params,
		[2]string{"LocationWhereUniqueInput!", "Location"},
		"deleteLocation",
		[]string{"id", "createdAt", "updatedAt", "longitude", "latitude"})

	return &LocationExec{ret}
}

func (client *Client) DeleteManyLocations(params *LocationWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "LocationWhereInput", "deleteManyLocations")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateOpeningHours(params OpeningHoursCreateInput) *OpeningHoursExec {
	ret := client.Client.Create(
		params,
		[2]string{"OpeningHoursCreateInput!", "OpeningHours"},
		"createOpeningHours",
		[]string{"id", "mon", "tue", "wed", "thu", "fri", "sat", "sun"})

	return &OpeningHoursExec{ret}
}

type OpeningHoursUpdateParams struct {
	Data  OpeningHoursUpdateInput      `json:"data"`
	Where OpeningHoursWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateOpeningHours(params OpeningHoursUpdateParams) *OpeningHoursExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"OpeningHoursUpdateInput!", "OpeningHoursWhereUniqueInput!", "OpeningHours"},
		"updateOpeningHours",
		[]string{"id", "mon", "tue", "wed", "thu", "fri", "sat", "sun"})

	return &OpeningHoursExec{ret}
}

type OpeningHoursUpdateManyParams struct {
	Data  OpeningHoursUpdateManyMutationInput `json:"data"`
	Where *OpeningHoursWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyOpeningHourses(params OpeningHoursUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"OpeningHoursUpdateManyMutationInput!", "OpeningHoursWhereInput"},
		"updateManyOpeningHourses")
	return &BatchPayloadExec{exec}
}

type OpeningHoursUpsertParams struct {
	Where  OpeningHoursWhereUniqueInput `json:"where"`
	Create OpeningHoursCreateInput      `json:"create"`
	Update OpeningHoursUpdateInput      `json:"update"`
}

func (client *Client) UpsertOpeningHours(params OpeningHoursUpsertParams) *OpeningHoursExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"OpeningHoursWhereUniqueInput!", "OpeningHoursCreateInput!", "OpeningHoursUpdateInput!", "OpeningHours"},
		"upsertOpeningHours",
		[]string{"id", "mon", "tue", "wed", "thu", "fri", "sat", "sun"})

	return &OpeningHoursExec{ret}
}

func (client *Client) DeleteOpeningHours(params OpeningHoursWhereUniqueInput) *OpeningHoursExec {
	ret := client.Client.Delete(
		params,
		[2]string{"OpeningHoursWhereUniqueInput!", "OpeningHours"},
		"deleteOpeningHours",
		[]string{"id", "mon", "tue", "wed", "thu", "fri", "sat", "sun"})

	return &OpeningHoursExec{ret}
}

func (client *Client) DeleteManyOpeningHourses(params *OpeningHoursWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "OpeningHoursWhereInput", "deleteManyOpeningHourses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePartner(params PartnerCreateInput) *PartnerExec {
	ret := client.Client.Create(
		params,
		[2]string{"PartnerCreateInput!", "Partner"},
		"createPartner",
		[]string{"id", "createdAt", "updatedAt", "brandName", "logo", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

type PartnerUpdateParams struct {
	Data  PartnerUpdateInput      `json:"data"`
	Where PartnerWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePartner(params PartnerUpdateParams) *PartnerExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PartnerUpdateInput!", "PartnerWhereUniqueInput!", "Partner"},
		"updatePartner",
		[]string{"id", "createdAt", "updatedAt", "brandName", "logo", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

type PartnerUpdateManyParams struct {
	Data  PartnerUpdateManyMutationInput `json:"data"`
	Where *PartnerWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPartners(params PartnerUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PartnerUpdateManyMutationInput!", "PartnerWhereInput"},
		"updateManyPartners")
	return &BatchPayloadExec{exec}
}

type PartnerUpsertParams struct {
	Where  PartnerWhereUniqueInput `json:"where"`
	Create PartnerCreateInput      `json:"create"`
	Update PartnerUpdateInput      `json:"update"`
}

func (client *Client) UpsertPartner(params PartnerUpsertParams) *PartnerExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PartnerWhereUniqueInput!", "PartnerCreateInput!", "PartnerUpdateInput!", "Partner"},
		"upsertPartner",
		[]string{"id", "createdAt", "updatedAt", "brandName", "logo", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

func (client *Client) DeletePartner(params PartnerWhereUniqueInput) *PartnerExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PartnerWhereUniqueInput!", "Partner"},
		"deletePartner",
		[]string{"id", "createdAt", "updatedAt", "brandName", "logo", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

func (client *Client) DeleteManyPartners(params *PartnerWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PartnerWhereInput", "deleteManyPartners")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePass(params PassCreateInput) *PassExec {
	ret := client.Client.Create(
		params,
		[2]string{"PassCreateInput!", "Pass"},
		"createPass",
		[]string{"id", "createdAt", "updatedAt", "expireAt", "state"})

	return &PassExec{ret}
}

type PassUpdateParams struct {
	Data  PassUpdateInput      `json:"data"`
	Where PassWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePass(params PassUpdateParams) *PassExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PassUpdateInput!", "PassWhereUniqueInput!", "Pass"},
		"updatePass",
		[]string{"id", "createdAt", "updatedAt", "expireAt", "state"})

	return &PassExec{ret}
}

type PassUpdateManyParams struct {
	Data  PassUpdateManyMutationInput `json:"data"`
	Where *PassWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPasses(params PassUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PassUpdateManyMutationInput!", "PassWhereInput"},
		"updateManyPasses")
	return &BatchPayloadExec{exec}
}

type PassUpsertParams struct {
	Where  PassWhereUniqueInput `json:"where"`
	Create PassCreateInput      `json:"create"`
	Update PassUpdateInput      `json:"update"`
}

func (client *Client) UpsertPass(params PassUpsertParams) *PassExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PassWhereUniqueInput!", "PassCreateInput!", "PassUpdateInput!", "Pass"},
		"upsertPass",
		[]string{"id", "createdAt", "updatedAt", "expireAt", "state"})

	return &PassExec{ret}
}

func (client *Client) DeletePass(params PassWhereUniqueInput) *PassExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PassWhereUniqueInput!", "Pass"},
		"deletePass",
		[]string{"id", "createdAt", "updatedAt", "expireAt", "state"})

	return &PassExec{ret}
}

func (client *Client) DeleteManyPasses(params *PassWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PassWhereInput", "deleteManyPasses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePassType(params PassTypeCreateInput) *PassTypeExec {
	ret := client.Client.Create(
		params,
		[2]string{"PassTypeCreateInput!", "PassType"},
		"createPassType",
		[]string{"id", "createdAt", "updatedAt", "gallery", "creatorID", "duration"})

	return &PassTypeExec{ret}
}

type PassTypeUpdateParams struct {
	Data  PassTypeUpdateInput      `json:"data"`
	Where PassTypeWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePassType(params PassTypeUpdateParams) *PassTypeExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PassTypeUpdateInput!", "PassTypeWhereUniqueInput!", "PassType"},
		"updatePassType",
		[]string{"id", "createdAt", "updatedAt", "gallery", "creatorID", "duration"})

	return &PassTypeExec{ret}
}

type PassTypeUpdateManyParams struct {
	Data  PassTypeUpdateManyMutationInput `json:"data"`
	Where *PassTypeWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPassTypes(params PassTypeUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PassTypeUpdateManyMutationInput!", "PassTypeWhereInput"},
		"updateManyPassTypes")
	return &BatchPayloadExec{exec}
}

type PassTypeUpsertParams struct {
	Where  PassTypeWhereUniqueInput `json:"where"`
	Create PassTypeCreateInput      `json:"create"`
	Update PassTypeUpdateInput      `json:"update"`
}

func (client *Client) UpsertPassType(params PassTypeUpsertParams) *PassTypeExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PassTypeWhereUniqueInput!", "PassTypeCreateInput!", "PassTypeUpdateInput!", "PassType"},
		"upsertPassType",
		[]string{"id", "createdAt", "updatedAt", "gallery", "creatorID", "duration"})

	return &PassTypeExec{ret}
}

func (client *Client) DeletePassType(params PassTypeWhereUniqueInput) *PassTypeExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PassTypeWhereUniqueInput!", "PassType"},
		"deletePassType",
		[]string{"id", "createdAt", "updatedAt", "gallery", "creatorID", "duration"})

	return &PassTypeExec{ret}
}

func (client *Client) DeleteManyPassTypes(params *PassTypeWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PassTypeWhereInput", "deleteManyPassTypes")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePaymentMethod(params PaymentMethodCreateInput) *PaymentMethodExec {
	ret := client.Client.Create(
		params,
		[2]string{"PaymentMethodCreateInput!", "PaymentMethod"},
		"createPaymentMethod",
		[]string{"id", "type", "value", "cardNumber", "code"})

	return &PaymentMethodExec{ret}
}

type PaymentMethodUpdateParams struct {
	Data  PaymentMethodUpdateInput      `json:"data"`
	Where PaymentMethodWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePaymentMethod(params PaymentMethodUpdateParams) *PaymentMethodExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PaymentMethodUpdateInput!", "PaymentMethodWhereUniqueInput!", "PaymentMethod"},
		"updatePaymentMethod",
		[]string{"id", "type", "value", "cardNumber", "code"})

	return &PaymentMethodExec{ret}
}

type PaymentMethodUpdateManyParams struct {
	Data  PaymentMethodUpdateManyMutationInput `json:"data"`
	Where *PaymentMethodWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPaymentMethods(params PaymentMethodUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PaymentMethodUpdateManyMutationInput!", "PaymentMethodWhereInput"},
		"updateManyPaymentMethods")
	return &BatchPayloadExec{exec}
}

type PaymentMethodUpsertParams struct {
	Where  PaymentMethodWhereUniqueInput `json:"where"`
	Create PaymentMethodCreateInput      `json:"create"`
	Update PaymentMethodUpdateInput      `json:"update"`
}

func (client *Client) UpsertPaymentMethod(params PaymentMethodUpsertParams) *PaymentMethodExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PaymentMethodWhereUniqueInput!", "PaymentMethodCreateInput!", "PaymentMethodUpdateInput!", "PaymentMethod"},
		"upsertPaymentMethod",
		[]string{"id", "type", "value", "cardNumber", "code"})

	return &PaymentMethodExec{ret}
}

func (client *Client) DeletePaymentMethod(params PaymentMethodWhereUniqueInput) *PaymentMethodExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PaymentMethodWhereUniqueInput!", "PaymentMethod"},
		"deletePaymentMethod",
		[]string{"id", "type", "value", "cardNumber", "code"})

	return &PaymentMethodExec{ret}
}

func (client *Client) DeleteManyPaymentMethods(params *PaymentMethodWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PaymentMethodWhereInput", "deleteManyPaymentMethods")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePerson(params PersonCreateInput) *PersonExec {
	ret := client.Client.Create(
		params,
		[2]string{"PersonCreateInput!", "Person"},
		"createPerson",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

type PersonUpdateParams struct {
	Data  PersonUpdateInput      `json:"data"`
	Where PersonWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePerson(params PersonUpdateParams) *PersonExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PersonUpdateInput!", "PersonWhereUniqueInput!", "Person"},
		"updatePerson",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

type PersonUpdateManyParams struct {
	Data  PersonUpdateManyMutationInput `json:"data"`
	Where *PersonWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPersons(params PersonUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PersonUpdateManyMutationInput!", "PersonWhereInput"},
		"updateManyPersons")
	return &BatchPayloadExec{exec}
}

type PersonUpsertParams struct {
	Where  PersonWhereUniqueInput `json:"where"`
	Create PersonCreateInput      `json:"create"`
	Update PersonUpdateInput      `json:"update"`
}

func (client *Client) UpsertPerson(params PersonUpsertParams) *PersonExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PersonWhereUniqueInput!", "PersonCreateInput!", "PersonUpdateInput!", "Person"},
		"upsertPerson",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

func (client *Client) DeletePerson(params PersonWhereUniqueInput) *PersonExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PersonWhereUniqueInput!", "Person"},
		"deletePerson",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

func (client *Client) DeleteManyPersons(params *PersonWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PersonWhereInput", "deleteManyPersons")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePersonReviews(params PersonReviewsCreateInput) *PersonReviewsExec {
	ret := client.Client.Create(
		params,
		[2]string{"PersonReviewsCreateInput!", "PersonReviews"},
		"createPersonReviews",
		[]string{"id", "createdAt", "updatedAt", "approveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

type PersonReviewsUpdateParams struct {
	Data  PersonReviewsUpdateInput      `json:"data"`
	Where PersonReviewsWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePersonReviews(params PersonReviewsUpdateParams) *PersonReviewsExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PersonReviewsUpdateInput!", "PersonReviewsWhereUniqueInput!", "PersonReviews"},
		"updatePersonReviews",
		[]string{"id", "createdAt", "updatedAt", "approveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

type PersonReviewsUpdateManyParams struct {
	Data  PersonReviewsUpdateManyMutationInput `json:"data"`
	Where *PersonReviewsWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPersonReviewses(params PersonReviewsUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PersonReviewsUpdateManyMutationInput!", "PersonReviewsWhereInput"},
		"updateManyPersonReviewses")
	return &BatchPayloadExec{exec}
}

type PersonReviewsUpsertParams struct {
	Where  PersonReviewsWhereUniqueInput `json:"where"`
	Create PersonReviewsCreateInput      `json:"create"`
	Update PersonReviewsUpdateInput      `json:"update"`
}

func (client *Client) UpsertPersonReviews(params PersonReviewsUpsertParams) *PersonReviewsExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PersonReviewsWhereUniqueInput!", "PersonReviewsCreateInput!", "PersonReviewsUpdateInput!", "PersonReviews"},
		"upsertPersonReviews",
		[]string{"id", "createdAt", "updatedAt", "approveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

func (client *Client) DeletePersonReviews(params PersonReviewsWhereUniqueInput) *PersonReviewsExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PersonReviewsWhereUniqueInput!", "PersonReviews"},
		"deletePersonReviews",
		[]string{"id", "createdAt", "updatedAt", "approveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

func (client *Client) DeleteManyPersonReviewses(params *PersonReviewsWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PersonReviewsWhereInput", "deleteManyPersonReviewses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePhoneChannel(params PhoneChannelCreateInput) *PhoneChannelExec {
	ret := client.Client.Create(
		params,
		[2]string{"PhoneChannelCreateInput!", "PhoneChannel"},
		"createPhoneChannel",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

type PhoneChannelUpdateParams struct {
	Data  PhoneChannelUpdateInput      `json:"data"`
	Where PhoneChannelWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePhoneChannel(params PhoneChannelUpdateParams) *PhoneChannelExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PhoneChannelUpdateInput!", "PhoneChannelWhereUniqueInput!", "PhoneChannel"},
		"updatePhoneChannel",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

type PhoneChannelUpdateManyParams struct {
	Data  PhoneChannelUpdateManyMutationInput `json:"data"`
	Where *PhoneChannelWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPhoneChannels(params PhoneChannelUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PhoneChannelUpdateManyMutationInput!", "PhoneChannelWhereInput"},
		"updateManyPhoneChannels")
	return &BatchPayloadExec{exec}
}

type PhoneChannelUpsertParams struct {
	Where  PhoneChannelWhereUniqueInput `json:"where"`
	Create PhoneChannelCreateInput      `json:"create"`
	Update PhoneChannelUpdateInput      `json:"update"`
}

func (client *Client) UpsertPhoneChannel(params PhoneChannelUpsertParams) *PhoneChannelExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PhoneChannelWhereUniqueInput!", "PhoneChannelCreateInput!", "PhoneChannelUpdateInput!", "PhoneChannel"},
		"upsertPhoneChannel",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

func (client *Client) DeletePhoneChannel(params PhoneChannelWhereUniqueInput) *PhoneChannelExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PhoneChannelWhereUniqueInput!", "PhoneChannel"},
		"deletePhoneChannel",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

func (client *Client) DeleteManyPhoneChannels(params *PhoneChannelWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PhoneChannelWhereInput", "deleteManyPhoneChannels")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePlace(params PlaceCreateInput) *PlaceExec {
	ret := client.Client.Create(
		params,
		[2]string{"PlaceCreateInput!", "Place"},
		"createPlace",
		[]string{"id", "createdAt", "updatedAt", "name", "shortName", "address", "googleLink", "website", "type", "extraTypes", "tags", "popularity", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &PlaceExec{ret}
}

type PlaceUpdateParams struct {
	Data  PlaceUpdateInput      `json:"data"`
	Where PlaceWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePlace(params PlaceUpdateParams) *PlaceExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PlaceUpdateInput!", "PlaceWhereUniqueInput!", "Place"},
		"updatePlace",
		[]string{"id", "createdAt", "updatedAt", "name", "shortName", "address", "googleLink", "website", "type", "extraTypes", "tags", "popularity", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &PlaceExec{ret}
}

type PlaceUpdateManyParams struct {
	Data  PlaceUpdateManyMutationInput `json:"data"`
	Where *PlaceWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPlaces(params PlaceUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PlaceUpdateManyMutationInput!", "PlaceWhereInput"},
		"updateManyPlaces")
	return &BatchPayloadExec{exec}
}

type PlaceUpsertParams struct {
	Where  PlaceWhereUniqueInput `json:"where"`
	Create PlaceCreateInput      `json:"create"`
	Update PlaceUpdateInput      `json:"update"`
}

func (client *Client) UpsertPlace(params PlaceUpsertParams) *PlaceExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PlaceWhereUniqueInput!", "PlaceCreateInput!", "PlaceUpdateInput!", "Place"},
		"upsertPlace",
		[]string{"id", "createdAt", "updatedAt", "name", "shortName", "address", "googleLink", "website", "type", "extraTypes", "tags", "popularity", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &PlaceExec{ret}
}

func (client *Client) DeletePlace(params PlaceWhereUniqueInput) *PlaceExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PlaceWhereUniqueInput!", "Place"},
		"deletePlace",
		[]string{"id", "createdAt", "updatedAt", "name", "shortName", "address", "googleLink", "website", "type", "extraTypes", "tags", "popularity", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &PlaceExec{ret}
}

func (client *Client) DeleteManyPlaces(params *PlaceWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PlaceWhereInput", "deleteManyPlaces")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateProductEntry(params ProductEntryCreateInput) *ProductEntryExec {
	ret := client.Client.Create(
		params,
		[2]string{"ProductEntryCreateInput!", "ProductEntry"},
		"createProductEntry",
		[]string{"id", "parentID", "name", "description", "quantity", "cost", "currencyCode"})

	return &ProductEntryExec{ret}
}

type ProductEntryUpdateParams struct {
	Data  ProductEntryUpdateInput      `json:"data"`
	Where ProductEntryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateProductEntry(params ProductEntryUpdateParams) *ProductEntryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ProductEntryUpdateInput!", "ProductEntryWhereUniqueInput!", "ProductEntry"},
		"updateProductEntry",
		[]string{"id", "parentID", "name", "description", "quantity", "cost", "currencyCode"})

	return &ProductEntryExec{ret}
}

type ProductEntryUpdateManyParams struct {
	Data  ProductEntryUpdateManyMutationInput `json:"data"`
	Where *ProductEntryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyProductEntries(params ProductEntryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ProductEntryUpdateManyMutationInput!", "ProductEntryWhereInput"},
		"updateManyProductEntries")
	return &BatchPayloadExec{exec}
}

type ProductEntryUpsertParams struct {
	Where  ProductEntryWhereUniqueInput `json:"where"`
	Create ProductEntryCreateInput      `json:"create"`
	Update ProductEntryUpdateInput      `json:"update"`
}

func (client *Client) UpsertProductEntry(params ProductEntryUpsertParams) *ProductEntryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ProductEntryWhereUniqueInput!", "ProductEntryCreateInput!", "ProductEntryUpdateInput!", "ProductEntry"},
		"upsertProductEntry",
		[]string{"id", "parentID", "name", "description", "quantity", "cost", "currencyCode"})

	return &ProductEntryExec{ret}
}

func (client *Client) DeleteProductEntry(params ProductEntryWhereUniqueInput) *ProductEntryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ProductEntryWhereUniqueInput!", "ProductEntry"},
		"deleteProductEntry",
		[]string{"id", "parentID", "name", "description", "quantity", "cost", "currencyCode"})

	return &ProductEntryExec{ret}
}

func (client *Client) DeleteManyProductEntries(params *ProductEntryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ProductEntryWhereInput", "deleteManyProductEntries")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePurchase(params PurchaseCreateInput) *PurchaseExec {
	ret := client.Client.Create(
		params,
		[2]string{"PurchaseCreateInput!", "Purchase"},
		"createPurchase",
		[]string{"id", "createdAt", "updatedAt", "chargeToken", "gatewayResponse", "discountID", "discount"})

	return &PurchaseExec{ret}
}

type PurchaseUpdateParams struct {
	Data  PurchaseUpdateInput      `json:"data"`
	Where PurchaseWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePurchase(params PurchaseUpdateParams) *PurchaseExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PurchaseUpdateInput!", "PurchaseWhereUniqueInput!", "Purchase"},
		"updatePurchase",
		[]string{"id", "createdAt", "updatedAt", "chargeToken", "gatewayResponse", "discountID", "discount"})

	return &PurchaseExec{ret}
}

type PurchaseUpdateManyParams struct {
	Data  PurchaseUpdateManyMutationInput `json:"data"`
	Where *PurchaseWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPurchases(params PurchaseUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PurchaseUpdateManyMutationInput!", "PurchaseWhereInput"},
		"updateManyPurchases")
	return &BatchPayloadExec{exec}
}

type PurchaseUpsertParams struct {
	Where  PurchaseWhereUniqueInput `json:"where"`
	Create PurchaseCreateInput      `json:"create"`
	Update PurchaseUpdateInput      `json:"update"`
}

func (client *Client) UpsertPurchase(params PurchaseUpsertParams) *PurchaseExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PurchaseWhereUniqueInput!", "PurchaseCreateInput!", "PurchaseUpdateInput!", "Purchase"},
		"upsertPurchase",
		[]string{"id", "createdAt", "updatedAt", "chargeToken", "gatewayResponse", "discountID", "discount"})

	return &PurchaseExec{ret}
}

func (client *Client) DeletePurchase(params PurchaseWhereUniqueInput) *PurchaseExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PurchaseWhereUniqueInput!", "Purchase"},
		"deletePurchase",
		[]string{"id", "createdAt", "updatedAt", "chargeToken", "gatewayResponse", "discountID", "discount"})

	return &PurchaseExec{ret}
}

func (client *Client) DeleteManyPurchases(params *PurchaseWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PurchaseWhereInput", "deleteManyPurchases")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateRoute(params RouteCreateInput) *RouteExec {
	ret := client.Client.Create(
		params,
		[2]string{"RouteCreateInput!", "Route"},
		"createRoute",
		[]string{"id", "createdAt", "updatedAt", "name", "image", "type", "extraTypes", "popularity", "color"})

	return &RouteExec{ret}
}

type RouteUpdateParams struct {
	Data  RouteUpdateInput      `json:"data"`
	Where RouteWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateRoute(params RouteUpdateParams) *RouteExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"RouteUpdateInput!", "RouteWhereUniqueInput!", "Route"},
		"updateRoute",
		[]string{"id", "createdAt", "updatedAt", "name", "image", "type", "extraTypes", "popularity", "color"})

	return &RouteExec{ret}
}

type RouteUpdateManyParams struct {
	Data  RouteUpdateManyMutationInput `json:"data"`
	Where *RouteWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyRoutes(params RouteUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"RouteUpdateManyMutationInput!", "RouteWhereInput"},
		"updateManyRoutes")
	return &BatchPayloadExec{exec}
}

type RouteUpsertParams struct {
	Where  RouteWhereUniqueInput `json:"where"`
	Create RouteCreateInput      `json:"create"`
	Update RouteUpdateInput      `json:"update"`
}

func (client *Client) UpsertRoute(params RouteUpsertParams) *RouteExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"RouteWhereUniqueInput!", "RouteCreateInput!", "RouteUpdateInput!", "Route"},
		"upsertRoute",
		[]string{"id", "createdAt", "updatedAt", "name", "image", "type", "extraTypes", "popularity", "color"})

	return &RouteExec{ret}
}

func (client *Client) DeleteRoute(params RouteWhereUniqueInput) *RouteExec {
	ret := client.Client.Delete(
		params,
		[2]string{"RouteWhereUniqueInput!", "Route"},
		"deleteRoute",
		[]string{"id", "createdAt", "updatedAt", "name", "image", "type", "extraTypes", "popularity", "color"})

	return &RouteExec{ret}
}

func (client *Client) DeleteManyRoutes(params *RouteWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "RouteWhereInput", "deleteManyRoutes")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateStory(params StoryCreateInput) *StoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"StoryCreateInput!", "Story"},
		"createStory",
		[]string{"id", "createdAt", "updatedAt", "type", "tags", "podcastLink", "audioStream", "principalImage", "likes", "views"})

	return &StoryExec{ret}
}

type StoryUpdateParams struct {
	Data  StoryUpdateInput      `json:"data"`
	Where StoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateStory(params StoryUpdateParams) *StoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"StoryUpdateInput!", "StoryWhereUniqueInput!", "Story"},
		"updateStory",
		[]string{"id", "createdAt", "updatedAt", "type", "tags", "podcastLink", "audioStream", "principalImage", "likes", "views"})

	return &StoryExec{ret}
}

type StoryUpdateManyParams struct {
	Data  StoryUpdateManyMutationInput `json:"data"`
	Where *StoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyStories(params StoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"StoryUpdateManyMutationInput!", "StoryWhereInput"},
		"updateManyStories")
	return &BatchPayloadExec{exec}
}

type StoryUpsertParams struct {
	Where  StoryWhereUniqueInput `json:"where"`
	Create StoryCreateInput      `json:"create"`
	Update StoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertStory(params StoryUpsertParams) *StoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"StoryWhereUniqueInput!", "StoryCreateInput!", "StoryUpdateInput!", "Story"},
		"upsertStory",
		[]string{"id", "createdAt", "updatedAt", "type", "tags", "podcastLink", "audioStream", "principalImage", "likes", "views"})

	return &StoryExec{ret}
}

func (client *Client) DeleteStory(params StoryWhereUniqueInput) *StoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"StoryWhereUniqueInput!", "Story"},
		"deleteStory",
		[]string{"id", "createdAt", "updatedAt", "type", "tags", "podcastLink", "audioStream", "principalImage", "likes", "views"})

	return &StoryExec{ret}
}

func (client *Client) DeleteManyStories(params *StoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "StoryWhereInput", "deleteManyStories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateText(params TextCreateInput) *TextExec {
	ret := client.Client.Create(
		params,
		[2]string{"TextCreateInput!", "Text"},
		"createText",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

type TextUpdateParams struct {
	Data  TextUpdateInput      `json:"data"`
	Where TextWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateText(params TextUpdateParams) *TextExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TextUpdateInput!", "TextWhereUniqueInput!", "Text"},
		"updateText",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

type TextUpdateManyParams struct {
	Data  TextUpdateManyMutationInput `json:"data"`
	Where *TextWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTexts(params TextUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TextUpdateManyMutationInput!", "TextWhereInput"},
		"updateManyTexts")
	return &BatchPayloadExec{exec}
}

type TextUpsertParams struct {
	Where  TextWhereUniqueInput `json:"where"`
	Create TextCreateInput      `json:"create"`
	Update TextUpdateInput      `json:"update"`
}

func (client *Client) UpsertText(params TextUpsertParams) *TextExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TextWhereUniqueInput!", "TextCreateInput!", "TextUpdateInput!", "Text"},
		"upsertText",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (client *Client) DeleteText(params TextWhereUniqueInput) *TextExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TextWhereUniqueInput!", "Text"},
		"deleteText",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (client *Client) DeleteManyTexts(params *TextWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TextWhereInput", "deleteManyTexts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTicket(params TicketCreateInput) *TicketExec {
	ret := client.Client.Create(
		params,
		[2]string{"TicketCreateInput!", "Ticket"},
		"createTicket",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "visited", "finished", "state"})

	return &TicketExec{ret}
}

type TicketUpdateParams struct {
	Data  TicketUpdateInput      `json:"data"`
	Where TicketWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTicket(params TicketUpdateParams) *TicketExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TicketUpdateInput!", "TicketWhereUniqueInput!", "Ticket"},
		"updateTicket",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "visited", "finished", "state"})

	return &TicketExec{ret}
}

type TicketUpdateManyParams struct {
	Data  TicketUpdateManyMutationInput `json:"data"`
	Where *TicketWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTickets(params TicketUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TicketUpdateManyMutationInput!", "TicketWhereInput"},
		"updateManyTickets")
	return &BatchPayloadExec{exec}
}

type TicketUpsertParams struct {
	Where  TicketWhereUniqueInput `json:"where"`
	Create TicketCreateInput      `json:"create"`
	Update TicketUpdateInput      `json:"update"`
}

func (client *Client) UpsertTicket(params TicketUpsertParams) *TicketExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TicketWhereUniqueInput!", "TicketCreateInput!", "TicketUpdateInput!", "Ticket"},
		"upsertTicket",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "visited", "finished", "state"})

	return &TicketExec{ret}
}

func (client *Client) DeleteTicket(params TicketWhereUniqueInput) *TicketExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TicketWhereUniqueInput!", "Ticket"},
		"deleteTicket",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "visited", "finished", "state"})

	return &TicketExec{ret}
}

func (client *Client) DeleteManyTickets(params *TicketWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TicketWhereInput", "deleteManyTickets")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTraveler(params TravelerCreateInput) *TravelerExec {
	ret := client.Client.Create(
		params,
		[2]string{"TravelerCreateInput!", "Traveler"},
		"createTraveler",
		[]string{"id", "createdAt", "updatedAt", "unregistered", "username"})

	return &TravelerExec{ret}
}

type TravelerUpdateParams struct {
	Data  TravelerUpdateInput      `json:"data"`
	Where TravelerWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTraveler(params TravelerUpdateParams) *TravelerExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TravelerUpdateInput!", "TravelerWhereUniqueInput!", "Traveler"},
		"updateTraveler",
		[]string{"id", "createdAt", "updatedAt", "unregistered", "username"})

	return &TravelerExec{ret}
}

type TravelerUpdateManyParams struct {
	Data  TravelerUpdateManyMutationInput `json:"data"`
	Where *TravelerWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTravelers(params TravelerUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TravelerUpdateManyMutationInput!", "TravelerWhereInput"},
		"updateManyTravelers")
	return &BatchPayloadExec{exec}
}

type TravelerUpsertParams struct {
	Where  TravelerWhereUniqueInput `json:"where"`
	Create TravelerCreateInput      `json:"create"`
	Update TravelerUpdateInput      `json:"update"`
}

func (client *Client) UpsertTraveler(params TravelerUpsertParams) *TravelerExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TravelerWhereUniqueInput!", "TravelerCreateInput!", "TravelerUpdateInput!", "Traveler"},
		"upsertTraveler",
		[]string{"id", "createdAt", "updatedAt", "unregistered", "username"})

	return &TravelerExec{ret}
}

func (client *Client) DeleteTraveler(params TravelerWhereUniqueInput) *TravelerExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TravelerWhereUniqueInput!", "Traveler"},
		"deleteTraveler",
		[]string{"id", "createdAt", "updatedAt", "unregistered", "username"})

	return &TravelerExec{ret}
}

func (client *Client) DeleteManyTravelers(params *TravelerWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TravelerWhereInput", "deleteManyTravelers")
	return &BatchPayloadExec{exec}
}

type StoryOrderByInput string

const (
	StoryOrderByInputIDAsc              StoryOrderByInput = "id_ASC"
	StoryOrderByInputIDDesc             StoryOrderByInput = "id_DESC"
	StoryOrderByInputCreatedAtAsc       StoryOrderByInput = "createdAt_ASC"
	StoryOrderByInputCreatedAtDesc      StoryOrderByInput = "createdAt_DESC"
	StoryOrderByInputUpdatedAtAsc       StoryOrderByInput = "updatedAt_ASC"
	StoryOrderByInputUpdatedAtDesc      StoryOrderByInput = "updatedAt_DESC"
	StoryOrderByInputTypeAsc            StoryOrderByInput = "type_ASC"
	StoryOrderByInputTypeDesc           StoryOrderByInput = "type_DESC"
	StoryOrderByInputPodcastLinkAsc     StoryOrderByInput = "podcastLink_ASC"
	StoryOrderByInputPodcastLinkDesc    StoryOrderByInput = "podcastLink_DESC"
	StoryOrderByInputAudioStreamAsc     StoryOrderByInput = "audioStream_ASC"
	StoryOrderByInputAudioStreamDesc    StoryOrderByInput = "audioStream_DESC"
	StoryOrderByInputPrincipalImageAsc  StoryOrderByInput = "principalImage_ASC"
	StoryOrderByInputPrincipalImageDesc StoryOrderByInput = "principalImage_DESC"
	StoryOrderByInputLikesAsc           StoryOrderByInput = "likes_ASC"
	StoryOrderByInputLikesDesc          StoryOrderByInput = "likes_DESC"
	StoryOrderByInputViewsAsc           StoryOrderByInput = "views_ASC"
	StoryOrderByInputViewsDesc          StoryOrderByInput = "views_DESC"
)

type PaymentMethodType string

const (
	PaymentMethodTypePaypal      PaymentMethodType = "PAYPAL"
	PaymentMethodTypeCulqi       PaymentMethodType = "CULQI"
	PaymentMethodTypeUnknown     PaymentMethodType = "UNKNOWN"
	PaymentMethodTypeSavedCard   PaymentMethodType = "SAVED_CARD"
	PaymentMethodTypeCulqiToken  PaymentMethodType = "CULQI_TOKEN"
	PaymentMethodTypePaypalOrder PaymentMethodType = "PAYPAL_ORDER"
)

type IDType string

const (
	IDTypeDni      IDType = "DNI"
	IDTypePassport IDType = "PASSPORT"
)

type TravelerOrderByInput string

const (
	TravelerOrderByInputIDAsc            TravelerOrderByInput = "id_ASC"
	TravelerOrderByInputIDDesc           TravelerOrderByInput = "id_DESC"
	TravelerOrderByInputCreatedAtAsc     TravelerOrderByInput = "createdAt_ASC"
	TravelerOrderByInputCreatedAtDesc    TravelerOrderByInput = "createdAt_DESC"
	TravelerOrderByInputUpdatedAtAsc     TravelerOrderByInput = "updatedAt_ASC"
	TravelerOrderByInputUpdatedAtDesc    TravelerOrderByInput = "updatedAt_DESC"
	TravelerOrderByInputUnregisteredAsc  TravelerOrderByInput = "unregistered_ASC"
	TravelerOrderByInputUnregisteredDesc TravelerOrderByInput = "unregistered_DESC"
	TravelerOrderByInputUsernameAsc      TravelerOrderByInput = "username_ASC"
	TravelerOrderByInputUsernameDesc     TravelerOrderByInput = "username_DESC"
)

type RouteOrderByInput string

const (
	RouteOrderByInputIDAsc          RouteOrderByInput = "id_ASC"
	RouteOrderByInputIDDesc         RouteOrderByInput = "id_DESC"
	RouteOrderByInputCreatedAtAsc   RouteOrderByInput = "createdAt_ASC"
	RouteOrderByInputCreatedAtDesc  RouteOrderByInput = "createdAt_DESC"
	RouteOrderByInputUpdatedAtAsc   RouteOrderByInput = "updatedAt_ASC"
	RouteOrderByInputUpdatedAtDesc  RouteOrderByInput = "updatedAt_DESC"
	RouteOrderByInputNameAsc        RouteOrderByInput = "name_ASC"
	RouteOrderByInputNameDesc       RouteOrderByInput = "name_DESC"
	RouteOrderByInputImageAsc       RouteOrderByInput = "image_ASC"
	RouteOrderByInputImageDesc      RouteOrderByInput = "image_DESC"
	RouteOrderByInputTypeAsc        RouteOrderByInput = "type_ASC"
	RouteOrderByInputTypeDesc       RouteOrderByInput = "type_DESC"
	RouteOrderByInputPopularityAsc  RouteOrderByInput = "popularity_ASC"
	RouteOrderByInputPopularityDesc RouteOrderByInput = "popularity_DESC"
	RouteOrderByInputColorAsc       RouteOrderByInput = "color_ASC"
	RouteOrderByInputColorDesc      RouteOrderByInput = "color_DESC"
)

type TextOrderByInput string

const (
	TextOrderByInputIDAsc       TextOrderByInput = "id_ASC"
	TextOrderByInputIDDesc      TextOrderByInput = "id_DESC"
	TextOrderByInputEnglishAsc  TextOrderByInput = "english_ASC"
	TextOrderByInputEnglishDesc TextOrderByInput = "english_DESC"
	TextOrderByInputSpanishAsc  TextOrderByInput = "spanish_ASC"
	TextOrderByInputSpanishDesc TextOrderByInput = "spanish_DESC"
)

type CredentialType string

const (
	CredentialTypeEmail     CredentialType = "EMAIL"
	CredentialTypePhone     CredentialType = "PHONE"
	CredentialTypeGmail     CredentialType = "GMAIL"
	CredentialTypeFacebook  CredentialType = "FACEBOOK"
	CredentialTypeAnonymous CredentialType = "ANONYMOUS"
)

type PassTypeOrderByInput string

const (
	PassTypeOrderByInputIDAsc         PassTypeOrderByInput = "id_ASC"
	PassTypeOrderByInputIDDesc        PassTypeOrderByInput = "id_DESC"
	PassTypeOrderByInputCreatedAtAsc  PassTypeOrderByInput = "createdAt_ASC"
	PassTypeOrderByInputCreatedAtDesc PassTypeOrderByInput = "createdAt_DESC"
	PassTypeOrderByInputUpdatedAtAsc  PassTypeOrderByInput = "updatedAt_ASC"
	PassTypeOrderByInputUpdatedAtDesc PassTypeOrderByInput = "updatedAt_DESC"
	PassTypeOrderByInputCreatorIdAsc  PassTypeOrderByInput = "creatorID_ASC"
	PassTypeOrderByInputCreatorIdDesc PassTypeOrderByInput = "creatorID_DESC"
	PassTypeOrderByInputDurationAsc   PassTypeOrderByInput = "duration_ASC"
	PassTypeOrderByInputDurationDesc  PassTypeOrderByInput = "duration_DESC"
)

type PhoneChannelOrderByInput string

const (
	PhoneChannelOrderByInputIDAsc           PhoneChannelOrderByInput = "id_ASC"
	PhoneChannelOrderByInputIDDesc          PhoneChannelOrderByInput = "id_DESC"
	PhoneChannelOrderByInputCreatedAtAsc    PhoneChannelOrderByInput = "createdAt_ASC"
	PhoneChannelOrderByInputCreatedAtDesc   PhoneChannelOrderByInput = "createdAt_DESC"
	PhoneChannelOrderByInputUpdatedAtAsc    PhoneChannelOrderByInput = "updatedAt_ASC"
	PhoneChannelOrderByInputUpdatedAtDesc   PhoneChannelOrderByInput = "updatedAt_DESC"
	PhoneChannelOrderByInputIsMainAsc       PhoneChannelOrderByInput = "isMain_ASC"
	PhoneChannelOrderByInputIsMainDesc      PhoneChannelOrderByInput = "isMain_DESC"
	PhoneChannelOrderByInputDisplayNameAsc  PhoneChannelOrderByInput = "displayName_ASC"
	PhoneChannelOrderByInputDisplayNameDesc PhoneChannelOrderByInput = "displayName_DESC"
	PhoneChannelOrderByInputValidAsc        PhoneChannelOrderByInput = "valid_ASC"
	PhoneChannelOrderByInputValidDesc       PhoneChannelOrderByInput = "valid_DESC"
	PhoneChannelOrderByInputCountryCodeAsc  PhoneChannelOrderByInput = "countryCode_ASC"
	PhoneChannelOrderByInputCountryCodeDesc PhoneChannelOrderByInput = "countryCode_DESC"
	PhoneChannelOrderByInputNumberAsc       PhoneChannelOrderByInput = "number_ASC"
	PhoneChannelOrderByInputNumberDesc      PhoneChannelOrderByInput = "number_DESC"
)

type OpeningHoursOrderByInput string

const (
	OpeningHoursOrderByInputIDAsc   OpeningHoursOrderByInput = "id_ASC"
	OpeningHoursOrderByInputIDDesc  OpeningHoursOrderByInput = "id_DESC"
	OpeningHoursOrderByInputMonAsc  OpeningHoursOrderByInput = "mon_ASC"
	OpeningHoursOrderByInputMonDesc OpeningHoursOrderByInput = "mon_DESC"
	OpeningHoursOrderByInputTueAsc  OpeningHoursOrderByInput = "tue_ASC"
	OpeningHoursOrderByInputTueDesc OpeningHoursOrderByInput = "tue_DESC"
	OpeningHoursOrderByInputWedAsc  OpeningHoursOrderByInput = "wed_ASC"
	OpeningHoursOrderByInputWedDesc OpeningHoursOrderByInput = "wed_DESC"
	OpeningHoursOrderByInputThuAsc  OpeningHoursOrderByInput = "thu_ASC"
	OpeningHoursOrderByInputThuDesc OpeningHoursOrderByInput = "thu_DESC"
	OpeningHoursOrderByInputFriAsc  OpeningHoursOrderByInput = "fri_ASC"
	OpeningHoursOrderByInputFriDesc OpeningHoursOrderByInput = "fri_DESC"
	OpeningHoursOrderByInputSatAsc  OpeningHoursOrderByInput = "sat_ASC"
	OpeningHoursOrderByInputSatDesc OpeningHoursOrderByInput = "sat_DESC"
	OpeningHoursOrderByInputSunAsc  OpeningHoursOrderByInput = "sun_ASC"
	OpeningHoursOrderByInputSunDesc OpeningHoursOrderByInput = "sun_DESC"
)

type FaqEntryOrderByInput string

const (
	FaqEntryOrderByInputIDAsc  FaqEntryOrderByInput = "id_ASC"
	FaqEntryOrderByInputIDDesc FaqEntryOrderByInput = "id_DESC"
)

type LimaContactOrderByInput string

const (
	LimaContactOrderByInputIDAsc           LimaContactOrderByInput = "id_ASC"
	LimaContactOrderByInputIDDesc          LimaContactOrderByInput = "id_DESC"
	LimaContactOrderByInputEmailAsc        LimaContactOrderByInput = "email_ASC"
	LimaContactOrderByInputEmailDesc       LimaContactOrderByInput = "email_DESC"
	LimaContactOrderByInputPhoneNumberAsc  LimaContactOrderByInput = "phoneNumber_ASC"
	LimaContactOrderByInputPhoneNumberDesc LimaContactOrderByInput = "phoneNumber_DESC"
)

type EmailChannelOrderByInput string

const (
	EmailChannelOrderByInputIDAsc           EmailChannelOrderByInput = "id_ASC"
	EmailChannelOrderByInputIDDesc          EmailChannelOrderByInput = "id_DESC"
	EmailChannelOrderByInputCreatedAtAsc    EmailChannelOrderByInput = "createdAt_ASC"
	EmailChannelOrderByInputCreatedAtDesc   EmailChannelOrderByInput = "createdAt_DESC"
	EmailChannelOrderByInputUpdatedAtAsc    EmailChannelOrderByInput = "updatedAt_ASC"
	EmailChannelOrderByInputUpdatedAtDesc   EmailChannelOrderByInput = "updatedAt_DESC"
	EmailChannelOrderByInputIsMainAsc       EmailChannelOrderByInput = "isMain_ASC"
	EmailChannelOrderByInputIsMainDesc      EmailChannelOrderByInput = "isMain_DESC"
	EmailChannelOrderByInputDisplayNameAsc  EmailChannelOrderByInput = "displayName_ASC"
	EmailChannelOrderByInputDisplayNameDesc EmailChannelOrderByInput = "displayName_DESC"
	EmailChannelOrderByInputValidAsc        EmailChannelOrderByInput = "valid_ASC"
	EmailChannelOrderByInputValidDesc       EmailChannelOrderByInput = "valid_DESC"
	EmailChannelOrderByInputValueAsc        EmailChannelOrderByInput = "value_ASC"
	EmailChannelOrderByInputValueDesc       EmailChannelOrderByInput = "value_DESC"
)

type PartnerOrderByInput string

const (
	PartnerOrderByInputIDAsc            PartnerOrderByInput = "id_ASC"
	PartnerOrderByInputIDDesc           PartnerOrderByInput = "id_DESC"
	PartnerOrderByInputCreatedAtAsc     PartnerOrderByInput = "createdAt_ASC"
	PartnerOrderByInputCreatedAtDesc    PartnerOrderByInput = "createdAt_DESC"
	PartnerOrderByInputUpdatedAtAsc     PartnerOrderByInput = "updatedAt_ASC"
	PartnerOrderByInputUpdatedAtDesc    PartnerOrderByInput = "updatedAt_DESC"
	PartnerOrderByInputBrandNameAsc     PartnerOrderByInput = "brandName_ASC"
	PartnerOrderByInputBrandNameDesc    PartnerOrderByInput = "brandName_DESC"
	PartnerOrderByInputLogoAsc          PartnerOrderByInput = "logo_ASC"
	PartnerOrderByInputLogoDesc         PartnerOrderByInput = "logo_DESC"
	PartnerOrderByInputSocialReasonAsc  PartnerOrderByInput = "socialReason_ASC"
	PartnerOrderByInputSocialReasonDesc PartnerOrderByInput = "socialReason_DESC"
	PartnerOrderByInputRucAsc           PartnerOrderByInput = "ruc_ASC"
	PartnerOrderByInputRucDesc          PartnerOrderByInput = "ruc_DESC"
	PartnerOrderByInputAddressAsc       PartnerOrderByInput = "address_ASC"
	PartnerOrderByInputAddressDesc      PartnerOrderByInput = "address_DESC"
)

type PurchaseOrderByInput string

const (
	PurchaseOrderByInputIDAsc               PurchaseOrderByInput = "id_ASC"
	PurchaseOrderByInputIDDesc              PurchaseOrderByInput = "id_DESC"
	PurchaseOrderByInputCreatedAtAsc        PurchaseOrderByInput = "createdAt_ASC"
	PurchaseOrderByInputCreatedAtDesc       PurchaseOrderByInput = "createdAt_DESC"
	PurchaseOrderByInputUpdatedAtAsc        PurchaseOrderByInput = "updatedAt_ASC"
	PurchaseOrderByInputUpdatedAtDesc       PurchaseOrderByInput = "updatedAt_DESC"
	PurchaseOrderByInputChargeTokenAsc      PurchaseOrderByInput = "chargeToken_ASC"
	PurchaseOrderByInputChargeTokenDesc     PurchaseOrderByInput = "chargeToken_DESC"
	PurchaseOrderByInputGatewayResponseAsc  PurchaseOrderByInput = "gatewayResponse_ASC"
	PurchaseOrderByInputGatewayResponseDesc PurchaseOrderByInput = "gatewayResponse_DESC"
	PurchaseOrderByInputDiscountIdAsc       PurchaseOrderByInput = "discountID_ASC"
	PurchaseOrderByInputDiscountIdDesc      PurchaseOrderByInput = "discountID_DESC"
	PurchaseOrderByInputDiscountAsc         PurchaseOrderByInput = "discount_ASC"
	PurchaseOrderByInputDiscountDesc        PurchaseOrderByInput = "discount_DESC"
)

type FaqOrderByInput string

const (
	FaqOrderByInputIDAsc         FaqOrderByInput = "id_ASC"
	FaqOrderByInputIDDesc        FaqOrderByInput = "id_DESC"
	FaqOrderByInputCreatedAtAsc  FaqOrderByInput = "createdAt_ASC"
	FaqOrderByInputCreatedAtDesc FaqOrderByInput = "createdAt_DESC"
	FaqOrderByInputUpdatedAtAsc  FaqOrderByInput = "updatedAt_ASC"
	FaqOrderByInputUpdatedAtDesc FaqOrderByInput = "updatedAt_DESC"
)

type CreditCardOrderByInput string

const (
	CreditCardOrderByInputIDAsc             CreditCardOrderByInput = "id_ASC"
	CreditCardOrderByInputIDDesc            CreditCardOrderByInput = "id_DESC"
	CreditCardOrderByInputCreatedAtAsc      CreditCardOrderByInput = "createdAt_ASC"
	CreditCardOrderByInputCreatedAtDesc     CreditCardOrderByInput = "createdAt_DESC"
	CreditCardOrderByInputUpdatedAtAsc      CreditCardOrderByInput = "updatedAt_ASC"
	CreditCardOrderByInputUpdatedAtDesc     CreditCardOrderByInput = "updatedAt_DESC"
	CreditCardOrderByInputCustomerTokenAsc  CreditCardOrderByInput = "customerToken_ASC"
	CreditCardOrderByInputCustomerTokenDesc CreditCardOrderByInput = "customerToken_DESC"
	CreditCardOrderByInputCardNumberAsc     CreditCardOrderByInput = "cardNumber_ASC"
	CreditCardOrderByInputCardNumberDesc    CreditCardOrderByInput = "cardNumber_DESC"
	CreditCardOrderByInputCardTokenAsc      CreditCardOrderByInput = "cardToken_ASC"
	CreditCardOrderByInputCardTokenDesc     CreditCardOrderByInput = "cardToken_DESC"
	CreditCardOrderByInputTypeAsc           CreditCardOrderByInput = "type_ASC"
	CreditCardOrderByInputTypeDesc          CreditCardOrderByInput = "type_DESC"
	CreditCardOrderByInputLastUsedAsc       CreditCardOrderByInput = "lastUsed_ASC"
	CreditCardOrderByInputLastUsedDesc      CreditCardOrderByInput = "lastUsed_DESC"
)

type CurrencyOrderByInput string

const (
	CurrencyOrderByInputIDAsc      CurrencyOrderByInput = "id_ASC"
	CurrencyOrderByInputIDDesc     CurrencyOrderByInput = "id_DESC"
	CurrencyOrderByInputCodeAsc    CurrencyOrderByInput = "code_ASC"
	CurrencyOrderByInputCodeDesc   CurrencyOrderByInput = "code_DESC"
	CurrencyOrderByInputSymbolAsc  CurrencyOrderByInput = "symbol_ASC"
	CurrencyOrderByInputSymbolDesc CurrencyOrderByInput = "symbol_DESC"
)

type CredentialOrderByInput string

const (
	CredentialOrderByInputIDAsc              CredentialOrderByInput = "id_ASC"
	CredentialOrderByInputIDDesc             CredentialOrderByInput = "id_DESC"
	CredentialOrderByInputCreatedAtAsc       CredentialOrderByInput = "createdAt_ASC"
	CredentialOrderByInputCreatedAtDesc      CredentialOrderByInput = "createdAt_DESC"
	CredentialOrderByInputUpdatedAtAsc       CredentialOrderByInput = "updatedAt_ASC"
	CredentialOrderByInputUpdatedAtDesc      CredentialOrderByInput = "updatedAt_DESC"
	CredentialOrderByInputDisplayNameAsc     CredentialOrderByInput = "displayName_ASC"
	CredentialOrderByInputDisplayNameDesc    CredentialOrderByInput = "displayName_DESC"
	CredentialOrderByInputIsMainAsc          CredentialOrderByInput = "isMain_ASC"
	CredentialOrderByInputIsMainDesc         CredentialOrderByInput = "isMain_DESC"
	CredentialOrderByInputTypeAsc            CredentialOrderByInput = "type_ASC"
	CredentialOrderByInputTypeDesc           CredentialOrderByInput = "type_DESC"
	CredentialOrderByInputValidatedAsc       CredentialOrderByInput = "validated_ASC"
	CredentialOrderByInputValidatedDesc      CredentialOrderByInput = "validated_DESC"
	CredentialOrderByInputValidationIdAsc    CredentialOrderByInput = "validationID_ASC"
	CredentialOrderByInputValidationIdDesc   CredentialOrderByInput = "validationID_DESC"
	CredentialOrderByInputValueAsc           CredentialOrderByInput = "value_ASC"
	CredentialOrderByInputValueDesc          CredentialOrderByInput = "value_DESC"
	CredentialOrderByInputRawPasswordAsc     CredentialOrderByInput = "rawPassword_ASC"
	CredentialOrderByInputRawPasswordDesc    CredentialOrderByInput = "rawPassword_DESC"
	CredentialOrderByInputHashedPasswordAsc  CredentialOrderByInput = "hashedPassword_ASC"
	CredentialOrderByInputHashedPasswordDesc CredentialOrderByInput = "hashedPassword_DESC"
)

type ExpertOrderByInput string

const (
	ExpertOrderByInputIDAsc         ExpertOrderByInput = "id_ASC"
	ExpertOrderByInputIDDesc        ExpertOrderByInput = "id_DESC"
	ExpertOrderByInputCreatedAtAsc  ExpertOrderByInput = "createdAt_ASC"
	ExpertOrderByInputCreatedAtDesc ExpertOrderByInput = "createdAt_DESC"
	ExpertOrderByInputUpdatedAtAsc  ExpertOrderByInput = "updatedAt_ASC"
	ExpertOrderByInputUpdatedAtDesc ExpertOrderByInput = "updatedAt_DESC"
	ExpertOrderByInputAliasAsc      ExpertOrderByInput = "alias_ASC"
	ExpertOrderByInputAliasDesc     ExpertOrderByInput = "alias_DESC"
)

type TicketOrderByInput string

const (
	TicketOrderByInputIDAsc         TicketOrderByInput = "id_ASC"
	TicketOrderByInputIDDesc        TicketOrderByInput = "id_DESC"
	TicketOrderByInputCreatedAtAsc  TicketOrderByInput = "createdAt_ASC"
	TicketOrderByInputCreatedAtDesc TicketOrderByInput = "createdAt_DESC"
	TicketOrderByInputUpdatedAtAsc  TicketOrderByInput = "updatedAt_ASC"
	TicketOrderByInputUpdatedAtDesc TicketOrderByInput = "updatedAt_DESC"
	TicketOrderByInputMaxUsesAsc    TicketOrderByInput = "maxUses_ASC"
	TicketOrderByInputMaxUsesDesc   TicketOrderByInput = "maxUses_DESC"
	TicketOrderByInputVisitedAsc    TicketOrderByInput = "visited_ASC"
	TicketOrderByInputVisitedDesc   TicketOrderByInput = "visited_DESC"
	TicketOrderByInputFinishedAsc   TicketOrderByInput = "finished_ASC"
	TicketOrderByInputFinishedDesc  TicketOrderByInput = "finished_DESC"
	TicketOrderByInputStateAsc      TicketOrderByInput = "state_ASC"
	TicketOrderByInputStateDesc     TicketOrderByInput = "state_DESC"
)

type PlaceOrderByInput string

const (
	PlaceOrderByInputIDAsc                PlaceOrderByInput = "id_ASC"
	PlaceOrderByInputIDDesc               PlaceOrderByInput = "id_DESC"
	PlaceOrderByInputCreatedAtAsc         PlaceOrderByInput = "createdAt_ASC"
	PlaceOrderByInputCreatedAtDesc        PlaceOrderByInput = "createdAt_DESC"
	PlaceOrderByInputUpdatedAtAsc         PlaceOrderByInput = "updatedAt_ASC"
	PlaceOrderByInputUpdatedAtDesc        PlaceOrderByInput = "updatedAt_DESC"
	PlaceOrderByInputNameAsc              PlaceOrderByInput = "name_ASC"
	PlaceOrderByInputNameDesc             PlaceOrderByInput = "name_DESC"
	PlaceOrderByInputShortNameAsc         PlaceOrderByInput = "shortName_ASC"
	PlaceOrderByInputShortNameDesc        PlaceOrderByInput = "shortName_DESC"
	PlaceOrderByInputAddressAsc           PlaceOrderByInput = "address_ASC"
	PlaceOrderByInputAddressDesc          PlaceOrderByInput = "address_DESC"
	PlaceOrderByInputGoogleLinkAsc        PlaceOrderByInput = "googleLink_ASC"
	PlaceOrderByInputGoogleLinkDesc       PlaceOrderByInput = "googleLink_DESC"
	PlaceOrderByInputWebsiteAsc           PlaceOrderByInput = "website_ASC"
	PlaceOrderByInputWebsiteDesc          PlaceOrderByInput = "website_DESC"
	PlaceOrderByInputTypeAsc              PlaceOrderByInput = "type_ASC"
	PlaceOrderByInputTypeDesc             PlaceOrderByInput = "type_DESC"
	PlaceOrderByInputPopularityAsc        PlaceOrderByInput = "popularity_ASC"
	PlaceOrderByInputPopularityDesc       PlaceOrderByInput = "popularity_DESC"
	PlaceOrderByInputProviderWebAsc       PlaceOrderByInput = "providerWeb_ASC"
	PlaceOrderByInputProviderWebDesc      PlaceOrderByInput = "providerWeb_DESC"
	PlaceOrderByInputContactPhoneAsc      PlaceOrderByInput = "contactPhone_ASC"
	PlaceOrderByInputContactPhoneDesc     PlaceOrderByInput = "contactPhone_DESC"
	PlaceOrderByInputContactEmailAsc      PlaceOrderByInput = "contactEmail_ASC"
	PlaceOrderByInputContactEmailDesc     PlaceOrderByInput = "contactEmail_DESC"
	PlaceOrderByInputAddressReferenceAsc  PlaceOrderByInput = "addressReference_ASC"
	PlaceOrderByInputAddressReferenceDesc PlaceOrderByInput = "addressReference_DESC"
)

type ProductEntryOrderByInput string

const (
	ProductEntryOrderByInputIDAsc            ProductEntryOrderByInput = "id_ASC"
	ProductEntryOrderByInputIDDesc           ProductEntryOrderByInput = "id_DESC"
	ProductEntryOrderByInputParentIdAsc      ProductEntryOrderByInput = "parentID_ASC"
	ProductEntryOrderByInputParentIdDesc     ProductEntryOrderByInput = "parentID_DESC"
	ProductEntryOrderByInputNameAsc          ProductEntryOrderByInput = "name_ASC"
	ProductEntryOrderByInputNameDesc         ProductEntryOrderByInput = "name_DESC"
	ProductEntryOrderByInputDescriptionAsc   ProductEntryOrderByInput = "description_ASC"
	ProductEntryOrderByInputDescriptionDesc  ProductEntryOrderByInput = "description_DESC"
	ProductEntryOrderByInputQuantityAsc      ProductEntryOrderByInput = "quantity_ASC"
	ProductEntryOrderByInputQuantityDesc     ProductEntryOrderByInput = "quantity_DESC"
	ProductEntryOrderByInputCostAsc          ProductEntryOrderByInput = "cost_ASC"
	ProductEntryOrderByInputCostDesc         ProductEntryOrderByInput = "cost_DESC"
	ProductEntryOrderByInputCurrencyCodeAsc  ProductEntryOrderByInput = "currencyCode_ASC"
	ProductEntryOrderByInputCurrencyCodeDesc ProductEntryOrderByInput = "currencyCode_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type PassOrderByInput string

const (
	PassOrderByInputIDAsc         PassOrderByInput = "id_ASC"
	PassOrderByInputIDDesc        PassOrderByInput = "id_DESC"
	PassOrderByInputCreatedAtAsc  PassOrderByInput = "createdAt_ASC"
	PassOrderByInputCreatedAtDesc PassOrderByInput = "createdAt_DESC"
	PassOrderByInputUpdatedAtAsc  PassOrderByInput = "updatedAt_ASC"
	PassOrderByInputUpdatedAtDesc PassOrderByInput = "updatedAt_DESC"
	PassOrderByInputExpireAtAsc   PassOrderByInput = "expireAt_ASC"
	PassOrderByInputExpireAtDesc  PassOrderByInput = "expireAt_DESC"
	PassOrderByInputStateAsc      PassOrderByInput = "state_ASC"
	PassOrderByInputStateDesc     PassOrderByInput = "state_DESC"
)

type PaymentMethodOrderByInput string

const (
	PaymentMethodOrderByInputIDAsc          PaymentMethodOrderByInput = "id_ASC"
	PaymentMethodOrderByInputIDDesc         PaymentMethodOrderByInput = "id_DESC"
	PaymentMethodOrderByInputTypeAsc        PaymentMethodOrderByInput = "type_ASC"
	PaymentMethodOrderByInputTypeDesc       PaymentMethodOrderByInput = "type_DESC"
	PaymentMethodOrderByInputValueAsc       PaymentMethodOrderByInput = "value_ASC"
	PaymentMethodOrderByInputValueDesc      PaymentMethodOrderByInput = "value_DESC"
	PaymentMethodOrderByInputCardNumberAsc  PaymentMethodOrderByInput = "cardNumber_ASC"
	PaymentMethodOrderByInputCardNumberDesc PaymentMethodOrderByInput = "cardNumber_DESC"
	PaymentMethodOrderByInputCodeAsc        PaymentMethodOrderByInput = "code_ASC"
	PaymentMethodOrderByInputCodeDesc       PaymentMethodOrderByInput = "code_DESC"
)

type EntryTicketOrderByInput string

const (
	EntryTicketOrderByInputIDAsc         EntryTicketOrderByInput = "id_ASC"
	EntryTicketOrderByInputIDDesc        EntryTicketOrderByInput = "id_DESC"
	EntryTicketOrderByInputCreatedAtAsc  EntryTicketOrderByInput = "createdAt_ASC"
	EntryTicketOrderByInputCreatedAtDesc EntryTicketOrderByInput = "createdAt_DESC"
	EntryTicketOrderByInputUpdatedAtAsc  EntryTicketOrderByInput = "updatedAt_ASC"
	EntryTicketOrderByInputUpdatedAtDesc EntryTicketOrderByInput = "updatedAt_DESC"
	EntryTicketOrderByInputAtAsc         EntryTicketOrderByInput = "at_ASC"
	EntryTicketOrderByInputAtDesc        EntryTicketOrderByInput = "at_DESC"
)

type LocationOrderByInput string

const (
	LocationOrderByInputIDAsc         LocationOrderByInput = "id_ASC"
	LocationOrderByInputIDDesc        LocationOrderByInput = "id_DESC"
	LocationOrderByInputCreatedAtAsc  LocationOrderByInput = "createdAt_ASC"
	LocationOrderByInputCreatedAtDesc LocationOrderByInput = "createdAt_DESC"
	LocationOrderByInputUpdatedAtAsc  LocationOrderByInput = "updatedAt_ASC"
	LocationOrderByInputUpdatedAtDesc LocationOrderByInput = "updatedAt_DESC"
	LocationOrderByInputLongitudeAsc  LocationOrderByInput = "longitude_ASC"
	LocationOrderByInputLongitudeDesc LocationOrderByInput = "longitude_DESC"
	LocationOrderByInputLatitudeAsc   LocationOrderByInput = "latitude_ASC"
	LocationOrderByInputLatitudeDesc  LocationOrderByInput = "latitude_DESC"
)

type FeatureOrderByInput string

const (
	FeatureOrderByInputIDAsc     FeatureOrderByInput = "id_ASC"
	FeatureOrderByInputIDDesc    FeatureOrderByInput = "id_DESC"
	FeatureOrderByInputImageAsc  FeatureOrderByInput = "image_ASC"
	FeatureOrderByInputImageDesc FeatureOrderByInput = "image_DESC"
)

type IDDocumentOrderByInput string

const (
	IDDocumentOrderByInputIDAsc         IDDocumentOrderByInput = "id_ASC"
	IDDocumentOrderByInputIDDesc        IDDocumentOrderByInput = "id_DESC"
	IDDocumentOrderByInputCreatedAtAsc  IDDocumentOrderByInput = "createdAt_ASC"
	IDDocumentOrderByInputCreatedAtDesc IDDocumentOrderByInput = "createdAt_DESC"
	IDDocumentOrderByInputUpdatedAtAsc  IDDocumentOrderByInput = "updatedAt_ASC"
	IDDocumentOrderByInputUpdatedAtDesc IDDocumentOrderByInput = "updatedAt_DESC"
	IDDocumentOrderByInputTypeAsc       IDDocumentOrderByInput = "type_ASC"
	IDDocumentOrderByInputTypeDesc      IDDocumentOrderByInput = "type_DESC"
	IDDocumentOrderByInputValueAsc      IDDocumentOrderByInput = "value_ASC"
	IDDocumentOrderByInputValueDesc     IDDocumentOrderByInput = "value_DESC"
	IDDocumentOrderByInputValidatedAsc  IDDocumentOrderByInput = "validated_ASC"
	IDDocumentOrderByInputValidatedDesc IDDocumentOrderByInput = "validated_DESC"
)

type AttractionOrderByInput string

const (
	AttractionOrderByInputIDAsc              AttractionOrderByInput = "id_ASC"
	AttractionOrderByInputIDDesc             AttractionOrderByInput = "id_DESC"
	AttractionOrderByInputCreatedAtAsc       AttractionOrderByInput = "createdAt_ASC"
	AttractionOrderByInputCreatedAtDesc      AttractionOrderByInput = "createdAt_DESC"
	AttractionOrderByInputUpdatedAtAsc       AttractionOrderByInput = "updatedAt_ASC"
	AttractionOrderByInputUpdatedAtDesc      AttractionOrderByInput = "updatedAt_DESC"
	AttractionOrderByInputPrincipalImageAsc  AttractionOrderByInput = "principalImage_ASC"
	AttractionOrderByInputPrincipalImageDesc AttractionOrderByInput = "principalImage_DESC"
	AttractionOrderByInputCoverImageAsc      AttractionOrderByInput = "coverImage_ASC"
	AttractionOrderByInputCoverImageDesc     AttractionOrderByInput = "coverImage_DESC"
	AttractionOrderByInputLandscapeImageAsc  AttractionOrderByInput = "landscapeImage_ASC"
	AttractionOrderByInputLandscapeImageDesc AttractionOrderByInput = "landscapeImage_DESC"
)

type CostOrderByInput string

const (
	CostOrderByInputIDAsc     CostOrderByInput = "id_ASC"
	CostOrderByInputIDDesc    CostOrderByInput = "id_DESC"
	CostOrderByInputValueAsc  CostOrderByInput = "value_ASC"
	CostOrderByInputValueDesc CostOrderByInput = "value_DESC"
)

type StoryType string

const (
	StoryTypeNewest   StoryType = "NEWEST"
	StoryTypePopular  StoryType = "POPULAR"
	StoryTypeTrending StoryType = "TRENDING"
)

type PersonReviewsOrderByInput string

const (
	PersonReviewsOrderByInputIDAsc             PersonReviewsOrderByInput = "id_ASC"
	PersonReviewsOrderByInputIDDesc            PersonReviewsOrderByInput = "id_DESC"
	PersonReviewsOrderByInputCreatedAtAsc      PersonReviewsOrderByInput = "createdAt_ASC"
	PersonReviewsOrderByInputCreatedAtDesc     PersonReviewsOrderByInput = "createdAt_DESC"
	PersonReviewsOrderByInputUpdatedAtAsc      PersonReviewsOrderByInput = "updatedAt_ASC"
	PersonReviewsOrderByInputUpdatedAtDesc     PersonReviewsOrderByInput = "updatedAt_DESC"
	PersonReviewsOrderByInputApproveNumberAsc  PersonReviewsOrderByInput = "approveNumber_ASC"
	PersonReviewsOrderByInputApproveNumberDesc PersonReviewsOrderByInput = "approveNumber_DESC"
	PersonReviewsOrderByInputDeclineNumberAsc  PersonReviewsOrderByInput = "declineNumber_ASC"
	PersonReviewsOrderByInputDeclineNumberDesc PersonReviewsOrderByInput = "declineNumber_DESC"
)

type PassState string

const (
	PassStateActive    PassState = "ACTIVE"
	PassStateInactive  PassState = "INACTIVE"
	PassStateFixed     PassState = "FIXED"
	PassStateCorrupted PassState = "CORRUPTED"
	PassStateUsing     PassState = "USING"
)

type TicketState string

const (
	TicketStateAvailable TicketState = "AVAILABLE"
	TicketStateInactive  TicketState = "INACTIVE"
	TicketStateFixed     TicketState = "FIXED"
	TicketStateCorrupted TicketState = "CORRUPTED"
	TicketStateUsing     TicketState = "USING"
	TicketStateUsed      TicketState = "USED"
)

type CreditCardType string

const (
	CreditCardTypeVisa       CreditCardType = "VISA"
	CreditCardTypeMastercard CreditCardType = "MASTERCARD"
	CreditCardTypeAmerican   CreditCardType = "AMERICAN"
)

type ExperienceType string

const (
	ExperienceTypeAdventure     ExperienceType = "ADVENTURE"
	ExperienceTypeHistory       ExperienceType = "HISTORY"
	ExperienceTypeRestaurant    ExperienceType = "RESTAURANT"
	ExperienceTypeHotel         ExperienceType = "HOTEL"
	ExperienceTypeNature        ExperienceType = "NATURE"
	ExperienceTypeDiscount      ExperienceType = "DISCOUNT"
	ExperienceTypeMuseum        ExperienceType = "MUSEUM"
	ExperienceTypeGastronomy    ExperienceType = "GASTRONOMY"
	ExperienceTypeArt           ExperienceType = "ART"
	ExperienceTypeBar           ExperienceType = "BAR"
	ExperienceTypeCulture       ExperienceType = "CULTURE"
	ExperienceTypeShopping      ExperienceType = "SHOPPING"
	ExperienceTypeEntertainment ExperienceType = "ENTERTAINMENT"
	ExperienceTypeGeneral       ExperienceType = "GENERAL"
	ExperienceTypeSport         ExperienceType = "SPORT"
)

type ActionTicketType string

const (
	ActionTicketTypeCompleteRegister ActionTicketType = "COMPLETE_REGISTER"
	ActionTicketTypeResetPassword    ActionTicketType = "RESET_PASSWORD"
	ActionTicketTypeChangePerson     ActionTicketType = "CHANGE_PERSON"
)

type PersonOrderByInput string

const (
	PersonOrderByInputIDAsc         PersonOrderByInput = "id_ASC"
	PersonOrderByInputIDDesc        PersonOrderByInput = "id_DESC"
	PersonOrderByInputCreatedAtAsc  PersonOrderByInput = "createdAt_ASC"
	PersonOrderByInputCreatedAtDesc PersonOrderByInput = "createdAt_DESC"
	PersonOrderByInputUpdatedAtAsc  PersonOrderByInput = "updatedAt_ASC"
	PersonOrderByInputUpdatedAtDesc PersonOrderByInput = "updatedAt_DESC"
	PersonOrderByInputQmIdAsc       PersonOrderByInput = "qmID_ASC"
	PersonOrderByInputQmIdDesc      PersonOrderByInput = "qmID_DESC"
	PersonOrderByInputNameAsc       PersonOrderByInput = "name_ASC"
	PersonOrderByInputNameDesc      PersonOrderByInput = "name_DESC"
	PersonOrderByInputPhotoAsc      PersonOrderByInput = "photo_ASC"
	PersonOrderByInputPhotoDesc     PersonOrderByInput = "photo_DESC"
	PersonOrderByInputBirthdateAsc  PersonOrderByInput = "birthdate_ASC"
	PersonOrderByInputBirthdateDesc PersonOrderByInput = "birthdate_DESC"
)

type ErrorOrderByInput string

const (
	ErrorOrderByInputIDAsc         ErrorOrderByInput = "id_ASC"
	ErrorOrderByInputIDDesc        ErrorOrderByInput = "id_DESC"
	ErrorOrderByInputCreatedAtAsc  ErrorOrderByInput = "createdAt_ASC"
	ErrorOrderByInputCreatedAtDesc ErrorOrderByInput = "createdAt_DESC"
	ErrorOrderByInputUpdatedAtAsc  ErrorOrderByInput = "updatedAt_ASC"
	ErrorOrderByInputUpdatedAtDesc ErrorOrderByInput = "updatedAt_DESC"
	ErrorOrderByInputCodeAsc       ErrorOrderByInput = "code_ASC"
	ErrorOrderByInputCodeDesc      ErrorOrderByInput = "code_DESC"
	ErrorOrderByInputInternalAsc   ErrorOrderByInput = "internal_ASC"
	ErrorOrderByInputInternalDesc  ErrorOrderByInput = "internal_DESC"
	ErrorOrderByInputExplainAsc    ErrorOrderByInput = "explain_ASC"
	ErrorOrderByInputExplainDesc   ErrorOrderByInput = "explain_DESC"
	ErrorOrderByInputLocationAsc   ErrorOrderByInput = "location_ASC"
	ErrorOrderByInputLocationDesc  ErrorOrderByInput = "location_DESC"
)

type LimaOrderByInput string

const (
	LimaOrderByInputIDAsc         LimaOrderByInput = "id_ASC"
	LimaOrderByInputIDDesc        LimaOrderByInput = "id_DESC"
	LimaOrderByInputCreatedAtAsc  LimaOrderByInput = "createdAt_ASC"
	LimaOrderByInputCreatedAtDesc LimaOrderByInput = "createdAt_DESC"
	LimaOrderByInputUpdatedAtAsc  LimaOrderByInput = "updatedAt_ASC"
	LimaOrderByInputUpdatedAtDesc LimaOrderByInput = "updatedAt_DESC"
	LimaOrderByInputVersionAsc    LimaOrderByInput = "version_ASC"
	LimaOrderByInputVersionDesc   LimaOrderByInput = "version_DESC"
	LimaOrderByInputAvailableAsc  LimaOrderByInput = "available_ASC"
	LimaOrderByInputAvailableDesc LimaOrderByInput = "available_DESC"
)

type ActionTicketOrderByInput string

const (
	ActionTicketOrderByInputIDAsc         ActionTicketOrderByInput = "id_ASC"
	ActionTicketOrderByInputIDDesc        ActionTicketOrderByInput = "id_DESC"
	ActionTicketOrderByInputCreatedAtAsc  ActionTicketOrderByInput = "createdAt_ASC"
	ActionTicketOrderByInputCreatedAtDesc ActionTicketOrderByInput = "createdAt_DESC"
	ActionTicketOrderByInputUpdatedAtAsc  ActionTicketOrderByInput = "updatedAt_ASC"
	ActionTicketOrderByInputUpdatedAtDesc ActionTicketOrderByInput = "updatedAt_DESC"
	ActionTicketOrderByInputTypeAsc       ActionTicketOrderByInput = "type_ASC"
	ActionTicketOrderByInputTypeDesc      ActionTicketOrderByInput = "type_DESC"
	ActionTicketOrderByInputTokenAsc      ActionTicketOrderByInput = "token_ASC"
	ActionTicketOrderByInputTokenDesc     ActionTicketOrderByInput = "token_DESC"
	ActionTicketOrderByInputAvailableAsc  ActionTicketOrderByInput = "available_ASC"
	ActionTicketOrderByInputAvailableDesc ActionTicketOrderByInput = "available_DESC"
	ActionTicketOrderByInputUsedAsc       ActionTicketOrderByInput = "used_ASC"
	ActionTicketOrderByInputUsedDesc      ActionTicketOrderByInput = "used_DESC"
)

type AttractionUpdateWithWhereUniqueNestedInput struct {
	Where AttractionWhereUniqueInput `json:"where"`
	Data  AttractionUpdateDataInput  `json:"data"`
}

type ActionTicketWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type StoryUpdateWithWhereUniqueWithoutAuthorInput struct {
	Where StoryWhereUniqueInput             `json:"where"`
	Data  StoryUpdateWithoutAuthorDataInput `json:"data"`
}

type CurrencyWhereInput struct {
	ID                  *string              `json:"id,omitempty"`
	IDNot               *string              `json:"id_not,omitempty"`
	IDIn                []string             `json:"id_in,omitempty"`
	IDNotIn             []string             `json:"id_not_in,omitempty"`
	IDLt                *string              `json:"id_lt,omitempty"`
	IDLte               *string              `json:"id_lte,omitempty"`
	IDGt                *string              `json:"id_gt,omitempty"`
	IDGte               *string              `json:"id_gte,omitempty"`
	IDContains          *string              `json:"id_contains,omitempty"`
	IDNotContains       *string              `json:"id_not_contains,omitempty"`
	IDStartsWith        *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string              `json:"id_not_ends_with,omitempty"`
	Name                *TextWhereInput      `json:"name,omitempty"`
	Code                *string              `json:"code,omitempty"`
	CodeNot             *string              `json:"code_not,omitempty"`
	CodeIn              []string             `json:"code_in,omitempty"`
	CodeNotIn           []string             `json:"code_not_in,omitempty"`
	CodeLt              *string              `json:"code_lt,omitempty"`
	CodeLte             *string              `json:"code_lte,omitempty"`
	CodeGt              *string              `json:"code_gt,omitempty"`
	CodeGte             *string              `json:"code_gte,omitempty"`
	CodeContains        *string              `json:"code_contains,omitempty"`
	CodeNotContains     *string              `json:"code_not_contains,omitempty"`
	CodeStartsWith      *string              `json:"code_starts_with,omitempty"`
	CodeNotStartsWith   *string              `json:"code_not_starts_with,omitempty"`
	CodeEndsWith        *string              `json:"code_ends_with,omitempty"`
	CodeNotEndsWith     *string              `json:"code_not_ends_with,omitempty"`
	Symbol              *string              `json:"symbol,omitempty"`
	SymbolNot           *string              `json:"symbol_not,omitempty"`
	SymbolIn            []string             `json:"symbol_in,omitempty"`
	SymbolNotIn         []string             `json:"symbol_not_in,omitempty"`
	SymbolLt            *string              `json:"symbol_lt,omitempty"`
	SymbolLte           *string              `json:"symbol_lte,omitempty"`
	SymbolGt            *string              `json:"symbol_gt,omitempty"`
	SymbolGte           *string              `json:"symbol_gte,omitempty"`
	SymbolContains      *string              `json:"symbol_contains,omitempty"`
	SymbolNotContains   *string              `json:"symbol_not_contains,omitempty"`
	SymbolStartsWith    *string              `json:"symbol_starts_with,omitempty"`
	SymbolNotStartsWith *string              `json:"symbol_not_starts_with,omitempty"`
	SymbolEndsWith      *string              `json:"symbol_ends_with,omitempty"`
	SymbolNotEndsWith   *string              `json:"symbol_not_ends_with,omitempty"`
	And                 []CurrencyWhereInput `json:"AND,omitempty"`
	Or                  []CurrencyWhereInput `json:"OR,omitempty"`
	Not                 []CurrencyWhereInput `json:"NOT,omitempty"`
}

type StoryUpdateWithoutAuthorDataInput struct {
	Type           *StoryType                             `json:"type,omitempty"`
	Tags           *StoryUpdatetagsInput                  `json:"tags,omitempty"`
	PodcastLink    *string                                `json:"podcastLink,omitempty"`
	AudioStream    *string                                `json:"audioStream,omitempty"`
	PrincipalImage *string                                `json:"principalImage,omitempty"`
	Title          *TextUpdateOneRequiredInput            `json:"title,omitempty"`
	Body           *TextUpdateOneRequiredInput            `json:"body,omitempty"`
	Likes          *int32                                 `json:"likes,omitempty"`
	Views          *int32                                 `json:"views,omitempty"`
	Reviews        *PersonReviewsUpdateManyInput          `json:"reviews,omitempty"`
	LinkedRoute    *RouteUpdateOneWithoutLinkedStoryInput `json:"linkedRoute,omitempty"`
}

type ProductEntryWhereInput struct {
	ID                        *string                  `json:"id,omitempty"`
	IDNot                     *string                  `json:"id_not,omitempty"`
	IDIn                      []string                 `json:"id_in,omitempty"`
	IDNotIn                   []string                 `json:"id_not_in,omitempty"`
	IDLt                      *string                  `json:"id_lt,omitempty"`
	IDLte                     *string                  `json:"id_lte,omitempty"`
	IDGt                      *string                  `json:"id_gt,omitempty"`
	IDGte                     *string                  `json:"id_gte,omitempty"`
	IDContains                *string                  `json:"id_contains,omitempty"`
	IDNotContains             *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith              *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string                  `json:"id_not_ends_with,omitempty"`
	ParentId                  *string                  `json:"parentID,omitempty"`
	ParentIdNot               *string                  `json:"parentID_not,omitempty"`
	ParentIdIn                []string                 `json:"parentID_in,omitempty"`
	ParentIdNotIn             []string                 `json:"parentID_not_in,omitempty"`
	ParentIdLt                *string                  `json:"parentID_lt,omitempty"`
	ParentIdLte               *string                  `json:"parentID_lte,omitempty"`
	ParentIdGt                *string                  `json:"parentID_gt,omitempty"`
	ParentIdGte               *string                  `json:"parentID_gte,omitempty"`
	ParentIdContains          *string                  `json:"parentID_contains,omitempty"`
	ParentIdNotContains       *string                  `json:"parentID_not_contains,omitempty"`
	ParentIdStartsWith        *string                  `json:"parentID_starts_with,omitempty"`
	ParentIdNotStartsWith     *string                  `json:"parentID_not_starts_with,omitempty"`
	ParentIdEndsWith          *string                  `json:"parentID_ends_with,omitempty"`
	ParentIdNotEndsWith       *string                  `json:"parentID_not_ends_with,omitempty"`
	Name                      *string                  `json:"name,omitempty"`
	NameNot                   *string                  `json:"name_not,omitempty"`
	NameIn                    []string                 `json:"name_in,omitempty"`
	NameNotIn                 []string                 `json:"name_not_in,omitempty"`
	NameLt                    *string                  `json:"name_lt,omitempty"`
	NameLte                   *string                  `json:"name_lte,omitempty"`
	NameGt                    *string                  `json:"name_gt,omitempty"`
	NameGte                   *string                  `json:"name_gte,omitempty"`
	NameContains              *string                  `json:"name_contains,omitempty"`
	NameNotContains           *string                  `json:"name_not_contains,omitempty"`
	NameStartsWith            *string                  `json:"name_starts_with,omitempty"`
	NameNotStartsWith         *string                  `json:"name_not_starts_with,omitempty"`
	NameEndsWith              *string                  `json:"name_ends_with,omitempty"`
	NameNotEndsWith           *string                  `json:"name_not_ends_with,omitempty"`
	Description               *string                  `json:"description,omitempty"`
	DescriptionNot            *string                  `json:"description_not,omitempty"`
	DescriptionIn             []string                 `json:"description_in,omitempty"`
	DescriptionNotIn          []string                 `json:"description_not_in,omitempty"`
	DescriptionLt             *string                  `json:"description_lt,omitempty"`
	DescriptionLte            *string                  `json:"description_lte,omitempty"`
	DescriptionGt             *string                  `json:"description_gt,omitempty"`
	DescriptionGte            *string                  `json:"description_gte,omitempty"`
	DescriptionContains       *string                  `json:"description_contains,omitempty"`
	DescriptionNotContains    *string                  `json:"description_not_contains,omitempty"`
	DescriptionStartsWith     *string                  `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith  *string                  `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith       *string                  `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith    *string                  `json:"description_not_ends_with,omitempty"`
	Quantity                  *int32                   `json:"quantity,omitempty"`
	QuantityNot               *int32                   `json:"quantity_not,omitempty"`
	QuantityIn                []int32                  `json:"quantity_in,omitempty"`
	QuantityNotIn             []int32                  `json:"quantity_not_in,omitempty"`
	QuantityLt                *int32                   `json:"quantity_lt,omitempty"`
	QuantityLte               *int32                   `json:"quantity_lte,omitempty"`
	QuantityGt                *int32                   `json:"quantity_gt,omitempty"`
	QuantityGte               *int32                   `json:"quantity_gte,omitempty"`
	Cost                      *float64                 `json:"cost,omitempty"`
	CostNot                   *float64                 `json:"cost_not,omitempty"`
	CostIn                    []float64                `json:"cost_in,omitempty"`
	CostNotIn                 []float64                `json:"cost_not_in,omitempty"`
	CostLt                    *float64                 `json:"cost_lt,omitempty"`
	CostLte                   *float64                 `json:"cost_lte,omitempty"`
	CostGt                    *float64                 `json:"cost_gt,omitempty"`
	CostGte                   *float64                 `json:"cost_gte,omitempty"`
	CurrencyCode              *string                  `json:"currencyCode,omitempty"`
	CurrencyCodeNot           *string                  `json:"currencyCode_not,omitempty"`
	CurrencyCodeIn            []string                 `json:"currencyCode_in,omitempty"`
	CurrencyCodeNotIn         []string                 `json:"currencyCode_not_in,omitempty"`
	CurrencyCodeLt            *string                  `json:"currencyCode_lt,omitempty"`
	CurrencyCodeLte           *string                  `json:"currencyCode_lte,omitempty"`
	CurrencyCodeGt            *string                  `json:"currencyCode_gt,omitempty"`
	CurrencyCodeGte           *string                  `json:"currencyCode_gte,omitempty"`
	CurrencyCodeContains      *string                  `json:"currencyCode_contains,omitempty"`
	CurrencyCodeNotContains   *string                  `json:"currencyCode_not_contains,omitempty"`
	CurrencyCodeStartsWith    *string                  `json:"currencyCode_starts_with,omitempty"`
	CurrencyCodeNotStartsWith *string                  `json:"currencyCode_not_starts_with,omitempty"`
	CurrencyCodeEndsWith      *string                  `json:"currencyCode_ends_with,omitempty"`
	CurrencyCodeNotEndsWith   *string                  `json:"currencyCode_not_ends_with,omitempty"`
	And                       []ProductEntryWhereInput `json:"AND,omitempty"`
	Or                        []ProductEntryWhereInput `json:"OR,omitempty"`
	Not                       []ProductEntryWhereInput `json:"NOT,omitempty"`
}

type StoryUpdatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type CostWhereInput struct {
	ID              *string             `json:"id,omitempty"`
	IDNot           *string             `json:"id_not,omitempty"`
	IDIn            []string            `json:"id_in,omitempty"`
	IDNotIn         []string            `json:"id_not_in,omitempty"`
	IDLt            *string             `json:"id_lt,omitempty"`
	IDLte           *string             `json:"id_lte,omitempty"`
	IDGt            *string             `json:"id_gt,omitempty"`
	IDGte           *string             `json:"id_gte,omitempty"`
	IDContains      *string             `json:"id_contains,omitempty"`
	IDNotContains   *string             `json:"id_not_contains,omitempty"`
	IDStartsWith    *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string             `json:"id_not_ends_with,omitempty"`
	Value           *float64            `json:"value,omitempty"`
	ValueNot        *float64            `json:"value_not,omitempty"`
	ValueIn         []float64           `json:"value_in,omitempty"`
	ValueNotIn      []float64           `json:"value_not_in,omitempty"`
	ValueLt         *float64            `json:"value_lt,omitempty"`
	ValueLte        *float64            `json:"value_lte,omitempty"`
	ValueGt         *float64            `json:"value_gt,omitempty"`
	ValueGte        *float64            `json:"value_gte,omitempty"`
	Currency        *CurrencyWhereInput `json:"currency,omitempty"`
	And             []CostWhereInput    `json:"AND,omitempty"`
	Or              []CostWhereInput    `json:"OR,omitempty"`
	Not             []CostWhereInput    `json:"NOT,omitempty"`
}

type PersonReviewsUpdateManyInput struct {
	Create     []PersonReviewsCreateInput                      `json:"create,omitempty"`
	Update     []PersonReviewsUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []PersonReviewsUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []PersonReviewsWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []PersonReviewsWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []PersonReviewsWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []PersonReviewsWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []PersonReviewsScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []PersonReviewsUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type PassWhereInput struct {
	ID              *string             `json:"id,omitempty"`
	IDNot           *string             `json:"id_not,omitempty"`
	IDIn            []string            `json:"id_in,omitempty"`
	IDNotIn         []string            `json:"id_not_in,omitempty"`
	IDLt            *string             `json:"id_lt,omitempty"`
	IDLte           *string             `json:"id_lte,omitempty"`
	IDGt            *string             `json:"id_gt,omitempty"`
	IDGte           *string             `json:"id_gte,omitempty"`
	IDContains      *string             `json:"id_contains,omitempty"`
	IDNotContains   *string             `json:"id_not_contains,omitempty"`
	IDStartsWith    *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string             `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string             `json:"createdAt,omitempty"`
	CreatedAtNot    *string             `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string             `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string             `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string             `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string             `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string             `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string             `json:"updatedAt_gte,omitempty"`
	Type            *PassTypeWhereInput `json:"type,omitempty"`
	Owner           *PersonWhereInput   `json:"owner,omitempty"`
	PurchaseReceive *PurchaseWhereInput `json:"purchaseReceive,omitempty"`
	ExpireAt        *string             `json:"expireAt,omitempty"`
	ExpireAtNot     *string             `json:"expireAt_not,omitempty"`
	ExpireAtIn      []string            `json:"expireAt_in,omitempty"`
	ExpireAtNotIn   []string            `json:"expireAt_not_in,omitempty"`
	ExpireAtLt      *string             `json:"expireAt_lt,omitempty"`
	ExpireAtLte     *string             `json:"expireAt_lte,omitempty"`
	ExpireAtGt      *string             `json:"expireAt_gt,omitempty"`
	ExpireAtGte     *string             `json:"expireAt_gte,omitempty"`
	State           *PassState          `json:"state,omitempty"`
	StateNot        *PassState          `json:"state_not,omitempty"`
	StateIn         []PassState         `json:"state_in,omitempty"`
	StateNotIn      []PassState         `json:"state_not_in,omitempty"`
	TicketsEvery    *TicketWhereInput   `json:"tickets_every,omitempty"`
	TicketsSome     *TicketWhereInput   `json:"tickets_some,omitempty"`
	TicketsNone     *TicketWhereInput   `json:"tickets_none,omitempty"`
	And             []PassWhereInput    `json:"AND,omitempty"`
	Or              []PassWhereInput    `json:"OR,omitempty"`
	Not             []PassWhereInput    `json:"NOT,omitempty"`
}

type PersonReviewsUpdateWithWhereUniqueNestedInput struct {
	Where PersonReviewsWhereUniqueInput `json:"where"`
	Data  PersonReviewsUpdateDataInput  `json:"data"`
}

type CreditCardWhereInput struct {
	ID                         *string                `json:"id,omitempty"`
	IDNot                      *string                `json:"id_not,omitempty"`
	IDIn                       []string               `json:"id_in,omitempty"`
	IDNotIn                    []string               `json:"id_not_in,omitempty"`
	IDLt                       *string                `json:"id_lt,omitempty"`
	IDLte                      *string                `json:"id_lte,omitempty"`
	IDGt                       *string                `json:"id_gt,omitempty"`
	IDGte                      *string                `json:"id_gte,omitempty"`
	IDContains                 *string                `json:"id_contains,omitempty"`
	IDNotContains              *string                `json:"id_not_contains,omitempty"`
	IDStartsWith               *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith            *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith                 *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith              *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt                  *string                `json:"createdAt,omitempty"`
	CreatedAtNot               *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn                []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn             []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte               *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt                *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte               *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt                  *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot               *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn             []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte               *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte               *string                `json:"updatedAt_gte,omitempty"`
	Owner                      *TravelerWhereInput    `json:"owner,omitempty"`
	CustomerToken              *string                `json:"customerToken,omitempty"`
	CustomerTokenNot           *string                `json:"customerToken_not,omitempty"`
	CustomerTokenIn            []string               `json:"customerToken_in,omitempty"`
	CustomerTokenNotIn         []string               `json:"customerToken_not_in,omitempty"`
	CustomerTokenLt            *string                `json:"customerToken_lt,omitempty"`
	CustomerTokenLte           *string                `json:"customerToken_lte,omitempty"`
	CustomerTokenGt            *string                `json:"customerToken_gt,omitempty"`
	CustomerTokenGte           *string                `json:"customerToken_gte,omitempty"`
	CustomerTokenContains      *string                `json:"customerToken_contains,omitempty"`
	CustomerTokenNotContains   *string                `json:"customerToken_not_contains,omitempty"`
	CustomerTokenStartsWith    *string                `json:"customerToken_starts_with,omitempty"`
	CustomerTokenNotStartsWith *string                `json:"customerToken_not_starts_with,omitempty"`
	CustomerTokenEndsWith      *string                `json:"customerToken_ends_with,omitempty"`
	CustomerTokenNotEndsWith   *string                `json:"customerToken_not_ends_with,omitempty"`
	CardNumber                 *string                `json:"cardNumber,omitempty"`
	CardNumberNot              *string                `json:"cardNumber_not,omitempty"`
	CardNumberIn               []string               `json:"cardNumber_in,omitempty"`
	CardNumberNotIn            []string               `json:"cardNumber_not_in,omitempty"`
	CardNumberLt               *string                `json:"cardNumber_lt,omitempty"`
	CardNumberLte              *string                `json:"cardNumber_lte,omitempty"`
	CardNumberGt               *string                `json:"cardNumber_gt,omitempty"`
	CardNumberGte              *string                `json:"cardNumber_gte,omitempty"`
	CardNumberContains         *string                `json:"cardNumber_contains,omitempty"`
	CardNumberNotContains      *string                `json:"cardNumber_not_contains,omitempty"`
	CardNumberStartsWith       *string                `json:"cardNumber_starts_with,omitempty"`
	CardNumberNotStartsWith    *string                `json:"cardNumber_not_starts_with,omitempty"`
	CardNumberEndsWith         *string                `json:"cardNumber_ends_with,omitempty"`
	CardNumberNotEndsWith      *string                `json:"cardNumber_not_ends_with,omitempty"`
	CardToken                  *string                `json:"cardToken,omitempty"`
	CardTokenNot               *string                `json:"cardToken_not,omitempty"`
	CardTokenIn                []string               `json:"cardToken_in,omitempty"`
	CardTokenNotIn             []string               `json:"cardToken_not_in,omitempty"`
	CardTokenLt                *string                `json:"cardToken_lt,omitempty"`
	CardTokenLte               *string                `json:"cardToken_lte,omitempty"`
	CardTokenGt                *string                `json:"cardToken_gt,omitempty"`
	CardTokenGte               *string                `json:"cardToken_gte,omitempty"`
	CardTokenContains          *string                `json:"cardToken_contains,omitempty"`
	CardTokenNotContains       *string                `json:"cardToken_not_contains,omitempty"`
	CardTokenStartsWith        *string                `json:"cardToken_starts_with,omitempty"`
	CardTokenNotStartsWith     *string                `json:"cardToken_not_starts_with,omitempty"`
	CardTokenEndsWith          *string                `json:"cardToken_ends_with,omitempty"`
	CardTokenNotEndsWith       *string                `json:"cardToken_not_ends_with,omitempty"`
	Type                       *CreditCardType        `json:"type,omitempty"`
	TypeNot                    *CreditCardType        `json:"type_not,omitempty"`
	TypeIn                     []CreditCardType       `json:"type_in,omitempty"`
	TypeNotIn                  []CreditCardType       `json:"type_not_in,omitempty"`
	LastUsed                   *string                `json:"lastUsed,omitempty"`
	LastUsedNot                *string                `json:"lastUsed_not,omitempty"`
	LastUsedIn                 []string               `json:"lastUsed_in,omitempty"`
	LastUsedNotIn              []string               `json:"lastUsed_not_in,omitempty"`
	LastUsedLt                 *string                `json:"lastUsed_lt,omitempty"`
	LastUsedLte                *string                `json:"lastUsed_lte,omitempty"`
	LastUsedGt                 *string                `json:"lastUsed_gt,omitempty"`
	LastUsedGte                *string                `json:"lastUsed_gte,omitempty"`
	And                        []CreditCardWhereInput `json:"AND,omitempty"`
	Or                         []CreditCardWhereInput `json:"OR,omitempty"`
	Not                        []CreditCardWhereInput `json:"NOT,omitempty"`
}

type PersonReviewsUpdateDataInput struct {
	Person        *PersonUpdateOneRequiredInput `json:"person,omitempty"`
	Title         *TextUpdateOneRequiredInput   `json:"title,omitempty"`
	Description   *TextUpdateOneRequiredInput   `json:"description,omitempty"`
	ApproveNumber *int32                        `json:"approveNumber,omitempty"`
	DeclineNumber *int32                        `json:"declineNumber,omitempty"`
	Comments      *PersonReviewsUpdateManyInput `json:"comments,omitempty"`
}

type FaqWhereInput struct {
	ID              *string               `json:"id,omitempty"`
	IDNot           *string               `json:"id_not,omitempty"`
	IDIn            []string              `json:"id_in,omitempty"`
	IDNotIn         []string              `json:"id_not_in,omitempty"`
	IDLt            *string               `json:"id_lt,omitempty"`
	IDLte           *string               `json:"id_lte,omitempty"`
	IDGt            *string               `json:"id_gt,omitempty"`
	IDGte           *string               `json:"id_gte,omitempty"`
	IDContains      *string               `json:"id_contains,omitempty"`
	IDNotContains   *string               `json:"id_not_contains,omitempty"`
	IDStartsWith    *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string               `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string               `json:"createdAt,omitempty"`
	CreatedAtNot    *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string               `json:"updatedAt_gte,omitempty"`
	Attraction      *AttractionWhereInput `json:"attraction,omitempty"`
	EntriesEvery    *FaqEntryWhereInput   `json:"entries_every,omitempty"`
	EntriesSome     *FaqEntryWhereInput   `json:"entries_some,omitempty"`
	EntriesNone     *FaqEntryWhereInput   `json:"entries_none,omitempty"`
	And             []FaqWhereInput       `json:"AND,omitempty"`
	Or              []FaqWhereInput       `json:"OR,omitempty"`
	Not             []FaqWhereInput       `json:"NOT,omitempty"`
}

type PersonReviewsUpsertWithWhereUniqueNestedInput struct {
	Where  PersonReviewsWhereUniqueInput `json:"where"`
	Update PersonReviewsUpdateDataInput  `json:"update"`
	Create PersonReviewsCreateInput      `json:"create"`
}

type PlaceWhereInput struct {
	ID                            *string                  `json:"id,omitempty"`
	IDNot                         *string                  `json:"id_not,omitempty"`
	IDIn                          []string                 `json:"id_in,omitempty"`
	IDNotIn                       []string                 `json:"id_not_in,omitempty"`
	IDLt                          *string                  `json:"id_lt,omitempty"`
	IDLte                         *string                  `json:"id_lte,omitempty"`
	IDGt                          *string                  `json:"id_gt,omitempty"`
	IDGte                         *string                  `json:"id_gte,omitempty"`
	IDContains                    *string                  `json:"id_contains,omitempty"`
	IDNotContains                 *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith                  *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith               *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith                    *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith                 *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt                     *string                  `json:"createdAt,omitempty"`
	CreatedAtNot                  *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn                   []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                   *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte                  *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt                   *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte                  *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt                     *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot                  *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                   []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                   *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                  *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                   *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                  *string                  `json:"updatedAt_gte,omitempty"`
	Name                          *string                  `json:"name,omitempty"`
	NameNot                       *string                  `json:"name_not,omitempty"`
	NameIn                        []string                 `json:"name_in,omitempty"`
	NameNotIn                     []string                 `json:"name_not_in,omitempty"`
	NameLt                        *string                  `json:"name_lt,omitempty"`
	NameLte                       *string                  `json:"name_lte,omitempty"`
	NameGt                        *string                  `json:"name_gt,omitempty"`
	NameGte                       *string                  `json:"name_gte,omitempty"`
	NameContains                  *string                  `json:"name_contains,omitempty"`
	NameNotContains               *string                  `json:"name_not_contains,omitempty"`
	NameStartsWith                *string                  `json:"name_starts_with,omitempty"`
	NameNotStartsWith             *string                  `json:"name_not_starts_with,omitempty"`
	NameEndsWith                  *string                  `json:"name_ends_with,omitempty"`
	NameNotEndsWith               *string                  `json:"name_not_ends_with,omitempty"`
	ShortName                     *string                  `json:"shortName,omitempty"`
	ShortNameNot                  *string                  `json:"shortName_not,omitempty"`
	ShortNameIn                   []string                 `json:"shortName_in,omitempty"`
	ShortNameNotIn                []string                 `json:"shortName_not_in,omitempty"`
	ShortNameLt                   *string                  `json:"shortName_lt,omitempty"`
	ShortNameLte                  *string                  `json:"shortName_lte,omitempty"`
	ShortNameGt                   *string                  `json:"shortName_gt,omitempty"`
	ShortNameGte                  *string                  `json:"shortName_gte,omitempty"`
	ShortNameContains             *string                  `json:"shortName_contains,omitempty"`
	ShortNameNotContains          *string                  `json:"shortName_not_contains,omitempty"`
	ShortNameStartsWith           *string                  `json:"shortName_starts_with,omitempty"`
	ShortNameNotStartsWith        *string                  `json:"shortName_not_starts_with,omitempty"`
	ShortNameEndsWith             *string                  `json:"shortName_ends_with,omitempty"`
	ShortNameNotEndsWith          *string                  `json:"shortName_not_ends_with,omitempty"`
	Description                   *TextWhereInput          `json:"description,omitempty"`
	ShortDescription              *TextWhereInput          `json:"shortDescription,omitempty"`
	Address                       *string                  `json:"address,omitempty"`
	AddressNot                    *string                  `json:"address_not,omitempty"`
	AddressIn                     []string                 `json:"address_in,omitempty"`
	AddressNotIn                  []string                 `json:"address_not_in,omitempty"`
	AddressLt                     *string                  `json:"address_lt,omitempty"`
	AddressLte                    *string                  `json:"address_lte,omitempty"`
	AddressGt                     *string                  `json:"address_gt,omitempty"`
	AddressGte                    *string                  `json:"address_gte,omitempty"`
	AddressContains               *string                  `json:"address_contains,omitempty"`
	AddressNotContains            *string                  `json:"address_not_contains,omitempty"`
	AddressStartsWith             *string                  `json:"address_starts_with,omitempty"`
	AddressNotStartsWith          *string                  `json:"address_not_starts_with,omitempty"`
	AddressEndsWith               *string                  `json:"address_ends_with,omitempty"`
	AddressNotEndsWith            *string                  `json:"address_not_ends_with,omitempty"`
	Location                      *LocationWhereInput      `json:"location,omitempty"`
	GoogleLink                    *string                  `json:"googleLink,omitempty"`
	GoogleLinkNot                 *string                  `json:"googleLink_not,omitempty"`
	GoogleLinkIn                  []string                 `json:"googleLink_in,omitempty"`
	GoogleLinkNotIn               []string                 `json:"googleLink_not_in,omitempty"`
	GoogleLinkLt                  *string                  `json:"googleLink_lt,omitempty"`
	GoogleLinkLte                 *string                  `json:"googleLink_lte,omitempty"`
	GoogleLinkGt                  *string                  `json:"googleLink_gt,omitempty"`
	GoogleLinkGte                 *string                  `json:"googleLink_gte,omitempty"`
	GoogleLinkContains            *string                  `json:"googleLink_contains,omitempty"`
	GoogleLinkNotContains         *string                  `json:"googleLink_not_contains,omitempty"`
	GoogleLinkStartsWith          *string                  `json:"googleLink_starts_with,omitempty"`
	GoogleLinkNotStartsWith       *string                  `json:"googleLink_not_starts_with,omitempty"`
	GoogleLinkEndsWith            *string                  `json:"googleLink_ends_with,omitempty"`
	GoogleLinkNotEndsWith         *string                  `json:"googleLink_not_ends_with,omitempty"`
	Website                       *string                  `json:"website,omitempty"`
	WebsiteNot                    *string                  `json:"website_not,omitempty"`
	WebsiteIn                     []string                 `json:"website_in,omitempty"`
	WebsiteNotIn                  []string                 `json:"website_not_in,omitempty"`
	WebsiteLt                     *string                  `json:"website_lt,omitempty"`
	WebsiteLte                    *string                  `json:"website_lte,omitempty"`
	WebsiteGt                     *string                  `json:"website_gt,omitempty"`
	WebsiteGte                    *string                  `json:"website_gte,omitempty"`
	WebsiteContains               *string                  `json:"website_contains,omitempty"`
	WebsiteNotContains            *string                  `json:"website_not_contains,omitempty"`
	WebsiteStartsWith             *string                  `json:"website_starts_with,omitempty"`
	WebsiteNotStartsWith          *string                  `json:"website_not_starts_with,omitempty"`
	WebsiteEndsWith               *string                  `json:"website_ends_with,omitempty"`
	WebsiteNotEndsWith            *string                  `json:"website_not_ends_with,omitempty"`
	Type                          *ExperienceType          `json:"type,omitempty"`
	TypeNot                       *ExperienceType          `json:"type_not,omitempty"`
	TypeIn                        []ExperienceType         `json:"type_in,omitempty"`
	TypeNotIn                     []ExperienceType         `json:"type_not_in,omitempty"`
	RoutesEvery                   *RouteWhereInput         `json:"routes_every,omitempty"`
	RoutesSome                    *RouteWhereInput         `json:"routes_some,omitempty"`
	RoutesNone                    *RouteWhereInput         `json:"routes_none,omitempty"`
	ReviewsEvery                  *PersonReviewsWhereInput `json:"reviews_every,omitempty"`
	ReviewsSome                   *PersonReviewsWhereInput `json:"reviews_some,omitempty"`
	ReviewsNone                   *PersonReviewsWhereInput `json:"reviews_none,omitempty"`
	LikedByEvery                  *PersonWhereInput        `json:"likedBy_every,omitempty"`
	LikedBySome                   *PersonWhereInput        `json:"likedBy_some,omitempty"`
	LikedByNone                   *PersonWhereInput        `json:"likedBy_none,omitempty"`
	Popularity                    *float64                 `json:"popularity,omitempty"`
	PopularityNot                 *float64                 `json:"popularity_not,omitempty"`
	PopularityIn                  []float64                `json:"popularity_in,omitempty"`
	PopularityNotIn               []float64                `json:"popularity_not_in,omitempty"`
	PopularityLt                  *float64                 `json:"popularity_lt,omitempty"`
	PopularityLte                 *float64                 `json:"popularity_lte,omitempty"`
	PopularityGt                  *float64                 `json:"popularity_gt,omitempty"`
	PopularityGte                 *float64                 `json:"popularity_gte,omitempty"`
	AmbassadorsEvery              *ExpertWhereInput        `json:"ambassadors_every,omitempty"`
	AmbassadorsSome               *ExpertWhereInput        `json:"ambassadors_some,omitempty"`
	AmbassadorsNone               *ExpertWhereInput        `json:"ambassadors_none,omitempty"`
	ProviderWeb                   *string                  `json:"providerWeb,omitempty"`
	ProviderWebNot                *string                  `json:"providerWeb_not,omitempty"`
	ProviderWebIn                 []string                 `json:"providerWeb_in,omitempty"`
	ProviderWebNotIn              []string                 `json:"providerWeb_not_in,omitempty"`
	ProviderWebLt                 *string                  `json:"providerWeb_lt,omitempty"`
	ProviderWebLte                *string                  `json:"providerWeb_lte,omitempty"`
	ProviderWebGt                 *string                  `json:"providerWeb_gt,omitempty"`
	ProviderWebGte                *string                  `json:"providerWeb_gte,omitempty"`
	ProviderWebContains           *string                  `json:"providerWeb_contains,omitempty"`
	ProviderWebNotContains        *string                  `json:"providerWeb_not_contains,omitempty"`
	ProviderWebStartsWith         *string                  `json:"providerWeb_starts_with,omitempty"`
	ProviderWebNotStartsWith      *string                  `json:"providerWeb_not_starts_with,omitempty"`
	ProviderWebEndsWith           *string                  `json:"providerWeb_ends_with,omitempty"`
	ProviderWebNotEndsWith        *string                  `json:"providerWeb_not_ends_with,omitempty"`
	ContactPhone                  *string                  `json:"contactPhone,omitempty"`
	ContactPhoneNot               *string                  `json:"contactPhone_not,omitempty"`
	ContactPhoneIn                []string                 `json:"contactPhone_in,omitempty"`
	ContactPhoneNotIn             []string                 `json:"contactPhone_not_in,omitempty"`
	ContactPhoneLt                *string                  `json:"contactPhone_lt,omitempty"`
	ContactPhoneLte               *string                  `json:"contactPhone_lte,omitempty"`
	ContactPhoneGt                *string                  `json:"contactPhone_gt,omitempty"`
	ContactPhoneGte               *string                  `json:"contactPhone_gte,omitempty"`
	ContactPhoneContains          *string                  `json:"contactPhone_contains,omitempty"`
	ContactPhoneNotContains       *string                  `json:"contactPhone_not_contains,omitempty"`
	ContactPhoneStartsWith        *string                  `json:"contactPhone_starts_with,omitempty"`
	ContactPhoneNotStartsWith     *string                  `json:"contactPhone_not_starts_with,omitempty"`
	ContactPhoneEndsWith          *string                  `json:"contactPhone_ends_with,omitempty"`
	ContactPhoneNotEndsWith       *string                  `json:"contactPhone_not_ends_with,omitempty"`
	ContactEmail                  *string                  `json:"contactEmail,omitempty"`
	ContactEmailNot               *string                  `json:"contactEmail_not,omitempty"`
	ContactEmailIn                []string                 `json:"contactEmail_in,omitempty"`
	ContactEmailNotIn             []string                 `json:"contactEmail_not_in,omitempty"`
	ContactEmailLt                *string                  `json:"contactEmail_lt,omitempty"`
	ContactEmailLte               *string                  `json:"contactEmail_lte,omitempty"`
	ContactEmailGt                *string                  `json:"contactEmail_gt,omitempty"`
	ContactEmailGte               *string                  `json:"contactEmail_gte,omitempty"`
	ContactEmailContains          *string                  `json:"contactEmail_contains,omitempty"`
	ContactEmailNotContains       *string                  `json:"contactEmail_not_contains,omitempty"`
	ContactEmailStartsWith        *string                  `json:"contactEmail_starts_with,omitempty"`
	ContactEmailNotStartsWith     *string                  `json:"contactEmail_not_starts_with,omitempty"`
	ContactEmailEndsWith          *string                  `json:"contactEmail_ends_with,omitempty"`
	ContactEmailNotEndsWith       *string                  `json:"contactEmail_not_ends_with,omitempty"`
	AddressReference              *string                  `json:"addressReference,omitempty"`
	AddressReferenceNot           *string                  `json:"addressReference_not,omitempty"`
	AddressReferenceIn            []string                 `json:"addressReference_in,omitempty"`
	AddressReferenceNotIn         []string                 `json:"addressReference_not_in,omitempty"`
	AddressReferenceLt            *string                  `json:"addressReference_lt,omitempty"`
	AddressReferenceLte           *string                  `json:"addressReference_lte,omitempty"`
	AddressReferenceGt            *string                  `json:"addressReference_gt,omitempty"`
	AddressReferenceGte           *string                  `json:"addressReference_gte,omitempty"`
	AddressReferenceContains      *string                  `json:"addressReference_contains,omitempty"`
	AddressReferenceNotContains   *string                  `json:"addressReference_not_contains,omitempty"`
	AddressReferenceStartsWith    *string                  `json:"addressReference_starts_with,omitempty"`
	AddressReferenceNotStartsWith *string                  `json:"addressReference_not_starts_with,omitempty"`
	AddressReferenceEndsWith      *string                  `json:"addressReference_ends_with,omitempty"`
	AddressReferenceNotEndsWith   *string                  `json:"addressReference_not_ends_with,omitempty"`
	OpeningHours                  *OpeningHoursWhereInput  `json:"openingHours,omitempty"`
	And                           []PlaceWhereInput        `json:"AND,omitempty"`
	Or                            []PlaceWhereInput        `json:"OR,omitempty"`
	Not                           []PlaceWhereInput        `json:"NOT,omitempty"`
}

type PersonReviewsScalarWhereInput struct {
	ID                 *string                         `json:"id,omitempty"`
	IDNot              *string                         `json:"id_not,omitempty"`
	IDIn               []string                        `json:"id_in,omitempty"`
	IDNotIn            []string                        `json:"id_not_in,omitempty"`
	IDLt               *string                         `json:"id_lt,omitempty"`
	IDLte              *string                         `json:"id_lte,omitempty"`
	IDGt               *string                         `json:"id_gt,omitempty"`
	IDGte              *string                         `json:"id_gte,omitempty"`
	IDContains         *string                         `json:"id_contains,omitempty"`
	IDNotContains      *string                         `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                         `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                         `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                         `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                         `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                         `json:"createdAt,omitempty"`
	CreatedAtNot       *string                         `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                        `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                        `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                         `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                         `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                         `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                         `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                         `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                         `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                        `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                        `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                         `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                         `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                         `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                         `json:"updatedAt_gte,omitempty"`
	ApproveNumber      *int32                          `json:"approveNumber,omitempty"`
	ApproveNumberNot   *int32                          `json:"approveNumber_not,omitempty"`
	ApproveNumberIn    []int32                         `json:"approveNumber_in,omitempty"`
	ApproveNumberNotIn []int32                         `json:"approveNumber_not_in,omitempty"`
	ApproveNumberLt    *int32                          `json:"approveNumber_lt,omitempty"`
	ApproveNumberLte   *int32                          `json:"approveNumber_lte,omitempty"`
	ApproveNumberGt    *int32                          `json:"approveNumber_gt,omitempty"`
	ApproveNumberGte   *int32                          `json:"approveNumber_gte,omitempty"`
	DeclineNumber      *int32                          `json:"declineNumber,omitempty"`
	DeclineNumberNot   *int32                          `json:"declineNumber_not,omitempty"`
	DeclineNumberIn    []int32                         `json:"declineNumber_in,omitempty"`
	DeclineNumberNotIn []int32                         `json:"declineNumber_not_in,omitempty"`
	DeclineNumberLt    *int32                          `json:"declineNumber_lt,omitempty"`
	DeclineNumberLte   *int32                          `json:"declineNumber_lte,omitempty"`
	DeclineNumberGt    *int32                          `json:"declineNumber_gt,omitempty"`
	DeclineNumberGte   *int32                          `json:"declineNumber_gte,omitempty"`
	And                []PersonReviewsScalarWhereInput `json:"AND,omitempty"`
	Or                 []PersonReviewsScalarWhereInput `json:"OR,omitempty"`
	Not                []PersonReviewsScalarWhereInput `json:"NOT,omitempty"`
}

type RouteWhereInput struct {
	ID                 *string                  `json:"id,omitempty"`
	IDNot              *string                  `json:"id_not,omitempty"`
	IDIn               []string                 `json:"id_in,omitempty"`
	IDNotIn            []string                 `json:"id_not_in,omitempty"`
	IDLt               *string                  `json:"id_lt,omitempty"`
	IDLte              *string                  `json:"id_lte,omitempty"`
	IDGt               *string                  `json:"id_gt,omitempty"`
	IDGte              *string                  `json:"id_gte,omitempty"`
	IDContains         *string                  `json:"id_contains,omitempty"`
	IDNotContains      *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                  `json:"createdAt,omitempty"`
	CreatedAtNot       *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                  `json:"updatedAt_gte,omitempty"`
	Name               *string                  `json:"name,omitempty"`
	NameNot            *string                  `json:"name_not,omitempty"`
	NameIn             []string                 `json:"name_in,omitempty"`
	NameNotIn          []string                 `json:"name_not_in,omitempty"`
	NameLt             *string                  `json:"name_lt,omitempty"`
	NameLte            *string                  `json:"name_lte,omitempty"`
	NameGt             *string                  `json:"name_gt,omitempty"`
	NameGte            *string                  `json:"name_gte,omitempty"`
	NameContains       *string                  `json:"name_contains,omitempty"`
	NameNotContains    *string                  `json:"name_not_contains,omitempty"`
	NameStartsWith     *string                  `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string                  `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string                  `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string                  `json:"name_not_ends_with,omitempty"`
	Image              *string                  `json:"image,omitempty"`
	ImageNot           *string                  `json:"image_not,omitempty"`
	ImageIn            []string                 `json:"image_in,omitempty"`
	ImageNotIn         []string                 `json:"image_not_in,omitempty"`
	ImageLt            *string                  `json:"image_lt,omitempty"`
	ImageLte           *string                  `json:"image_lte,omitempty"`
	ImageGt            *string                  `json:"image_gt,omitempty"`
	ImageGte           *string                  `json:"image_gte,omitempty"`
	ImageContains      *string                  `json:"image_contains,omitempty"`
	ImageNotContains   *string                  `json:"image_not_contains,omitempty"`
	ImageStartsWith    *string                  `json:"image_starts_with,omitempty"`
	ImageNotStartsWith *string                  `json:"image_not_starts_with,omitempty"`
	ImageEndsWith      *string                  `json:"image_ends_with,omitempty"`
	ImageNotEndsWith   *string                  `json:"image_not_ends_with,omitempty"`
	Type               *ExperienceType          `json:"type,omitempty"`
	TypeNot            *ExperienceType          `json:"type_not,omitempty"`
	TypeIn             []ExperienceType         `json:"type_in,omitempty"`
	TypeNotIn          []ExperienceType         `json:"type_not_in,omitempty"`
	Creator            *ExpertWhereInput        `json:"creator,omitempty"`
	PlacesEvery        *PlaceWhereInput         `json:"places_every,omitempty"`
	PlacesSome         *PlaceWhereInput         `json:"places_some,omitempty"`
	PlacesNone         *PlaceWhereInput         `json:"places_none,omitempty"`
	LinkedStory        *StoryWhereInput         `json:"linkedStory,omitempty"`
	LikedByEvery       *PersonWhereInput        `json:"likedBy_every,omitempty"`
	LikedBySome        *PersonWhereInput        `json:"likedBy_some,omitempty"`
	LikedByNone        *PersonWhereInput        `json:"likedBy_none,omitempty"`
	ReviewsEvery       *PersonReviewsWhereInput `json:"reviews_every,omitempty"`
	ReviewsSome        *PersonReviewsWhereInput `json:"reviews_some,omitempty"`
	ReviewsNone        *PersonReviewsWhereInput `json:"reviews_none,omitempty"`
	Popularity         *float64                 `json:"popularity,omitempty"`
	PopularityNot      *float64                 `json:"popularity_not,omitempty"`
	PopularityIn       []float64                `json:"popularity_in,omitempty"`
	PopularityNotIn    []float64                `json:"popularity_not_in,omitempty"`
	PopularityLt       *float64                 `json:"popularity_lt,omitempty"`
	PopularityLte      *float64                 `json:"popularity_lte,omitempty"`
	PopularityGt       *float64                 `json:"popularity_gt,omitempty"`
	PopularityGte      *float64                 `json:"popularity_gte,omitempty"`
	Color              *string                  `json:"color,omitempty"`
	ColorNot           *string                  `json:"color_not,omitempty"`
	ColorIn            []string                 `json:"color_in,omitempty"`
	ColorNotIn         []string                 `json:"color_not_in,omitempty"`
	ColorLt            *string                  `json:"color_lt,omitempty"`
	ColorLte           *string                  `json:"color_lte,omitempty"`
	ColorGt            *string                  `json:"color_gt,omitempty"`
	ColorGte           *string                  `json:"color_gte,omitempty"`
	ColorContains      *string                  `json:"color_contains,omitempty"`
	ColorNotContains   *string                  `json:"color_not_contains,omitempty"`
	ColorStartsWith    *string                  `json:"color_starts_with,omitempty"`
	ColorNotStartsWith *string                  `json:"color_not_starts_with,omitempty"`
	ColorEndsWith      *string                  `json:"color_ends_with,omitempty"`
	ColorNotEndsWith   *string                  `json:"color_not_ends_with,omitempty"`
	And                []RouteWhereInput        `json:"AND,omitempty"`
	Or                 []RouteWhereInput        `json:"OR,omitempty"`
	Not                []RouteWhereInput        `json:"NOT,omitempty"`
}

type PersonReviewsUpdateManyWithWhereNestedInput struct {
	Where PersonReviewsScalarWhereInput    `json:"where"`
	Data  PersonReviewsUpdateManyDataInput `json:"data"`
}

type StoryWhereInput struct {
	ID                          *string                  `json:"id,omitempty"`
	IDNot                       *string                  `json:"id_not,omitempty"`
	IDIn                        []string                 `json:"id_in,omitempty"`
	IDNotIn                     []string                 `json:"id_not_in,omitempty"`
	IDLt                        *string                  `json:"id_lt,omitempty"`
	IDLte                       *string                  `json:"id_lte,omitempty"`
	IDGt                        *string                  `json:"id_gt,omitempty"`
	IDGte                       *string                  `json:"id_gte,omitempty"`
	IDContains                  *string                  `json:"id_contains,omitempty"`
	IDNotContains               *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt                   *string                  `json:"createdAt,omitempty"`
	CreatedAtNot                *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string                  `json:"updatedAt_gte,omitempty"`
	Author                      *ExpertWhereInput        `json:"author,omitempty"`
	Type                        *StoryType               `json:"type,omitempty"`
	TypeNot                     *StoryType               `json:"type_not,omitempty"`
	TypeIn                      []StoryType              `json:"type_in,omitempty"`
	TypeNotIn                   []StoryType              `json:"type_not_in,omitempty"`
	PodcastLink                 *string                  `json:"podcastLink,omitempty"`
	PodcastLinkNot              *string                  `json:"podcastLink_not,omitempty"`
	PodcastLinkIn               []string                 `json:"podcastLink_in,omitempty"`
	PodcastLinkNotIn            []string                 `json:"podcastLink_not_in,omitempty"`
	PodcastLinkLt               *string                  `json:"podcastLink_lt,omitempty"`
	PodcastLinkLte              *string                  `json:"podcastLink_lte,omitempty"`
	PodcastLinkGt               *string                  `json:"podcastLink_gt,omitempty"`
	PodcastLinkGte              *string                  `json:"podcastLink_gte,omitempty"`
	PodcastLinkContains         *string                  `json:"podcastLink_contains,omitempty"`
	PodcastLinkNotContains      *string                  `json:"podcastLink_not_contains,omitempty"`
	PodcastLinkStartsWith       *string                  `json:"podcastLink_starts_with,omitempty"`
	PodcastLinkNotStartsWith    *string                  `json:"podcastLink_not_starts_with,omitempty"`
	PodcastLinkEndsWith         *string                  `json:"podcastLink_ends_with,omitempty"`
	PodcastLinkNotEndsWith      *string                  `json:"podcastLink_not_ends_with,omitempty"`
	AudioStream                 *string                  `json:"audioStream,omitempty"`
	AudioStreamNot              *string                  `json:"audioStream_not,omitempty"`
	AudioStreamIn               []string                 `json:"audioStream_in,omitempty"`
	AudioStreamNotIn            []string                 `json:"audioStream_not_in,omitempty"`
	AudioStreamLt               *string                  `json:"audioStream_lt,omitempty"`
	AudioStreamLte              *string                  `json:"audioStream_lte,omitempty"`
	AudioStreamGt               *string                  `json:"audioStream_gt,omitempty"`
	AudioStreamGte              *string                  `json:"audioStream_gte,omitempty"`
	AudioStreamContains         *string                  `json:"audioStream_contains,omitempty"`
	AudioStreamNotContains      *string                  `json:"audioStream_not_contains,omitempty"`
	AudioStreamStartsWith       *string                  `json:"audioStream_starts_with,omitempty"`
	AudioStreamNotStartsWith    *string                  `json:"audioStream_not_starts_with,omitempty"`
	AudioStreamEndsWith         *string                  `json:"audioStream_ends_with,omitempty"`
	AudioStreamNotEndsWith      *string                  `json:"audioStream_not_ends_with,omitempty"`
	PrincipalImage              *string                  `json:"principalImage,omitempty"`
	PrincipalImageNot           *string                  `json:"principalImage_not,omitempty"`
	PrincipalImageIn            []string                 `json:"principalImage_in,omitempty"`
	PrincipalImageNotIn         []string                 `json:"principalImage_not_in,omitempty"`
	PrincipalImageLt            *string                  `json:"principalImage_lt,omitempty"`
	PrincipalImageLte           *string                  `json:"principalImage_lte,omitempty"`
	PrincipalImageGt            *string                  `json:"principalImage_gt,omitempty"`
	PrincipalImageGte           *string                  `json:"principalImage_gte,omitempty"`
	PrincipalImageContains      *string                  `json:"principalImage_contains,omitempty"`
	PrincipalImageNotContains   *string                  `json:"principalImage_not_contains,omitempty"`
	PrincipalImageStartsWith    *string                  `json:"principalImage_starts_with,omitempty"`
	PrincipalImageNotStartsWith *string                  `json:"principalImage_not_starts_with,omitempty"`
	PrincipalImageEndsWith      *string                  `json:"principalImage_ends_with,omitempty"`
	PrincipalImageNotEndsWith   *string                  `json:"principalImage_not_ends_with,omitempty"`
	Title                       *TextWhereInput          `json:"title,omitempty"`
	Body                        *TextWhereInput          `json:"body,omitempty"`
	Likes                       *int32                   `json:"likes,omitempty"`
	LikesNot                    *int32                   `json:"likes_not,omitempty"`
	LikesIn                     []int32                  `json:"likes_in,omitempty"`
	LikesNotIn                  []int32                  `json:"likes_not_in,omitempty"`
	LikesLt                     *int32                   `json:"likes_lt,omitempty"`
	LikesLte                    *int32                   `json:"likes_lte,omitempty"`
	LikesGt                     *int32                   `json:"likes_gt,omitempty"`
	LikesGte                    *int32                   `json:"likes_gte,omitempty"`
	Views                       *int32                   `json:"views,omitempty"`
	ViewsNot                    *int32                   `json:"views_not,omitempty"`
	ViewsIn                     []int32                  `json:"views_in,omitempty"`
	ViewsNotIn                  []int32                  `json:"views_not_in,omitempty"`
	ViewsLt                     *int32                   `json:"views_lt,omitempty"`
	ViewsLte                    *int32                   `json:"views_lte,omitempty"`
	ViewsGt                     *int32                   `json:"views_gt,omitempty"`
	ViewsGte                    *int32                   `json:"views_gte,omitempty"`
	ReviewsEvery                *PersonReviewsWhereInput `json:"reviews_every,omitempty"`
	ReviewsSome                 *PersonReviewsWhereInput `json:"reviews_some,omitempty"`
	ReviewsNone                 *PersonReviewsWhereInput `json:"reviews_none,omitempty"`
	LinkedRoute                 *RouteWhereInput         `json:"linkedRoute,omitempty"`
	And                         []StoryWhereInput        `json:"AND,omitempty"`
	Or                          []StoryWhereInput        `json:"OR,omitempty"`
	Not                         []StoryWhereInput        `json:"NOT,omitempty"`
}

type PersonReviewsUpdateManyDataInput struct {
	ApproveNumber *int32 `json:"approveNumber,omitempty"`
	DeclineNumber *int32 `json:"declineNumber,omitempty"`
}

type PersonReviewsWhereInput struct {
	ID                 *string                   `json:"id,omitempty"`
	IDNot              *string                   `json:"id_not,omitempty"`
	IDIn               []string                  `json:"id_in,omitempty"`
	IDNotIn            []string                  `json:"id_not_in,omitempty"`
	IDLt               *string                   `json:"id_lt,omitempty"`
	IDLte              *string                   `json:"id_lte,omitempty"`
	IDGt               *string                   `json:"id_gt,omitempty"`
	IDGte              *string                   `json:"id_gte,omitempty"`
	IDContains         *string                   `json:"id_contains,omitempty"`
	IDNotContains      *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                   `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                   `json:"createdAt,omitempty"`
	CreatedAtNot       *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                   `json:"updatedAt_gte,omitempty"`
	Person             *PersonWhereInput         `json:"person,omitempty"`
	Title              *TextWhereInput           `json:"title,omitempty"`
	Description        *TextWhereInput           `json:"description,omitempty"`
	ApproveNumber      *int32                    `json:"approveNumber,omitempty"`
	ApproveNumberNot   *int32                    `json:"approveNumber_not,omitempty"`
	ApproveNumberIn    []int32                   `json:"approveNumber_in,omitempty"`
	ApproveNumberNotIn []int32                   `json:"approveNumber_not_in,omitempty"`
	ApproveNumberLt    *int32                    `json:"approveNumber_lt,omitempty"`
	ApproveNumberLte   *int32                    `json:"approveNumber_lte,omitempty"`
	ApproveNumberGt    *int32                    `json:"approveNumber_gt,omitempty"`
	ApproveNumberGte   *int32                    `json:"approveNumber_gte,omitempty"`
	DeclineNumber      *int32                    `json:"declineNumber,omitempty"`
	DeclineNumberNot   *int32                    `json:"declineNumber_not,omitempty"`
	DeclineNumberIn    []int32                   `json:"declineNumber_in,omitempty"`
	DeclineNumberNotIn []int32                   `json:"declineNumber_not_in,omitempty"`
	DeclineNumberLt    *int32                    `json:"declineNumber_lt,omitempty"`
	DeclineNumberLte   *int32                    `json:"declineNumber_lte,omitempty"`
	DeclineNumberGt    *int32                    `json:"declineNumber_gt,omitempty"`
	DeclineNumberGte   *int32                    `json:"declineNumber_gte,omitempty"`
	CommentsEvery      *PersonReviewsWhereInput  `json:"comments_every,omitempty"`
	CommentsSome       *PersonReviewsWhereInput  `json:"comments_some,omitempty"`
	CommentsNone       *PersonReviewsWhereInput  `json:"comments_none,omitempty"`
	And                []PersonReviewsWhereInput `json:"AND,omitempty"`
	Or                 []PersonReviewsWhereInput `json:"OR,omitempty"`
	Not                []PersonReviewsWhereInput `json:"NOT,omitempty"`
}

type PlaceCreateManyWithoutRoutesInput struct {
	Create  []PlaceCreateWithoutRoutesInput `json:"create,omitempty"`
	Connect []PlaceWhereUniqueInput         `json:"connect,omitempty"`
}

type ExpertUpdateManyMutationInput struct {
	Alias *string `json:"alias,omitempty"`
}

type PlaceCreateWithoutRoutesInput struct {
	ID               *string                       `json:"id,omitempty"`
	Name             string                        `json:"name"`
	ShortName        *string                       `json:"shortName,omitempty"`
	Description      TextCreateOneInput            `json:"description"`
	ShortDescription *TextCreateOneInput           `json:"shortDescription,omitempty"`
	Address          string                        `json:"address"`
	Location         LocationCreateOneInput        `json:"location"`
	GoogleLink       *string                       `json:"googleLink,omitempty"`
	Website          *string                       `json:"website,omitempty"`
	Type             *ExperienceType               `json:"type,omitempty"`
	ExtraTypes       *PlaceCreateextraTypesInput   `json:"extraTypes,omitempty"`
	Reviews          *PersonReviewsCreateManyInput `json:"reviews,omitempty"`
	Tags             *PlaceCreatetagsInput         `json:"tags,omitempty"`
	LikedBy          *PersonCreateManyInput        `json:"likedBy,omitempty"`
	Popularity       *float64                      `json:"popularity,omitempty"`
	Ambassadors      *ExpertCreateManyInput        `json:"ambassadors,omitempty"`
	ProviderWeb      *string                       `json:"providerWeb,omitempty"`
	ContactPhone     *string                       `json:"contactPhone,omitempty"`
	ContactEmail     *string                       `json:"contactEmail,omitempty"`
	AddressReference *string                       `json:"addressReference,omitempty"`
	OpeningHours     OpeningHoursCreateOneInput    `json:"openingHours"`
}

type RouteUpdateOneWithoutLinkedStoryInput struct {
	Create     *RouteCreateWithoutLinkedStoryInput     `json:"create,omitempty"`
	Update     *RouteUpdateWithoutLinkedStoryDataInput `json:"update,omitempty"`
	Upsert     *RouteUpsertWithoutLinkedStoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                   `json:"delete,omitempty"`
	Disconnect *bool                                   `json:"disconnect,omitempty"`
	Connect    *RouteWhereUniqueInput                  `json:"connect,omitempty"`
}

type PlaceCreatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type TicketSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *TicketWhereInput              `json:"node,omitempty"`
	And                        []TicketSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TicketSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TicketSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PersonCreateManyInput struct {
	Create  []PersonCreateInput      `json:"create,omitempty"`
	Connect []PersonWhereUniqueInput `json:"connect,omitempty"`
}

type TextSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *TextWhereInput              `json:"node,omitempty"`
	And                        []TextSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TextSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TextSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ExpertCreateManyInput struct {
	Create  []ExpertCreateInput      `json:"create,omitempty"`
	Connect []ExpertWhereUniqueInput `json:"connect,omitempty"`
}

type RouteSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *RouteWhereInput              `json:"node,omitempty"`
	And                        []RouteSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []RouteSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []RouteSubscriptionWhereInput `json:"NOT,omitempty"`
}

type StoryCreateOneWithoutLinkedRouteInput struct {
	Create  *StoryCreateWithoutLinkedRouteInput `json:"create,omitempty"`
	Connect *StoryWhereUniqueInput              `json:"connect,omitempty"`
}

type ProductEntrySubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *ProductEntryWhereInput              `json:"node,omitempty"`
	And                        []ProductEntrySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ProductEntrySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ProductEntrySubscriptionWhereInput `json:"NOT,omitempty"`
}

type StoryCreateWithoutLinkedRouteInput struct {
	ID             *string                            `json:"id,omitempty"`
	Author         ExpertCreateOneWithoutStoriesInput `json:"author"`
	Type           StoryType                          `json:"type"`
	Tags           *StoryCreatetagsInput              `json:"tags,omitempty"`
	PodcastLink    *string                            `json:"podcastLink,omitempty"`
	AudioStream    *string                            `json:"audioStream,omitempty"`
	PrincipalImage string                             `json:"principalImage"`
	Title          TextCreateOneInput                 `json:"title"`
	Body           TextCreateOneInput                 `json:"body"`
	Likes          int32                              `json:"likes"`
	Views          int32                              `json:"views"`
	Reviews        *PersonReviewsCreateManyInput      `json:"reviews,omitempty"`
}

type PartnerWhereInput struct {
	ID                        *string                 `json:"id,omitempty"`
	IDNot                     *string                 `json:"id_not,omitempty"`
	IDIn                      []string                `json:"id_in,omitempty"`
	IDNotIn                   []string                `json:"id_not_in,omitempty"`
	IDLt                      *string                 `json:"id_lt,omitempty"`
	IDLte                     *string                 `json:"id_lte,omitempty"`
	IDGt                      *string                 `json:"id_gt,omitempty"`
	IDGte                     *string                 `json:"id_gte,omitempty"`
	IDContains                *string                 `json:"id_contains,omitempty"`
	IDNotContains             *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith              *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt                 *string                 `json:"createdAt,omitempty"`
	CreatedAtNot              *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt                 *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot              *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn               []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn            []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt               *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte              *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt               *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte              *string                 `json:"updatedAt_gte,omitempty"`
	Attender                  *PersonWhereInput       `json:"attender,omitempty"`
	Owner                     *PersonWhereInput       `json:"owner,omitempty"`
	AttractionsEvery          *AttractionWhereInput   `json:"attractions_every,omitempty"`
	AttractionsSome           *AttractionWhereInput   `json:"attractions_some,omitempty"`
	AttractionsNone           *AttractionWhereInput   `json:"attractions_none,omitempty"`
	BrandName                 *string                 `json:"brandName,omitempty"`
	BrandNameNot              *string                 `json:"brandName_not,omitempty"`
	BrandNameIn               []string                `json:"brandName_in,omitempty"`
	BrandNameNotIn            []string                `json:"brandName_not_in,omitempty"`
	BrandNameLt               *string                 `json:"brandName_lt,omitempty"`
	BrandNameLte              *string                 `json:"brandName_lte,omitempty"`
	BrandNameGt               *string                 `json:"brandName_gt,omitempty"`
	BrandNameGte              *string                 `json:"brandName_gte,omitempty"`
	BrandNameContains         *string                 `json:"brandName_contains,omitempty"`
	BrandNameNotContains      *string                 `json:"brandName_not_contains,omitempty"`
	BrandNameStartsWith       *string                 `json:"brandName_starts_with,omitempty"`
	BrandNameNotStartsWith    *string                 `json:"brandName_not_starts_with,omitempty"`
	BrandNameEndsWith         *string                 `json:"brandName_ends_with,omitempty"`
	BrandNameNotEndsWith      *string                 `json:"brandName_not_ends_with,omitempty"`
	Logo                      *string                 `json:"logo,omitempty"`
	LogoNot                   *string                 `json:"logo_not,omitempty"`
	LogoIn                    []string                `json:"logo_in,omitempty"`
	LogoNotIn                 []string                `json:"logo_not_in,omitempty"`
	LogoLt                    *string                 `json:"logo_lt,omitempty"`
	LogoLte                   *string                 `json:"logo_lte,omitempty"`
	LogoGt                    *string                 `json:"logo_gt,omitempty"`
	LogoGte                   *string                 `json:"logo_gte,omitempty"`
	LogoContains              *string                 `json:"logo_contains,omitempty"`
	LogoNotContains           *string                 `json:"logo_not_contains,omitempty"`
	LogoStartsWith            *string                 `json:"logo_starts_with,omitempty"`
	LogoNotStartsWith         *string                 `json:"logo_not_starts_with,omitempty"`
	LogoEndsWith              *string                 `json:"logo_ends_with,omitempty"`
	LogoNotEndsWith           *string                 `json:"logo_not_ends_with,omitempty"`
	SocialReason              *string                 `json:"socialReason,omitempty"`
	SocialReasonNot           *string                 `json:"socialReason_not,omitempty"`
	SocialReasonIn            []string                `json:"socialReason_in,omitempty"`
	SocialReasonNotIn         []string                `json:"socialReason_not_in,omitempty"`
	SocialReasonLt            *string                 `json:"socialReason_lt,omitempty"`
	SocialReasonLte           *string                 `json:"socialReason_lte,omitempty"`
	SocialReasonGt            *string                 `json:"socialReason_gt,omitempty"`
	SocialReasonGte           *string                 `json:"socialReason_gte,omitempty"`
	SocialReasonContains      *string                 `json:"socialReason_contains,omitempty"`
	SocialReasonNotContains   *string                 `json:"socialReason_not_contains,omitempty"`
	SocialReasonStartsWith    *string                 `json:"socialReason_starts_with,omitempty"`
	SocialReasonNotStartsWith *string                 `json:"socialReason_not_starts_with,omitempty"`
	SocialReasonEndsWith      *string                 `json:"socialReason_ends_with,omitempty"`
	SocialReasonNotEndsWith   *string                 `json:"socialReason_not_ends_with,omitempty"`
	Ruc                       *string                 `json:"ruc,omitempty"`
	RucNot                    *string                 `json:"ruc_not,omitempty"`
	RucIn                     []string                `json:"ruc_in,omitempty"`
	RucNotIn                  []string                `json:"ruc_not_in,omitempty"`
	RucLt                     *string                 `json:"ruc_lt,omitempty"`
	RucLte                    *string                 `json:"ruc_lte,omitempty"`
	RucGt                     *string                 `json:"ruc_gt,omitempty"`
	RucGte                    *string                 `json:"ruc_gte,omitempty"`
	RucContains               *string                 `json:"ruc_contains,omitempty"`
	RucNotContains            *string                 `json:"ruc_not_contains,omitempty"`
	RucStartsWith             *string                 `json:"ruc_starts_with,omitempty"`
	RucNotStartsWith          *string                 `json:"ruc_not_starts_with,omitempty"`
	RucEndsWith               *string                 `json:"ruc_ends_with,omitempty"`
	RucNotEndsWith            *string                 `json:"ruc_not_ends_with,omitempty"`
	Address                   *string                 `json:"address,omitempty"`
	AddressNot                *string                 `json:"address_not,omitempty"`
	AddressIn                 []string                `json:"address_in,omitempty"`
	AddressNotIn              []string                `json:"address_not_in,omitempty"`
	AddressLt                 *string                 `json:"address_lt,omitempty"`
	AddressLte                *string                 `json:"address_lte,omitempty"`
	AddressGt                 *string                 `json:"address_gt,omitempty"`
	AddressGte                *string                 `json:"address_gte,omitempty"`
	AddressContains           *string                 `json:"address_contains,omitempty"`
	AddressNotContains        *string                 `json:"address_not_contains,omitempty"`
	AddressStartsWith         *string                 `json:"address_starts_with,omitempty"`
	AddressNotStartsWith      *string                 `json:"address_not_starts_with,omitempty"`
	AddressEndsWith           *string                 `json:"address_ends_with,omitempty"`
	AddressNotEndsWith        *string                 `json:"address_not_ends_with,omitempty"`
	Location                  *LocationWhereInput     `json:"location,omitempty"`
	FeaturesEvery             *FeatureWhereInput      `json:"features_every,omitempty"`
	FeaturesSome              *FeatureWhereInput      `json:"features_some,omitempty"`
	FeaturesNone              *FeatureWhereInput      `json:"features_none,omitempty"`
	ServiceHours              *OpeningHoursWhereInput `json:"serviceHours,omitempty"`
	RegistryEvery             *EntryTicketWhereInput  `json:"registry_every,omitempty"`
	RegistrySome              *EntryTicketWhereInput  `json:"registry_some,omitempty"`
	RegistryNone              *EntryTicketWhereInput  `json:"registry_none,omitempty"`
	And                       []PartnerWhereInput     `json:"AND,omitempty"`
	Or                        []PartnerWhereInput     `json:"OR,omitempty"`
	Not                       []PartnerWhereInput     `json:"NOT,omitempty"`
}

type ExpertCreateOneWithoutStoriesInput struct {
	Create  *ExpertCreateWithoutStoriesInput `json:"create,omitempty"`
	Connect *ExpertWhereUniqueInput          `json:"connect,omitempty"`
}

type AttractionWhereInput struct {
	ID                          *string                `json:"id,omitempty"`
	IDNot                       *string                `json:"id_not,omitempty"`
	IDIn                        []string               `json:"id_in,omitempty"`
	IDNotIn                     []string               `json:"id_not_in,omitempty"`
	IDLt                        *string                `json:"id_lt,omitempty"`
	IDLte                       *string                `json:"id_lte,omitempty"`
	IDGt                        *string                `json:"id_gt,omitempty"`
	IDGte                       *string                `json:"id_gte,omitempty"`
	IDContains                  *string                `json:"id_contains,omitempty"`
	IDNotContains               *string                `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt                   *string                `json:"createdAt,omitempty"`
	CreatedAtNot                *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string                `json:"updatedAt_gte,omitempty"`
	Owner                       *PartnerWhereInput     `json:"owner,omitempty"`
	Name                        *TextWhereInput        `json:"name,omitempty"`
	Description                 *TextWhereInput        `json:"description,omitempty"`
	ShortDescription            *TextWhereInput        `json:"shortDescription,omitempty"`
	Faqs                        *FaqWhereInput         `json:"faqs,omitempty"`
	PrincipalImage              *string                `json:"principalImage,omitempty"`
	PrincipalImageNot           *string                `json:"principalImage_not,omitempty"`
	PrincipalImageIn            []string               `json:"principalImage_in,omitempty"`
	PrincipalImageNotIn         []string               `json:"principalImage_not_in,omitempty"`
	PrincipalImageLt            *string                `json:"principalImage_lt,omitempty"`
	PrincipalImageLte           *string                `json:"principalImage_lte,omitempty"`
	PrincipalImageGt            *string                `json:"principalImage_gt,omitempty"`
	PrincipalImageGte           *string                `json:"principalImage_gte,omitempty"`
	PrincipalImageContains      *string                `json:"principalImage_contains,omitempty"`
	PrincipalImageNotContains   *string                `json:"principalImage_not_contains,omitempty"`
	PrincipalImageStartsWith    *string                `json:"principalImage_starts_with,omitempty"`
	PrincipalImageNotStartsWith *string                `json:"principalImage_not_starts_with,omitempty"`
	PrincipalImageEndsWith      *string                `json:"principalImage_ends_with,omitempty"`
	PrincipalImageNotEndsWith   *string                `json:"principalImage_not_ends_with,omitempty"`
	CoverImage                  *string                `json:"coverImage,omitempty"`
	CoverImageNot               *string                `json:"coverImage_not,omitempty"`
	CoverImageIn                []string               `json:"coverImage_in,omitempty"`
	CoverImageNotIn             []string               `json:"coverImage_not_in,omitempty"`
	CoverImageLt                *string                `json:"coverImage_lt,omitempty"`
	CoverImageLte               *string                `json:"coverImage_lte,omitempty"`
	CoverImageGt                *string                `json:"coverImage_gt,omitempty"`
	CoverImageGte               *string                `json:"coverImage_gte,omitempty"`
	CoverImageContains          *string                `json:"coverImage_contains,omitempty"`
	CoverImageNotContains       *string                `json:"coverImage_not_contains,omitempty"`
	CoverImageStartsWith        *string                `json:"coverImage_starts_with,omitempty"`
	CoverImageNotStartsWith     *string                `json:"coverImage_not_starts_with,omitempty"`
	CoverImageEndsWith          *string                `json:"coverImage_ends_with,omitempty"`
	CoverImageNotEndsWith       *string                `json:"coverImage_not_ends_with,omitempty"`
	LandscapeImage              *string                `json:"landscapeImage,omitempty"`
	LandscapeImageNot           *string                `json:"landscapeImage_not,omitempty"`
	LandscapeImageIn            []string               `json:"landscapeImage_in,omitempty"`
	LandscapeImageNotIn         []string               `json:"landscapeImage_not_in,omitempty"`
	LandscapeImageLt            *string                `json:"landscapeImage_lt,omitempty"`
	LandscapeImageLte           *string                `json:"landscapeImage_lte,omitempty"`
	LandscapeImageGt            *string                `json:"landscapeImage_gt,omitempty"`
	LandscapeImageGte           *string                `json:"landscapeImage_gte,omitempty"`
	LandscapeImageContains      *string                `json:"landscapeImage_contains,omitempty"`
	LandscapeImageNotContains   *string                `json:"landscapeImage_not_contains,omitempty"`
	LandscapeImageStartsWith    *string                `json:"landscapeImage_starts_with,omitempty"`
	LandscapeImageNotStartsWith *string                `json:"landscapeImage_not_starts_with,omitempty"`
	LandscapeImageEndsWith      *string                `json:"landscapeImage_ends_with,omitempty"`
	LandscapeImageNotEndsWith   *string                `json:"landscapeImage_not_ends_with,omitempty"`
	Place                       *PlaceWhereInput       `json:"place,omitempty"`
	And                         []AttractionWhereInput `json:"AND,omitempty"`
	Or                          []AttractionWhereInput `json:"OR,omitempty"`
	Not                         []AttractionWhereInput `json:"NOT,omitempty"`
}

type ExpertCreateWithoutStoriesInput struct {
	ID     *string              `json:"id,omitempty"`
	Person PersonCreateOneInput `json:"person"`
	Alias  string               `json:"alias"`
}

type PersonSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *PersonWhereInput              `json:"node,omitempty"`
	And                        []PersonSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PersonSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PersonSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AttractionUpdateInput struct {
	Owner            *PartnerUpdateOneRequiredWithoutAttractionsInput `json:"owner,omitempty"`
	Name             *TextUpdateOneRequiredInput                      `json:"name,omitempty"`
	Description      *TextUpdateOneInput                              `json:"description,omitempty"`
	ShortDescription *TextUpdateOneInput                              `json:"shortDescription,omitempty"`
	Faqs             *FaqUpdateOneRequiredWithoutAttractionInput      `json:"faqs,omitempty"`
	PrincipalImage   *string                                          `json:"principalImage,omitempty"`
	CoverImage       *string                                          `json:"coverImage,omitempty"`
	LandscapeImage   *string                                          `json:"landscapeImage,omitempty"`
	Gallery          *AttractionUpdategalleryInput                    `json:"gallery,omitempty"`
	Type             *AttractionUpdatetypeInput                       `json:"type,omitempty"`
	Place            *PlaceUpdateOneRequiredInput                     `json:"place,omitempty"`
}

type PassTypeSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *PassTypeWhereInput              `json:"node,omitempty"`
	And                        []PassTypeSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PassTypeSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PassTypeSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PartnerUpdateOneRequiredWithoutAttractionsInput struct {
	Create  *PartnerCreateWithoutAttractionsInput     `json:"create,omitempty"`
	Update  *PartnerUpdateWithoutAttractionsDataInput `json:"update,omitempty"`
	Upsert  *PartnerUpsertWithoutAttractionsInput     `json:"upsert,omitempty"`
	Connect *PartnerWhereUniqueInput                  `json:"connect,omitempty"`
}

type PartnerSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *PartnerWhereInput              `json:"node,omitempty"`
	And                        []PartnerSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PartnerSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PartnerSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PartnerUpdateWithoutAttractionsDataInput struct {
	Attender     *PersonUpdateOneRequiredInput             `json:"attender,omitempty"`
	Owner        *PersonUpdateOneInput                     `json:"owner,omitempty"`
	BrandName    *string                                   `json:"brandName,omitempty"`
	Logo         *string                                   `json:"logo,omitempty"`
	SocialReason *string                                   `json:"socialReason,omitempty"`
	Ruc          *string                                   `json:"ruc,omitempty"`
	Address      *string                                   `json:"address,omitempty"`
	Location     *LocationUpdateOneRequiredInput           `json:"location,omitempty"`
	Features     *FeatureUpdateManyInput                   `json:"features,omitempty"`
	ServiceHours *OpeningHoursUpdateOneInput               `json:"serviceHours,omitempty"`
	Registry     *EntryTicketUpdateManyWithoutPartnerInput `json:"registry,omitempty"`
}

type LocationSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *LocationWhereInput              `json:"node,omitempty"`
	And                        []LocationSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []LocationSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []LocationSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PersonUpdateOneRequiredInput struct {
	Create  *PersonCreateInput       `json:"create,omitempty"`
	Update  *PersonUpdateDataInput   `json:"update,omitempty"`
	Upsert  *PersonUpsertNestedInput `json:"upsert,omitempty"`
	Connect *PersonWhereUniqueInput  `json:"connect,omitempty"`
}

type LimaSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *LimaWhereInput              `json:"node,omitempty"`
	And                        []LimaSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []LimaSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []LimaSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PersonUpdateDataInput struct {
	QmId           *string                                        `json:"qmID,omitempty"`
	Name           *string                                        `json:"name,omitempty"`
	Photo          *string                                        `json:"photo,omitempty"`
	Birthdate      *string                                        `json:"birthdate,omitempty"`
	Country        *TextUpdateOneInput                            `json:"country,omitempty"`
	Phones         *PhoneChannelUpdateManyWithoutPersonInput      `json:"phones,omitempty"`
	Emails         *EmailChannelUpdateManyWithoutPersonInput      `json:"emails,omitempty"`
	IDentification *IDDocumentUpdateOneRequiredWithoutPersonInput `json:"identification,omitempty"`
	Tags           *PersonUpdatetagsInput                         `json:"tags,omitempty"`
	Credentials    *CredentialUpdateManyWithoutOwnerInput         `json:"credentials,omitempty"`
}

type CredentialWhereInput struct {
	ID                          *string                `json:"id,omitempty"`
	IDNot                       *string                `json:"id_not,omitempty"`
	IDIn                        []string               `json:"id_in,omitempty"`
	IDNotIn                     []string               `json:"id_not_in,omitempty"`
	IDLt                        *string                `json:"id_lt,omitempty"`
	IDLte                       *string                `json:"id_lte,omitempty"`
	IDGt                        *string                `json:"id_gt,omitempty"`
	IDGte                       *string                `json:"id_gte,omitempty"`
	IDContains                  *string                `json:"id_contains,omitempty"`
	IDNotContains               *string                `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt                   *string                `json:"createdAt,omitempty"`
	CreatedAtNot                *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string                `json:"updatedAt_gte,omitempty"`
	DisplayName                 *string                `json:"displayName,omitempty"`
	DisplayNameNot              *string                `json:"displayName_not,omitempty"`
	DisplayNameIn               []string               `json:"displayName_in,omitempty"`
	DisplayNameNotIn            []string               `json:"displayName_not_in,omitempty"`
	DisplayNameLt               *string                `json:"displayName_lt,omitempty"`
	DisplayNameLte              *string                `json:"displayName_lte,omitempty"`
	DisplayNameGt               *string                `json:"displayName_gt,omitempty"`
	DisplayNameGte              *string                `json:"displayName_gte,omitempty"`
	DisplayNameContains         *string                `json:"displayName_contains,omitempty"`
	DisplayNameNotContains      *string                `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith       *string                `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith    *string                `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith         *string                `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith      *string                `json:"displayName_not_ends_with,omitempty"`
	Owner                       *PersonWhereInput      `json:"owner,omitempty"`
	IsMain                      *bool                  `json:"isMain,omitempty"`
	IsMainNot                   *bool                  `json:"isMain_not,omitempty"`
	Type                        *CredentialType        `json:"type,omitempty"`
	TypeNot                     *CredentialType        `json:"type_not,omitempty"`
	TypeIn                      []CredentialType       `json:"type_in,omitempty"`
	TypeNotIn                   []CredentialType       `json:"type_not_in,omitempty"`
	Validated                   *bool                  `json:"validated,omitempty"`
	ValidatedNot                *bool                  `json:"validated_not,omitempty"`
	ValidationId                *string                `json:"validationID,omitempty"`
	ValidationIdNot             *string                `json:"validationID_not,omitempty"`
	ValidationIdIn              []string               `json:"validationID_in,omitempty"`
	ValidationIdNotIn           []string               `json:"validationID_not_in,omitempty"`
	ValidationIdLt              *string                `json:"validationID_lt,omitempty"`
	ValidationIdLte             *string                `json:"validationID_lte,omitempty"`
	ValidationIdGt              *string                `json:"validationID_gt,omitempty"`
	ValidationIdGte             *string                `json:"validationID_gte,omitempty"`
	ValidationIdContains        *string                `json:"validationID_contains,omitempty"`
	ValidationIdNotContains     *string                `json:"validationID_not_contains,omitempty"`
	ValidationIdStartsWith      *string                `json:"validationID_starts_with,omitempty"`
	ValidationIdNotStartsWith   *string                `json:"validationID_not_starts_with,omitempty"`
	ValidationIdEndsWith        *string                `json:"validationID_ends_with,omitempty"`
	ValidationIdNotEndsWith     *string                `json:"validationID_not_ends_with,omitempty"`
	Value                       *string                `json:"value,omitempty"`
	ValueNot                    *string                `json:"value_not,omitempty"`
	ValueIn                     []string               `json:"value_in,omitempty"`
	ValueNotIn                  []string               `json:"value_not_in,omitempty"`
	ValueLt                     *string                `json:"value_lt,omitempty"`
	ValueLte                    *string                `json:"value_lte,omitempty"`
	ValueGt                     *string                `json:"value_gt,omitempty"`
	ValueGte                    *string                `json:"value_gte,omitempty"`
	ValueContains               *string                `json:"value_contains,omitempty"`
	ValueNotContains            *string                `json:"value_not_contains,omitempty"`
	ValueStartsWith             *string                `json:"value_starts_with,omitempty"`
	ValueNotStartsWith          *string                `json:"value_not_starts_with,omitempty"`
	ValueEndsWith               *string                `json:"value_ends_with,omitempty"`
	ValueNotEndsWith            *string                `json:"value_not_ends_with,omitempty"`
	RawPassword                 *string                `json:"rawPassword,omitempty"`
	RawPasswordNot              *string                `json:"rawPassword_not,omitempty"`
	RawPasswordIn               []string               `json:"rawPassword_in,omitempty"`
	RawPasswordNotIn            []string               `json:"rawPassword_not_in,omitempty"`
	RawPasswordLt               *string                `json:"rawPassword_lt,omitempty"`
	RawPasswordLte              *string                `json:"rawPassword_lte,omitempty"`
	RawPasswordGt               *string                `json:"rawPassword_gt,omitempty"`
	RawPasswordGte              *string                `json:"rawPassword_gte,omitempty"`
	RawPasswordContains         *string                `json:"rawPassword_contains,omitempty"`
	RawPasswordNotContains      *string                `json:"rawPassword_not_contains,omitempty"`
	RawPasswordStartsWith       *string                `json:"rawPassword_starts_with,omitempty"`
	RawPasswordNotStartsWith    *string                `json:"rawPassword_not_starts_with,omitempty"`
	RawPasswordEndsWith         *string                `json:"rawPassword_ends_with,omitempty"`
	RawPasswordNotEndsWith      *string                `json:"rawPassword_not_ends_with,omitempty"`
	HashedPassword              *string                `json:"hashedPassword,omitempty"`
	HashedPasswordNot           *string                `json:"hashedPassword_not,omitempty"`
	HashedPasswordIn            []string               `json:"hashedPassword_in,omitempty"`
	HashedPasswordNotIn         []string               `json:"hashedPassword_not_in,omitempty"`
	HashedPasswordLt            *string                `json:"hashedPassword_lt,omitempty"`
	HashedPasswordLte           *string                `json:"hashedPassword_lte,omitempty"`
	HashedPasswordGt            *string                `json:"hashedPassword_gt,omitempty"`
	HashedPasswordGte           *string                `json:"hashedPassword_gte,omitempty"`
	HashedPasswordContains      *string                `json:"hashedPassword_contains,omitempty"`
	HashedPasswordNotContains   *string                `json:"hashedPassword_not_contains,omitempty"`
	HashedPasswordStartsWith    *string                `json:"hashedPassword_starts_with,omitempty"`
	HashedPasswordNotStartsWith *string                `json:"hashedPassword_not_starts_with,omitempty"`
	HashedPasswordEndsWith      *string                `json:"hashedPassword_ends_with,omitempty"`
	HashedPasswordNotEndsWith   *string                `json:"hashedPassword_not_ends_with,omitempty"`
	And                         []CredentialWhereInput `json:"AND,omitempty"`
	Or                          []CredentialWhereInput `json:"OR,omitempty"`
	Not                         []CredentialWhereInput `json:"NOT,omitempty"`
}

type TextUpdateOneInput struct {
	Create     *TextCreateInput       `json:"create,omitempty"`
	Update     *TextUpdateDataInput   `json:"update,omitempty"`
	Upsert     *TextUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                  `json:"delete,omitempty"`
	Disconnect *bool                  `json:"disconnect,omitempty"`
	Connect    *TextWhereUniqueInput  `json:"connect,omitempty"`
}

type FaqEntrySubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *FaqEntryWhereInput              `json:"node,omitempty"`
	And                        []FaqEntrySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []FaqEntrySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []FaqEntrySubscriptionWhereInput `json:"NOT,omitempty"`
}

type TextUpdateDataInput struct {
	English *string `json:"english,omitempty"`
	Spanish *string `json:"spanish,omitempty"`
}

type FaqSubscriptionWhereInput struct {
	MutationIn                 []MutationType              `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                    `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                    `json:"updatedFields_contains_some,omitempty"`
	Node                       *FaqWhereInput              `json:"node,omitempty"`
	And                        []FaqSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []FaqSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []FaqSubscriptionWhereInput `json:"NOT,omitempty"`
}

type TextUpsertNestedInput struct {
	Update TextUpdateDataInput `json:"update"`
	Create TextCreateInput     `json:"create"`
}

type ExpertSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *ExpertWhereInput              `json:"node,omitempty"`
	And                        []ExpertSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ExpertSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ExpertSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PhoneChannelUpdateManyWithoutPersonInput struct {
	Create     []PhoneChannelCreateWithoutPersonInput                `json:"create,omitempty"`
	Delete     []PhoneChannelWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []PhoneChannelWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []PhoneChannelWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []PhoneChannelWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []PhoneChannelUpdateWithWhereUniqueWithoutPersonInput `json:"update,omitempty"`
	Upsert     []PhoneChannelUpsertWithWhereUniqueWithoutPersonInput `json:"upsert,omitempty"`
	DeleteMany []PhoneChannelScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []PhoneChannelUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type PersonWhereInput struct {
	ID                 *string                 `json:"id,omitempty"`
	IDNot              *string                 `json:"id_not,omitempty"`
	IDIn               []string                `json:"id_in,omitempty"`
	IDNotIn            []string                `json:"id_not_in,omitempty"`
	IDLt               *string                 `json:"id_lt,omitempty"`
	IDLte              *string                 `json:"id_lte,omitempty"`
	IDGt               *string                 `json:"id_gt,omitempty"`
	IDGte              *string                 `json:"id_gte,omitempty"`
	IDContains         *string                 `json:"id_contains,omitempty"`
	IDNotContains      *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                 `json:"createdAt,omitempty"`
	CreatedAtNot       *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                 `json:"updatedAt_gte,omitempty"`
	QmId               *string                 `json:"qmID,omitempty"`
	QmIdNot            *string                 `json:"qmID_not,omitempty"`
	QmIdIn             []string                `json:"qmID_in,omitempty"`
	QmIdNotIn          []string                `json:"qmID_not_in,omitempty"`
	QmIdLt             *string                 `json:"qmID_lt,omitempty"`
	QmIdLte            *string                 `json:"qmID_lte,omitempty"`
	QmIdGt             *string                 `json:"qmID_gt,omitempty"`
	QmIdGte            *string                 `json:"qmID_gte,omitempty"`
	QmIdContains       *string                 `json:"qmID_contains,omitempty"`
	QmIdNotContains    *string                 `json:"qmID_not_contains,omitempty"`
	QmIdStartsWith     *string                 `json:"qmID_starts_with,omitempty"`
	QmIdNotStartsWith  *string                 `json:"qmID_not_starts_with,omitempty"`
	QmIdEndsWith       *string                 `json:"qmID_ends_with,omitempty"`
	QmIdNotEndsWith    *string                 `json:"qmID_not_ends_with,omitempty"`
	Name               *string                 `json:"name,omitempty"`
	NameNot            *string                 `json:"name_not,omitempty"`
	NameIn             []string                `json:"name_in,omitempty"`
	NameNotIn          []string                `json:"name_not_in,omitempty"`
	NameLt             *string                 `json:"name_lt,omitempty"`
	NameLte            *string                 `json:"name_lte,omitempty"`
	NameGt             *string                 `json:"name_gt,omitempty"`
	NameGte            *string                 `json:"name_gte,omitempty"`
	NameContains       *string                 `json:"name_contains,omitempty"`
	NameNotContains    *string                 `json:"name_not_contains,omitempty"`
	NameStartsWith     *string                 `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string                 `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string                 `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string                 `json:"name_not_ends_with,omitempty"`
	Photo              *string                 `json:"photo,omitempty"`
	PhotoNot           *string                 `json:"photo_not,omitempty"`
	PhotoIn            []string                `json:"photo_in,omitempty"`
	PhotoNotIn         []string                `json:"photo_not_in,omitempty"`
	PhotoLt            *string                 `json:"photo_lt,omitempty"`
	PhotoLte           *string                 `json:"photo_lte,omitempty"`
	PhotoGt            *string                 `json:"photo_gt,omitempty"`
	PhotoGte           *string                 `json:"photo_gte,omitempty"`
	PhotoContains      *string                 `json:"photo_contains,omitempty"`
	PhotoNotContains   *string                 `json:"photo_not_contains,omitempty"`
	PhotoStartsWith    *string                 `json:"photo_starts_with,omitempty"`
	PhotoNotStartsWith *string                 `json:"photo_not_starts_with,omitempty"`
	PhotoEndsWith      *string                 `json:"photo_ends_with,omitempty"`
	PhotoNotEndsWith   *string                 `json:"photo_not_ends_with,omitempty"`
	Birthdate          *string                 `json:"birthdate,omitempty"`
	BirthdateNot       *string                 `json:"birthdate_not,omitempty"`
	BirthdateIn        []string                `json:"birthdate_in,omitempty"`
	BirthdateNotIn     []string                `json:"birthdate_not_in,omitempty"`
	BirthdateLt        *string                 `json:"birthdate_lt,omitempty"`
	BirthdateLte       *string                 `json:"birthdate_lte,omitempty"`
	BirthdateGt        *string                 `json:"birthdate_gt,omitempty"`
	BirthdateGte       *string                 `json:"birthdate_gte,omitempty"`
	Country            *TextWhereInput         `json:"country,omitempty"`
	PhonesEvery        *PhoneChannelWhereInput `json:"phones_every,omitempty"`
	PhonesSome         *PhoneChannelWhereInput `json:"phones_some,omitempty"`
	PhonesNone         *PhoneChannelWhereInput `json:"phones_none,omitempty"`
	EmailsEvery        *EmailChannelWhereInput `json:"emails_every,omitempty"`
	EmailsSome         *EmailChannelWhereInput `json:"emails_some,omitempty"`
	EmailsNone         *EmailChannelWhereInput `json:"emails_none,omitempty"`
	IDentification     *IDDocumentWhereInput   `json:"identification,omitempty"`
	CredentialsEvery   *CredentialWhereInput   `json:"credentials_every,omitempty"`
	CredentialsSome    *CredentialWhereInput   `json:"credentials_some,omitempty"`
	CredentialsNone    *CredentialWhereInput   `json:"credentials_none,omitempty"`
	And                []PersonWhereInput      `json:"AND,omitempty"`
	Or                 []PersonWhereInput      `json:"OR,omitempty"`
	Not                []PersonWhereInput      `json:"NOT,omitempty"`
}

type PhoneChannelUpdateWithWhereUniqueWithoutPersonInput struct {
	Where PhoneChannelWhereUniqueInput             `json:"where"`
	Data  PhoneChannelUpdateWithoutPersonDataInput `json:"data"`
}

type ErrorSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *ErrorWhereInput              `json:"node,omitempty"`
	And                        []ErrorSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ErrorSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ErrorSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PhoneChannelUpdateWithoutPersonDataInput struct {
	IsMain      *bool   `json:"isMain,omitempty"`
	DisplayName *string `json:"displayName,omitempty"`
	Valid       *bool   `json:"valid,omitempty"`
	CountryCode *string `json:"countryCode,omitempty"`
	Number      *string `json:"number,omitempty"`
}

type EmailChannelSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *EmailChannelWhereInput              `json:"node,omitempty"`
	And                        []EmailChannelSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []EmailChannelSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []EmailChannelSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PhoneChannelUpsertWithWhereUniqueWithoutPersonInput struct {
	Where  PhoneChannelWhereUniqueInput             `json:"where"`
	Update PhoneChannelUpdateWithoutPersonDataInput `json:"update"`
	Create PhoneChannelCreateWithoutPersonInput     `json:"create"`
}

type CurrencySubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *CurrencyWhereInput              `json:"node,omitempty"`
	And                        []CurrencySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CurrencySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CurrencySubscriptionWhereInput `json:"NOT,omitempty"`
}

type PhoneChannelScalarWhereInput struct {
	ID                       *string                        `json:"id,omitempty"`
	IDNot                    *string                        `json:"id_not,omitempty"`
	IDIn                     []string                       `json:"id_in,omitempty"`
	IDNotIn                  []string                       `json:"id_not_in,omitempty"`
	IDLt                     *string                        `json:"id_lt,omitempty"`
	IDLte                    *string                        `json:"id_lte,omitempty"`
	IDGt                     *string                        `json:"id_gt,omitempty"`
	IDGte                    *string                        `json:"id_gte,omitempty"`
	IDContains               *string                        `json:"id_contains,omitempty"`
	IDNotContains            *string                        `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                        `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                        `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                        `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                        `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string                        `json:"createdAt,omitempty"`
	CreatedAtNot             *string                        `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                       `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                       `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                        `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                        `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                        `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                        `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                        `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                        `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                       `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                       `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                        `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                        `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                        `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                        `json:"updatedAt_gte,omitempty"`
	IsMain                   *bool                          `json:"isMain,omitempty"`
	IsMainNot                *bool                          `json:"isMain_not,omitempty"`
	DisplayName              *string                        `json:"displayName,omitempty"`
	DisplayNameNot           *string                        `json:"displayName_not,omitempty"`
	DisplayNameIn            []string                       `json:"displayName_in,omitempty"`
	DisplayNameNotIn         []string                       `json:"displayName_not_in,omitempty"`
	DisplayNameLt            *string                        `json:"displayName_lt,omitempty"`
	DisplayNameLte           *string                        `json:"displayName_lte,omitempty"`
	DisplayNameGt            *string                        `json:"displayName_gt,omitempty"`
	DisplayNameGte           *string                        `json:"displayName_gte,omitempty"`
	DisplayNameContains      *string                        `json:"displayName_contains,omitempty"`
	DisplayNameNotContains   *string                        `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith    *string                        `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith *string                        `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith      *string                        `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith   *string                        `json:"displayName_not_ends_with,omitempty"`
	Valid                    *bool                          `json:"valid,omitempty"`
	ValidNot                 *bool                          `json:"valid_not,omitempty"`
	CountryCode              *string                        `json:"countryCode,omitempty"`
	CountryCodeNot           *string                        `json:"countryCode_not,omitempty"`
	CountryCodeIn            []string                       `json:"countryCode_in,omitempty"`
	CountryCodeNotIn         []string                       `json:"countryCode_not_in,omitempty"`
	CountryCodeLt            *string                        `json:"countryCode_lt,omitempty"`
	CountryCodeLte           *string                        `json:"countryCode_lte,omitempty"`
	CountryCodeGt            *string                        `json:"countryCode_gt,omitempty"`
	CountryCodeGte           *string                        `json:"countryCode_gte,omitempty"`
	CountryCodeContains      *string                        `json:"countryCode_contains,omitempty"`
	CountryCodeNotContains   *string                        `json:"countryCode_not_contains,omitempty"`
	CountryCodeStartsWith    *string                        `json:"countryCode_starts_with,omitempty"`
	CountryCodeNotStartsWith *string                        `json:"countryCode_not_starts_with,omitempty"`
	CountryCodeEndsWith      *string                        `json:"countryCode_ends_with,omitempty"`
	CountryCodeNotEndsWith   *string                        `json:"countryCode_not_ends_with,omitempty"`
	Number                   *string                        `json:"number,omitempty"`
	NumberNot                *string                        `json:"number_not,omitempty"`
	NumberIn                 []string                       `json:"number_in,omitempty"`
	NumberNotIn              []string                       `json:"number_not_in,omitempty"`
	NumberLt                 *string                        `json:"number_lt,omitempty"`
	NumberLte                *string                        `json:"number_lte,omitempty"`
	NumberGt                 *string                        `json:"number_gt,omitempty"`
	NumberGte                *string                        `json:"number_gte,omitempty"`
	NumberContains           *string                        `json:"number_contains,omitempty"`
	NumberNotContains        *string                        `json:"number_not_contains,omitempty"`
	NumberStartsWith         *string                        `json:"number_starts_with,omitempty"`
	NumberNotStartsWith      *string                        `json:"number_not_starts_with,omitempty"`
	NumberEndsWith           *string                        `json:"number_ends_with,omitempty"`
	NumberNotEndsWith        *string                        `json:"number_not_ends_with,omitempty"`
	And                      []PhoneChannelScalarWhereInput `json:"AND,omitempty"`
	Or                       []PhoneChannelScalarWhereInput `json:"OR,omitempty"`
	Not                      []PhoneChannelScalarWhereInput `json:"NOT,omitempty"`
}

type CredentialSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *CredentialWhereInput              `json:"node,omitempty"`
	And                        []CredentialSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CredentialSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CredentialSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PhoneChannelUpdateManyWithWhereNestedInput struct {
	Where PhoneChannelScalarWhereInput    `json:"where"`
	Data  PhoneChannelUpdateManyDataInput `json:"data"`
}

type CredentialWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Value *string `json:"value,omitempty"`
}

type PhoneChannelUpdateManyDataInput struct {
	IsMain      *bool   `json:"isMain,omitempty"`
	DisplayName *string `json:"displayName,omitempty"`
	Valid       *bool   `json:"valid,omitempty"`
	CountryCode *string `json:"countryCode,omitempty"`
	Number      *string `json:"number,omitempty"`
}

type ActionTicketSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *ActionTicketWhereInput              `json:"node,omitempty"`
	And                        []ActionTicketSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ActionTicketSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ActionTicketSubscriptionWhereInput `json:"NOT,omitempty"`
}

type EmailChannelUpdateManyWithoutPersonInput struct {
	Create     []EmailChannelCreateWithoutPersonInput                `json:"create,omitempty"`
	Delete     []EmailChannelWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []EmailChannelWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []EmailChannelWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []EmailChannelWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []EmailChannelUpdateWithWhereUniqueWithoutPersonInput `json:"update,omitempty"`
	Upsert     []EmailChannelUpsertWithWhereUniqueWithoutPersonInput `json:"upsert,omitempty"`
	DeleteMany []EmailChannelScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []EmailChannelUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type CreditCardWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type EmailChannelUpdateWithWhereUniqueWithoutPersonInput struct {
	Where EmailChannelWhereUniqueInput             `json:"where"`
	Data  EmailChannelUpdateWithoutPersonDataInput `json:"data"`
}

type TravelerCreateInput struct {
	ID                 *string                                    `json:"id,omitempty"`
	Unregistered       *bool                                      `json:"unregistered,omitempty"`
	RegistrationTicket *ActionTicketCreateOneInput                `json:"registrationTicket,omitempty"`
	Person             PersonCreateOneInput                       `json:"person"`
	Username           *string                                    `json:"username,omitempty"`
	Cards              *CreditCardCreateManyWithoutOwnerInput     `json:"cards,omitempty"`
	Purchases          *PurchaseCreateManyInput                   `json:"purchases,omitempty"`
	Passes             *PassCreateManyInput                       `json:"passes,omitempty"`
	Registry           *EntryTicketCreateManyWithoutTravelerInput `json:"registry,omitempty"`
}

type EmailChannelUpdateWithoutPersonDataInput struct {
	IsMain      *bool                          `json:"isMain,omitempty"`
	DisplayName *string                        `json:"displayName,omitempty"`
	Valid       *bool                          `json:"valid,omitempty"`
	Value       *string                        `json:"value,omitempty"`
	Extras      *EmailChannelUpdateextrasInput `json:"extras,omitempty"`
}

type CurrencyWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type EmailChannelUpdateextrasInput struct {
	Set []string `json:"set,omitempty"`
}

type TextUpdateManyMutationInput struct {
	English *string `json:"english,omitempty"`
	Spanish *string `json:"spanish,omitempty"`
}

type EmailChannelUpsertWithWhereUniqueWithoutPersonInput struct {
	Where  EmailChannelWhereUniqueInput             `json:"where"`
	Update EmailChannelUpdateWithoutPersonDataInput `json:"update"`
	Create EmailChannelCreateWithoutPersonInput     `json:"create"`
}

type StoryUpdateManyMutationInput struct {
	Type           *StoryType            `json:"type,omitempty"`
	Tags           *StoryUpdatetagsInput `json:"tags,omitempty"`
	PodcastLink    *string               `json:"podcastLink,omitempty"`
	AudioStream    *string               `json:"audioStream,omitempty"`
	PrincipalImage *string               `json:"principalImage,omitempty"`
	Likes          *int32                `json:"likes,omitempty"`
	Views          *int32                `json:"views,omitempty"`
}

type EmailChannelScalarWhereInput struct {
	ID                       *string                        `json:"id,omitempty"`
	IDNot                    *string                        `json:"id_not,omitempty"`
	IDIn                     []string                       `json:"id_in,omitempty"`
	IDNotIn                  []string                       `json:"id_not_in,omitempty"`
	IDLt                     *string                        `json:"id_lt,omitempty"`
	IDLte                    *string                        `json:"id_lte,omitempty"`
	IDGt                     *string                        `json:"id_gt,omitempty"`
	IDGte                    *string                        `json:"id_gte,omitempty"`
	IDContains               *string                        `json:"id_contains,omitempty"`
	IDNotContains            *string                        `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                        `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                        `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                        `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                        `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string                        `json:"createdAt,omitempty"`
	CreatedAtNot             *string                        `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                       `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                       `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                        `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                        `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                        `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                        `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                        `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                        `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                       `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                       `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                        `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                        `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                        `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                        `json:"updatedAt_gte,omitempty"`
	IsMain                   *bool                          `json:"isMain,omitempty"`
	IsMainNot                *bool                          `json:"isMain_not,omitempty"`
	DisplayName              *string                        `json:"displayName,omitempty"`
	DisplayNameNot           *string                        `json:"displayName_not,omitempty"`
	DisplayNameIn            []string                       `json:"displayName_in,omitempty"`
	DisplayNameNotIn         []string                       `json:"displayName_not_in,omitempty"`
	DisplayNameLt            *string                        `json:"displayName_lt,omitempty"`
	DisplayNameLte           *string                        `json:"displayName_lte,omitempty"`
	DisplayNameGt            *string                        `json:"displayName_gt,omitempty"`
	DisplayNameGte           *string                        `json:"displayName_gte,omitempty"`
	DisplayNameContains      *string                        `json:"displayName_contains,omitempty"`
	DisplayNameNotContains   *string                        `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith    *string                        `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith *string                        `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith      *string                        `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith   *string                        `json:"displayName_not_ends_with,omitempty"`
	Valid                    *bool                          `json:"valid,omitempty"`
	ValidNot                 *bool                          `json:"valid_not,omitempty"`
	Value                    *string                        `json:"value,omitempty"`
	ValueNot                 *string                        `json:"value_not,omitempty"`
	ValueIn                  []string                       `json:"value_in,omitempty"`
	ValueNotIn               []string                       `json:"value_not_in,omitempty"`
	ValueLt                  *string                        `json:"value_lt,omitempty"`
	ValueLte                 *string                        `json:"value_lte,omitempty"`
	ValueGt                  *string                        `json:"value_gt,omitempty"`
	ValueGte                 *string                        `json:"value_gte,omitempty"`
	ValueContains            *string                        `json:"value_contains,omitempty"`
	ValueNotContains         *string                        `json:"value_not_contains,omitempty"`
	ValueStartsWith          *string                        `json:"value_starts_with,omitempty"`
	ValueNotStartsWith       *string                        `json:"value_not_starts_with,omitempty"`
	ValueEndsWith            *string                        `json:"value_ends_with,omitempty"`
	ValueNotEndsWith         *string                        `json:"value_not_ends_with,omitempty"`
	And                      []EmailChannelScalarWhereInput `json:"AND,omitempty"`
	Or                       []EmailChannelScalarWhereInput `json:"OR,omitempty"`
	Not                      []EmailChannelScalarWhereInput `json:"NOT,omitempty"`
}

type StoryUpdateInput struct {
	Author         *ExpertUpdateOneRequiredWithoutStoriesInput `json:"author,omitempty"`
	Type           *StoryType                                  `json:"type,omitempty"`
	Tags           *StoryUpdatetagsInput                       `json:"tags,omitempty"`
	PodcastLink    *string                                     `json:"podcastLink,omitempty"`
	AudioStream    *string                                     `json:"audioStream,omitempty"`
	PrincipalImage *string                                     `json:"principalImage,omitempty"`
	Title          *TextUpdateOneRequiredInput                 `json:"title,omitempty"`
	Body           *TextUpdateOneRequiredInput                 `json:"body,omitempty"`
	Likes          *int32                                      `json:"likes,omitempty"`
	Views          *int32                                      `json:"views,omitempty"`
	Reviews        *PersonReviewsUpdateManyInput               `json:"reviews,omitempty"`
	LinkedRoute    *RouteUpdateOneWithoutLinkedStoryInput      `json:"linkedRoute,omitempty"`
}

type EmailChannelUpdateManyWithWhereNestedInput struct {
	Where EmailChannelScalarWhereInput    `json:"where"`
	Data  EmailChannelUpdateManyDataInput `json:"data"`
}

type RouteUpdateInput struct {
	Name        *string                                `json:"name,omitempty"`
	Image       *string                                `json:"image,omitempty"`
	Type        *ExperienceType                        `json:"type,omitempty"`
	ExtraTypes  *RouteUpdateextraTypesInput            `json:"extraTypes,omitempty"`
	Creator     *ExpertUpdateOneRequiredInput          `json:"creator,omitempty"`
	Places      *PlaceUpdateManyWithoutRoutesInput     `json:"places,omitempty"`
	LinkedStory *StoryUpdateOneWithoutLinkedRouteInput `json:"linkedStory,omitempty"`
	LikedBy     *PersonUpdateManyInput                 `json:"likedBy,omitempty"`
	Reviews     *PersonReviewsUpdateManyInput          `json:"reviews,omitempty"`
	Popularity  *float64                               `json:"popularity,omitempty"`
	Color       *string                                `json:"color,omitempty"`
}

type EmailChannelUpdateManyDataInput struct {
	IsMain      *bool                          `json:"isMain,omitempty"`
	DisplayName *string                        `json:"displayName,omitempty"`
	Valid       *bool                          `json:"valid,omitempty"`
	Value       *string                        `json:"value,omitempty"`
	Extras      *EmailChannelUpdateextrasInput `json:"extras,omitempty"`
}

type RouteCreateInput struct {
	ID          *string                                `json:"id,omitempty"`
	Name        string                                 `json:"name"`
	Image       string                                 `json:"image"`
	Type        ExperienceType                         `json:"type"`
	ExtraTypes  *RouteCreateextraTypesInput            `json:"extraTypes,omitempty"`
	Creator     ExpertCreateOneInput                   `json:"creator"`
	Places      *PlaceCreateManyWithoutRoutesInput     `json:"places,omitempty"`
	LinkedStory *StoryCreateOneWithoutLinkedRouteInput `json:"linkedStory,omitempty"`
	LikedBy     *PersonCreateManyInput                 `json:"likedBy,omitempty"`
	Reviews     *PersonReviewsCreateManyInput          `json:"reviews,omitempty"`
	Popularity  *float64                               `json:"popularity,omitempty"`
	Color       string                                 `json:"color"`
}

type IDDocumentUpdateOneRequiredWithoutPersonInput struct {
	Create  *IDDocumentCreateWithoutPersonInput     `json:"create,omitempty"`
	Update  *IDDocumentUpdateWithoutPersonDataInput `json:"update,omitempty"`
	Upsert  *IDDocumentUpsertWithoutPersonInput     `json:"upsert,omitempty"`
	Connect *IDDocumentWhereUniqueInput             `json:"connect,omitempty"`
}

type PurchaseUpdateInput struct {
	ChargeToken     *string                              `json:"chargeToken,omitempty"`
	GatewayResponse *string                              `json:"gatewayResponse,omitempty"`
	Products        *ProductEntryUpdateManyInput         `json:"products,omitempty"`
	DiscountId      *string                              `json:"discountID,omitempty"`
	Discount        *int32                               `json:"discount,omitempty"`
	PaymentMethod   *PaymentMethodUpdateOneRequiredInput `json:"paymentMethod,omitempty"`
}

type IDDocumentUpdateWithoutPersonDataInput struct {
	Type      *IDType `json:"type,omitempty"`
	Value     *string `json:"value,omitempty"`
	Validated *bool   `json:"validated,omitempty"`
}

type ProductEntryUpdateManyMutationInput struct {
	ParentId     *string  `json:"parentID,omitempty"`
	Name         *string  `json:"name,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Quantity     *int32   `json:"quantity,omitempty"`
	Cost         *float64 `json:"cost,omitempty"`
	CurrencyCode *string  `json:"currencyCode,omitempty"`
}

type IDDocumentUpsertWithoutPersonInput struct {
	Update IDDocumentUpdateWithoutPersonDataInput `json:"update"`
	Create IDDocumentCreateWithoutPersonInput     `json:"create"`
}

type ProductEntryUpdateInput struct {
	ParentId     *string  `json:"parentID,omitempty"`
	Name         *string  `json:"name,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Quantity     *int32   `json:"quantity,omitempty"`
	Cost         *float64 `json:"cost,omitempty"`
	CurrencyCode *string  `json:"currencyCode,omitempty"`
}

type PersonUpdatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type PlaceUpdateInput struct {
	Name             *string                             `json:"name,omitempty"`
	ShortName        *string                             `json:"shortName,omitempty"`
	Description      *TextUpdateOneRequiredInput         `json:"description,omitempty"`
	ShortDescription *TextUpdateOneInput                 `json:"shortDescription,omitempty"`
	Address          *string                             `json:"address,omitempty"`
	Location         *LocationUpdateOneRequiredInput     `json:"location,omitempty"`
	GoogleLink       *string                             `json:"googleLink,omitempty"`
	Website          *string                             `json:"website,omitempty"`
	Type             *ExperienceType                     `json:"type,omitempty"`
	ExtraTypes       *PlaceUpdateextraTypesInput         `json:"extraTypes,omitempty"`
	Routes           *RouteUpdateManyWithoutPlacesInput  `json:"routes,omitempty"`
	Reviews          *PersonReviewsUpdateManyInput       `json:"reviews,omitempty"`
	Tags             *PlaceUpdatetagsInput               `json:"tags,omitempty"`
	LikedBy          *PersonUpdateManyInput              `json:"likedBy,omitempty"`
	Popularity       *float64                            `json:"popularity,omitempty"`
	Ambassadors      *ExpertUpdateManyInput              `json:"ambassadors,omitempty"`
	ProviderWeb      *string                             `json:"providerWeb,omitempty"`
	ContactPhone     *string                             `json:"contactPhone,omitempty"`
	ContactEmail     *string                             `json:"contactEmail,omitempty"`
	AddressReference *string                             `json:"addressReference,omitempty"`
	OpeningHours     *OpeningHoursUpdateOneRequiredInput `json:"openingHours,omitempty"`
}

type CredentialUpdateManyWithoutOwnerInput struct {
	Create     []CredentialCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []CredentialWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []CredentialWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []CredentialWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []CredentialWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []CredentialUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []CredentialUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []CredentialScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []CredentialUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type ExpertWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Alias *string `json:"alias,omitempty"`
}

type CredentialUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where CredentialWhereUniqueInput            `json:"where"`
	Data  CredentialUpdateWithoutOwnerDataInput `json:"data"`
}

type PersonUpdateWithoutPhonesDataInput struct {
	QmId           *string                                        `json:"qmID,omitempty"`
	Name           *string                                        `json:"name,omitempty"`
	Photo          *string                                        `json:"photo,omitempty"`
	Birthdate      *string                                        `json:"birthdate,omitempty"`
	Country        *TextUpdateOneInput                            `json:"country,omitempty"`
	Emails         *EmailChannelUpdateManyWithoutPersonInput      `json:"emails,omitempty"`
	IDentification *IDDocumentUpdateOneRequiredWithoutPersonInput `json:"identification,omitempty"`
	Tags           *PersonUpdatetagsInput                         `json:"tags,omitempty"`
	Credentials    *CredentialUpdateManyWithoutOwnerInput         `json:"credentials,omitempty"`
}

type CredentialUpdateWithoutOwnerDataInput struct {
	DisplayName    *string         `json:"displayName,omitempty"`
	IsMain         *bool           `json:"isMain,omitempty"`
	Type           *CredentialType `json:"type,omitempty"`
	Validated      *bool           `json:"validated,omitempty"`
	ValidationId   *string         `json:"validationID,omitempty"`
	Value          *string         `json:"value,omitempty"`
	RawPassword    *string         `json:"rawPassword,omitempty"`
	HashedPassword *string         `json:"hashedPassword,omitempty"`
}

type FaqWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type CredentialUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  CredentialWhereUniqueInput            `json:"where"`
	Update CredentialUpdateWithoutOwnerDataInput `json:"update"`
	Create CredentialCreateWithoutOwnerInput     `json:"create"`
}

type PersonCreateWithoutPhonesInput struct {
	ID             *string                                   `json:"id,omitempty"`
	QmId           *string                                   `json:"qmID,omitempty"`
	Name           string                                    `json:"name"`
	Photo          *string                                   `json:"photo,omitempty"`
	Birthdate      *string                                   `json:"birthdate,omitempty"`
	Country        *TextCreateOneInput                       `json:"country,omitempty"`
	Emails         *EmailChannelCreateManyWithoutPersonInput `json:"emails,omitempty"`
	IDentification IDDocumentCreateOneWithoutPersonInput     `json:"identification"`
	Tags           *PersonCreatetagsInput                    `json:"tags,omitempty"`
	Credentials    *CredentialCreateManyWithoutOwnerInput    `json:"credentials,omitempty"`
}

type CredentialScalarWhereInput struct {
	ID                          *string                      `json:"id,omitempty"`
	IDNot                       *string                      `json:"id_not,omitempty"`
	IDIn                        []string                     `json:"id_in,omitempty"`
	IDNotIn                     []string                     `json:"id_not_in,omitempty"`
	IDLt                        *string                      `json:"id_lt,omitempty"`
	IDLte                       *string                      `json:"id_lte,omitempty"`
	IDGt                        *string                      `json:"id_gt,omitempty"`
	IDGte                       *string                      `json:"id_gte,omitempty"`
	IDContains                  *string                      `json:"id_contains,omitempty"`
	IDNotContains               *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                      `json:"id_not_ends_with,omitempty"`
	CreatedAt                   *string                      `json:"createdAt,omitempty"`
	CreatedAtNot                *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string                      `json:"updatedAt_gte,omitempty"`
	DisplayName                 *string                      `json:"displayName,omitempty"`
	DisplayNameNot              *string                      `json:"displayName_not,omitempty"`
	DisplayNameIn               []string                     `json:"displayName_in,omitempty"`
	DisplayNameNotIn            []string                     `json:"displayName_not_in,omitempty"`
	DisplayNameLt               *string                      `json:"displayName_lt,omitempty"`
	DisplayNameLte              *string                      `json:"displayName_lte,omitempty"`
	DisplayNameGt               *string                      `json:"displayName_gt,omitempty"`
	DisplayNameGte              *string                      `json:"displayName_gte,omitempty"`
	DisplayNameContains         *string                      `json:"displayName_contains,omitempty"`
	DisplayNameNotContains      *string                      `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith       *string                      `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith    *string                      `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith         *string                      `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith      *string                      `json:"displayName_not_ends_with,omitempty"`
	IsMain                      *bool                        `json:"isMain,omitempty"`
	IsMainNot                   *bool                        `json:"isMain_not,omitempty"`
	Type                        *CredentialType              `json:"type,omitempty"`
	TypeNot                     *CredentialType              `json:"type_not,omitempty"`
	TypeIn                      []CredentialType             `json:"type_in,omitempty"`
	TypeNotIn                   []CredentialType             `json:"type_not_in,omitempty"`
	Validated                   *bool                        `json:"validated,omitempty"`
	ValidatedNot                *bool                        `json:"validated_not,omitempty"`
	ValidationId                *string                      `json:"validationID,omitempty"`
	ValidationIdNot             *string                      `json:"validationID_not,omitempty"`
	ValidationIdIn              []string                     `json:"validationID_in,omitempty"`
	ValidationIdNotIn           []string                     `json:"validationID_not_in,omitempty"`
	ValidationIdLt              *string                      `json:"validationID_lt,omitempty"`
	ValidationIdLte             *string                      `json:"validationID_lte,omitempty"`
	ValidationIdGt              *string                      `json:"validationID_gt,omitempty"`
	ValidationIdGte             *string                      `json:"validationID_gte,omitempty"`
	ValidationIdContains        *string                      `json:"validationID_contains,omitempty"`
	ValidationIdNotContains     *string                      `json:"validationID_not_contains,omitempty"`
	ValidationIdStartsWith      *string                      `json:"validationID_starts_with,omitempty"`
	ValidationIdNotStartsWith   *string                      `json:"validationID_not_starts_with,omitempty"`
	ValidationIdEndsWith        *string                      `json:"validationID_ends_with,omitempty"`
	ValidationIdNotEndsWith     *string                      `json:"validationID_not_ends_with,omitempty"`
	Value                       *string                      `json:"value,omitempty"`
	ValueNot                    *string                      `json:"value_not,omitempty"`
	ValueIn                     []string                     `json:"value_in,omitempty"`
	ValueNotIn                  []string                     `json:"value_not_in,omitempty"`
	ValueLt                     *string                      `json:"value_lt,omitempty"`
	ValueLte                    *string                      `json:"value_lte,omitempty"`
	ValueGt                     *string                      `json:"value_gt,omitempty"`
	ValueGte                    *string                      `json:"value_gte,omitempty"`
	ValueContains               *string                      `json:"value_contains,omitempty"`
	ValueNotContains            *string                      `json:"value_not_contains,omitempty"`
	ValueStartsWith             *string                      `json:"value_starts_with,omitempty"`
	ValueNotStartsWith          *string                      `json:"value_not_starts_with,omitempty"`
	ValueEndsWith               *string                      `json:"value_ends_with,omitempty"`
	ValueNotEndsWith            *string                      `json:"value_not_ends_with,omitempty"`
	RawPassword                 *string                      `json:"rawPassword,omitempty"`
	RawPasswordNot              *string                      `json:"rawPassword_not,omitempty"`
	RawPasswordIn               []string                     `json:"rawPassword_in,omitempty"`
	RawPasswordNotIn            []string                     `json:"rawPassword_not_in,omitempty"`
	RawPasswordLt               *string                      `json:"rawPassword_lt,omitempty"`
	RawPasswordLte              *string                      `json:"rawPassword_lte,omitempty"`
	RawPasswordGt               *string                      `json:"rawPassword_gt,omitempty"`
	RawPasswordGte              *string                      `json:"rawPassword_gte,omitempty"`
	RawPasswordContains         *string                      `json:"rawPassword_contains,omitempty"`
	RawPasswordNotContains      *string                      `json:"rawPassword_not_contains,omitempty"`
	RawPasswordStartsWith       *string                      `json:"rawPassword_starts_with,omitempty"`
	RawPasswordNotStartsWith    *string                      `json:"rawPassword_not_starts_with,omitempty"`
	RawPasswordEndsWith         *string                      `json:"rawPassword_ends_with,omitempty"`
	RawPasswordNotEndsWith      *string                      `json:"rawPassword_not_ends_with,omitempty"`
	HashedPassword              *string                      `json:"hashedPassword,omitempty"`
	HashedPasswordNot           *string                      `json:"hashedPassword_not,omitempty"`
	HashedPasswordIn            []string                     `json:"hashedPassword_in,omitempty"`
	HashedPasswordNotIn         []string                     `json:"hashedPassword_not_in,omitempty"`
	HashedPasswordLt            *string                      `json:"hashedPassword_lt,omitempty"`
	HashedPasswordLte           *string                      `json:"hashedPassword_lte,omitempty"`
	HashedPasswordGt            *string                      `json:"hashedPassword_gt,omitempty"`
	HashedPasswordGte           *string                      `json:"hashedPassword_gte,omitempty"`
	HashedPasswordContains      *string                      `json:"hashedPassword_contains,omitempty"`
	HashedPasswordNotContains   *string                      `json:"hashedPassword_not_contains,omitempty"`
	HashedPasswordStartsWith    *string                      `json:"hashedPassword_starts_with,omitempty"`
	HashedPasswordNotStartsWith *string                      `json:"hashedPassword_not_starts_with,omitempty"`
	HashedPasswordEndsWith      *string                      `json:"hashedPassword_ends_with,omitempty"`
	HashedPasswordNotEndsWith   *string                      `json:"hashedPassword_not_ends_with,omitempty"`
	And                         []CredentialScalarWhereInput `json:"AND,omitempty"`
	Or                          []CredentialScalarWhereInput `json:"OR,omitempty"`
	Not                         []CredentialScalarWhereInput `json:"NOT,omitempty"`
}

type PhoneChannelCreateInput struct {
	ID          *string                           `json:"id,omitempty"`
	Person      PersonCreateOneWithoutPhonesInput `json:"person"`
	IsMain      *bool                             `json:"isMain,omitempty"`
	DisplayName string                            `json:"displayName"`
	Valid       *bool                             `json:"valid,omitempty"`
	CountryCode string                            `json:"countryCode"`
	Number      *string                           `json:"number,omitempty"`
}

type CredentialUpdateManyWithWhereNestedInput struct {
	Where CredentialScalarWhereInput    `json:"where"`
	Data  CredentialUpdateManyDataInput `json:"data"`
}

type PersonReviewsUpdateManyMutationInput struct {
	ApproveNumber *int32 `json:"approveNumber,omitempty"`
	DeclineNumber *int32 `json:"declineNumber,omitempty"`
}

type CredentialUpdateManyDataInput struct {
	DisplayName    *string         `json:"displayName,omitempty"`
	IsMain         *bool           `json:"isMain,omitempty"`
	Type           *CredentialType `json:"type,omitempty"`
	Validated      *bool           `json:"validated,omitempty"`
	ValidationId   *string         `json:"validationID,omitempty"`
	Value          *string         `json:"value,omitempty"`
	RawPassword    *string         `json:"rawPassword,omitempty"`
	HashedPassword *string         `json:"hashedPassword,omitempty"`
}

type PersonUpdateManyMutationInput struct {
	QmId      *string                `json:"qmID,omitempty"`
	Name      *string                `json:"name,omitempty"`
	Photo     *string                `json:"photo,omitempty"`
	Birthdate *string                `json:"birthdate,omitempty"`
	Tags      *PersonUpdatetagsInput `json:"tags,omitempty"`
}

type PersonUpsertNestedInput struct {
	Update PersonUpdateDataInput `json:"update"`
	Create PersonCreateInput     `json:"create"`
}

type PersonUpdateInput struct {
	QmId           *string                                        `json:"qmID,omitempty"`
	Name           *string                                        `json:"name,omitempty"`
	Photo          *string                                        `json:"photo,omitempty"`
	Birthdate      *string                                        `json:"birthdate,omitempty"`
	Country        *TextUpdateOneInput                            `json:"country,omitempty"`
	Phones         *PhoneChannelUpdateManyWithoutPersonInput      `json:"phones,omitempty"`
	Emails         *EmailChannelUpdateManyWithoutPersonInput      `json:"emails,omitempty"`
	IDentification *IDDocumentUpdateOneRequiredWithoutPersonInput `json:"identification,omitempty"`
	Tags           *PersonUpdatetagsInput                         `json:"tags,omitempty"`
	Credentials    *CredentialUpdateManyWithoutOwnerInput         `json:"credentials,omitempty"`
}

type PersonUpdateOneInput struct {
	Create     *PersonCreateInput       `json:"create,omitempty"`
	Update     *PersonUpdateDataInput   `json:"update,omitempty"`
	Upsert     *PersonUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                    `json:"delete,omitempty"`
	Disconnect *bool                    `json:"disconnect,omitempty"`
	Connect    *PersonWhereUniqueInput  `json:"connect,omitempty"`
}

type PaymentMethodUpdateInput struct {
	Type       *PaymentMethodType `json:"type,omitempty"`
	Value      *string            `json:"value,omitempty"`
	CardNumber *string            `json:"cardNumber,omitempty"`
	Code       *string            `json:"code,omitempty"`
}

type LocationUpdateOneRequiredInput struct {
	Create  *LocationCreateInput       `json:"create,omitempty"`
	Update  *LocationUpdateDataInput   `json:"update,omitempty"`
	Upsert  *LocationUpsertNestedInput `json:"upsert,omitempty"`
	Connect *LocationWhereUniqueInput  `json:"connect,omitempty"`
}

type AttractionWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type LocationUpdateDataInput struct {
	Longitude   *float64            `json:"longitude,omitempty"`
	Latitude    *float64            `json:"latitude,omitempty"`
	Description *TextUpdateOneInput `json:"description,omitempty"`
}

type PassUpsertWithWhereUniqueWithoutTypeInput struct {
	Where  PassWhereUniqueInput           `json:"where"`
	Update PassUpdateWithoutTypeDataInput `json:"update"`
	Create PassCreateWithoutTypeInput     `json:"create"`
}

type LocationUpsertNestedInput struct {
	Update LocationUpdateDataInput `json:"update"`
	Create LocationCreateInput     `json:"create"`
}

type LimaWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type FeatureUpdateManyInput struct {
	Create     []FeatureCreateInput                      `json:"create,omitempty"`
	Update     []FeatureUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []FeatureUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []FeatureWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []FeatureWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []FeatureWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []FeatureWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []FeatureScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []FeatureUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type PassUpdateManyWithoutTypeInput struct {
	Create     []PassCreateWithoutTypeInput                `json:"create,omitempty"`
	Delete     []PassWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []PassWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []PassWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []PassWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []PassUpdateWithWhereUniqueWithoutTypeInput `json:"update,omitempty"`
	Upsert     []PassUpsertWithWhereUniqueWithoutTypeInput `json:"upsert,omitempty"`
	DeleteMany []PassScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []PassUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type FeatureUpdateWithWhereUniqueNestedInput struct {
	Where FeatureWhereUniqueInput `json:"where"`
	Data  FeatureUpdateDataInput  `json:"data"`
}

type LimaWhereInput struct {
	ID                   *string                `json:"id,omitempty"`
	IDNot                *string                `json:"id_not,omitempty"`
	IDIn                 []string               `json:"id_in,omitempty"`
	IDNotIn              []string               `json:"id_not_in,omitempty"`
	IDLt                 *string                `json:"id_lt,omitempty"`
	IDLte                *string                `json:"id_lte,omitempty"`
	IDGt                 *string                `json:"id_gt,omitempty"`
	IDGte                *string                `json:"id_gte,omitempty"`
	IDContains           *string                `json:"id_contains,omitempty"`
	IDNotContains        *string                `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt            *string                `json:"createdAt,omitempty"`
	CreatedAtNot         *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string                `json:"updatedAt_gte,omitempty"`
	Version              *string                `json:"version,omitempty"`
	VersionNot           *string                `json:"version_not,omitempty"`
	VersionIn            []string               `json:"version_in,omitempty"`
	VersionNotIn         []string               `json:"version_not_in,omitempty"`
	VersionLt            *string                `json:"version_lt,omitempty"`
	VersionLte           *string                `json:"version_lte,omitempty"`
	VersionGt            *string                `json:"version_gt,omitempty"`
	VersionGte           *string                `json:"version_gte,omitempty"`
	VersionContains      *string                `json:"version_contains,omitempty"`
	VersionNotContains   *string                `json:"version_not_contains,omitempty"`
	VersionStartsWith    *string                `json:"version_starts_with,omitempty"`
	VersionNotStartsWith *string                `json:"version_not_starts_with,omitempty"`
	VersionEndsWith      *string                `json:"version_ends_with,omitempty"`
	VersionNotEndsWith   *string                `json:"version_not_ends_with,omitempty"`
	Available            *bool                  `json:"available,omitempty"`
	AvailableNot         *bool                  `json:"available_not,omitempty"`
	MainAttractionsEvery *AttractionWhereInput  `json:"mainAttractions_every,omitempty"`
	MainAttractionsSome  *AttractionWhereInput  `json:"mainAttractions_some,omitempty"`
	MainAttractionsNone  *AttractionWhereInput  `json:"mainAttractions_none,omitempty"`
	MainPlacesEvery      *PlaceWhereInput       `json:"mainPlaces_every,omitempty"`
	MainPlacesSome       *PlaceWhereInput       `json:"mainPlaces_some,omitempty"`
	MainPlacesNone       *PlaceWhereInput       `json:"mainPlaces_none,omitempty"`
	MainPartnersEvery    *PartnerWhereInput     `json:"mainPartners_every,omitempty"`
	MainPartnersSome     *PartnerWhereInput     `json:"mainPartners_some,omitempty"`
	MainPartnersNone     *PartnerWhereInput     `json:"mainPartners_none,omitempty"`
	HotStoriesEvery      *StoryWhereInput       `json:"hotStories_every,omitempty"`
	HotStoriesSome       *StoryWhereInput       `json:"hotStories_some,omitempty"`
	HotStoriesNone       *StoryWhereInput       `json:"hotStories_none,omitempty"`
	Contact              *LimaContactWhereInput `json:"contact,omitempty"`
	Faq                  *FaqWhereInput         `json:"faq,omitempty"`
	And                  []LimaWhereInput       `json:"AND,omitempty"`
	Or                   []LimaWhereInput       `json:"OR,omitempty"`
	Not                  []LimaWhereInput       `json:"NOT,omitempty"`
}

type FeatureUpdateDataInput struct {
	Name  *TextUpdateOneInput `json:"name,omitempty"`
	Image *string             `json:"image,omitempty"`
}

type PassCreateWithoutTypeInput struct {
	ID              *string                             `json:"id,omitempty"`
	Owner           PersonCreateOneInput                `json:"owner"`
	PurchaseReceive *PurchaseCreateOneInput             `json:"purchaseReceive,omitempty"`
	ExpireAt        string                              `json:"expireAt"`
	State           *PassState                          `json:"state,omitempty"`
	Tickets         *TicketCreateManyWithoutParentInput `json:"tickets,omitempty"`
}

type FeatureUpsertWithWhereUniqueNestedInput struct {
	Where  FeatureWhereUniqueInput `json:"where"`
	Update FeatureUpdateDataInput  `json:"update"`
	Create FeatureCreateInput      `json:"create"`
}

type PassTypeCreateInput struct {
	ID               *string                         `json:"id,omitempty"`
	Name             TextCreateOneInput              `json:"name"`
	ShortDescription *TextCreateOneInput             `json:"shortDescription,omitempty"`
	Description      *TextCreateOneInput             `json:"description,omitempty"`
	Disclaimer       *TextCreateOneInput             `json:"disclaimer,omitempty"`
	Gallery          *PassTypeCreategalleryInput     `json:"gallery,omitempty"`
	CreatorId        string                          `json:"creatorID"`
	Attractions      *AttractionCreateManyInput      `json:"attractions,omitempty"`
	Cost             CostCreateOneInput              `json:"cost"`
	Duration         int32                           `json:"duration"`
	Children         *PassCreateManyWithoutTypeInput `json:"children,omitempty"`
}

type FeatureScalarWhereInput struct {
	ID                 *string                   `json:"id,omitempty"`
	IDNot              *string                   `json:"id_not,omitempty"`
	IDIn               []string                  `json:"id_in,omitempty"`
	IDNotIn            []string                  `json:"id_not_in,omitempty"`
	IDLt               *string                   `json:"id_lt,omitempty"`
	IDLte              *string                   `json:"id_lte,omitempty"`
	IDGt               *string                   `json:"id_gt,omitempty"`
	IDGte              *string                   `json:"id_gte,omitempty"`
	IDContains         *string                   `json:"id_contains,omitempty"`
	IDNotContains      *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                   `json:"id_not_ends_with,omitempty"`
	Image              *string                   `json:"image,omitempty"`
	ImageNot           *string                   `json:"image_not,omitempty"`
	ImageIn            []string                  `json:"image_in,omitempty"`
	ImageNotIn         []string                  `json:"image_not_in,omitempty"`
	ImageLt            *string                   `json:"image_lt,omitempty"`
	ImageLte           *string                   `json:"image_lte,omitempty"`
	ImageGt            *string                   `json:"image_gt,omitempty"`
	ImageGte           *string                   `json:"image_gte,omitempty"`
	ImageContains      *string                   `json:"image_contains,omitempty"`
	ImageNotContains   *string                   `json:"image_not_contains,omitempty"`
	ImageStartsWith    *string                   `json:"image_starts_with,omitempty"`
	ImageNotStartsWith *string                   `json:"image_not_starts_with,omitempty"`
	ImageEndsWith      *string                   `json:"image_ends_with,omitempty"`
	ImageNotEndsWith   *string                   `json:"image_not_ends_with,omitempty"`
	And                []FeatureScalarWhereInput `json:"AND,omitempty"`
	Or                 []FeatureScalarWhereInput `json:"OR,omitempty"`
	Not                []FeatureScalarWhereInput `json:"NOT,omitempty"`
}

type LimaContactWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type FeatureUpdateManyWithWhereNestedInput struct {
	Where FeatureScalarWhereInput    `json:"where"`
	Data  FeatureUpdateManyDataInput `json:"data"`
}

type PartnerUpdateManyMutationInput struct {
	BrandName    *string `json:"brandName,omitempty"`
	Logo         *string `json:"logo,omitempty"`
	SocialReason *string `json:"socialReason,omitempty"`
	Ruc          *string `json:"ruc,omitempty"`
	Address      *string `json:"address,omitempty"`
}

type FeatureUpdateManyDataInput struct {
	Image *string `json:"image,omitempty"`
}

type OpeningHoursUpdateManyMutationInput struct {
	Mon *string `json:"mon,omitempty"`
	Tue *string `json:"tue,omitempty"`
	Wed *string `json:"wed,omitempty"`
	Thu *string `json:"thu,omitempty"`
	Fri *string `json:"fri,omitempty"`
	Sat *string `json:"sat,omitempty"`
	Sun *string `json:"sun,omitempty"`
}

type OpeningHoursUpdateOneInput struct {
	Create     *OpeningHoursCreateInput       `json:"create,omitempty"`
	Update     *OpeningHoursUpdateDataInput   `json:"update,omitempty"`
	Upsert     *OpeningHoursUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                          `json:"delete,omitempty"`
	Disconnect *bool                          `json:"disconnect,omitempty"`
	Connect    *OpeningHoursWhereUniqueInput  `json:"connect,omitempty"`
}

type OpeningHoursUpdateInput struct {
	Mon         *string             `json:"mon,omitempty"`
	Tue         *string             `json:"tue,omitempty"`
	Wed         *string             `json:"wed,omitempty"`
	Thu         *string             `json:"thu,omitempty"`
	Fri         *string             `json:"fri,omitempty"`
	Sat         *string             `json:"sat,omitempty"`
	Sun         *string             `json:"sun,omitempty"`
	Description *TextUpdateOneInput `json:"description,omitempty"`
}

type OpeningHoursUpdateDataInput struct {
	Mon         *string             `json:"mon,omitempty"`
	Tue         *string             `json:"tue,omitempty"`
	Wed         *string             `json:"wed,omitempty"`
	Thu         *string             `json:"thu,omitempty"`
	Fri         *string             `json:"fri,omitempty"`
	Sat         *string             `json:"sat,omitempty"`
	Sun         *string             `json:"sun,omitempty"`
	Description *TextUpdateOneInput `json:"description,omitempty"`
}

type LocationUpdateInput struct {
	Longitude   *float64            `json:"longitude,omitempty"`
	Latitude    *float64            `json:"latitude,omitempty"`
	Description *TextUpdateOneInput `json:"description,omitempty"`
}

type OpeningHoursUpsertNestedInput struct {
	Update OpeningHoursUpdateDataInput `json:"update"`
	Create OpeningHoursCreateInput     `json:"create"`
}

type OpeningHoursWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type EntryTicketUpdateManyWithoutPartnerInput struct {
	Create     []EntryTicketCreateWithoutPartnerInput                `json:"create,omitempty"`
	Delete     []EntryTicketWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []EntryTicketWhereUniqueInput                         `json:"connect,omitempty"`
	Set        []EntryTicketWhereUniqueInput                         `json:"set,omitempty"`
	Disconnect []EntryTicketWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []EntryTicketUpdateWithWhereUniqueWithoutPartnerInput `json:"update,omitempty"`
	Upsert     []EntryTicketUpsertWithWhereUniqueWithoutPartnerInput `json:"upsert,omitempty"`
	DeleteMany []EntryTicketScalarWhereInput                         `json:"deleteMany,omitempty"`
	UpdateMany []EntryTicketUpdateManyWithWhereNestedInput           `json:"updateMany,omitempty"`
}

type LimaUpdateManyMutationInput struct {
	Version   *string `json:"version,omitempty"`
	Available *bool   `json:"available,omitempty"`
}

type EntryTicketUpdateWithWhereUniqueWithoutPartnerInput struct {
	Where EntryTicketWhereUniqueInput              `json:"where"`
	Data  EntryTicketUpdateWithoutPartnerDataInput `json:"data"`
}

type FaqUpdateDataInput struct {
	Attraction *AttractionUpdateOneRequiredWithoutFaqsInput `json:"attraction,omitempty"`
	Entries    *FaqEntryUpdateManyWithoutFaqInput           `json:"entries,omitempty"`
}

type EntryTicketUpdateWithoutPartnerDataInput struct {
	At       *string                                        `json:"at,omitempty"`
	Ticket   *TicketUpdateOneRequiredInput                  `json:"ticket,omitempty"`
	Traveler *TravelerUpdateOneRequiredWithoutRegistryInput `json:"traveler,omitempty"`
}

type FaqUpdateOneRequiredInput struct {
	Create  *FaqCreateInput       `json:"create,omitempty"`
	Update  *FaqUpdateDataInput   `json:"update,omitempty"`
	Upsert  *FaqUpsertNestedInput `json:"upsert,omitempty"`
	Connect *FaqWhereUniqueInput  `json:"connect,omitempty"`
}

type TicketUpdateOneRequiredInput struct {
	Create  *TicketCreateInput       `json:"create,omitempty"`
	Update  *TicketUpdateDataInput   `json:"update,omitempty"`
	Upsert  *TicketUpsertNestedInput `json:"upsert,omitempty"`
	Connect *TicketWhereUniqueInput  `json:"connect,omitempty"`
}

type LimaContactUpdateDataInput struct {
	Message     *TextUpdateOneRequiredInput `json:"message,omitempty"`
	Email       *string                     `json:"email,omitempty"`
	PhoneNumber *string                     `json:"phoneNumber,omitempty"`
}

type TicketUpdateDataInput struct {
	Parent        *PassUpdateOneRequiredWithoutTicketsInput `json:"parent,omitempty"`
	Attraction    *AttractionUpdateOneRequiredInput         `json:"attraction,omitempty"`
	Description   *TextUpdateOneInput                       `json:"description,omitempty"`
	AvailableTime *TextUpdateOneInput                       `json:"availableTime,omitempty"`
	MaxUses       *int32                                    `json:"maxUses,omitempty"`
	Visited       *bool                                     `json:"visited,omitempty"`
	Finished      *bool                                     `json:"finished,omitempty"`
	State         *TicketState                              `json:"state,omitempty"`
}

type LimaContactUpdateOneRequiredInput struct {
	Create  *LimaContactCreateInput       `json:"create,omitempty"`
	Update  *LimaContactUpdateDataInput   `json:"update,omitempty"`
	Upsert  *LimaContactUpsertNestedInput `json:"upsert,omitempty"`
	Connect *LimaContactWhereUniqueInput  `json:"connect,omitempty"`
}

type PassUpdateOneRequiredWithoutTicketsInput struct {
	Create  *PassCreateWithoutTicketsInput     `json:"create,omitempty"`
	Update  *PassUpdateWithoutTicketsDataInput `json:"update,omitempty"`
	Upsert  *PassUpsertWithoutTicketsInput     `json:"upsert,omitempty"`
	Connect *PassWhereUniqueInput              `json:"connect,omitempty"`
}

type StoryUpdateDataInput struct {
	Author         *ExpertUpdateOneRequiredWithoutStoriesInput `json:"author,omitempty"`
	Type           *StoryType                                  `json:"type,omitempty"`
	Tags           *StoryUpdatetagsInput                       `json:"tags,omitempty"`
	PodcastLink    *string                                     `json:"podcastLink,omitempty"`
	AudioStream    *string                                     `json:"audioStream,omitempty"`
	PrincipalImage *string                                     `json:"principalImage,omitempty"`
	Title          *TextUpdateOneRequiredInput                 `json:"title,omitempty"`
	Body           *TextUpdateOneRequiredInput                 `json:"body,omitempty"`
	Likes          *int32                                      `json:"likes,omitempty"`
	Views          *int32                                      `json:"views,omitempty"`
	Reviews        *PersonReviewsUpdateManyInput               `json:"reviews,omitempty"`
	LinkedRoute    *RouteUpdateOneWithoutLinkedStoryInput      `json:"linkedRoute,omitempty"`
}

type PassUpdateWithoutTicketsDataInput struct {
	Type            *PassTypeUpdateOneRequiredWithoutChildrenInput `json:"type,omitempty"`
	Owner           *PersonUpdateOneRequiredInput                  `json:"owner,omitempty"`
	PurchaseReceive *PurchaseUpdateOneInput                        `json:"purchaseReceive,omitempty"`
	ExpireAt        *string                                        `json:"expireAt,omitempty"`
	State           *PassState                                     `json:"state,omitempty"`
}

type ActionTicketWhereInput struct {
	ID                 *string                  `json:"id,omitempty"`
	IDNot              *string                  `json:"id_not,omitempty"`
	IDIn               []string                 `json:"id_in,omitempty"`
	IDNotIn            []string                 `json:"id_not_in,omitempty"`
	IDLt               *string                  `json:"id_lt,omitempty"`
	IDLte              *string                  `json:"id_lte,omitempty"`
	IDGt               *string                  `json:"id_gt,omitempty"`
	IDGte              *string                  `json:"id_gte,omitempty"`
	IDContains         *string                  `json:"id_contains,omitempty"`
	IDNotContains      *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                  `json:"createdAt,omitempty"`
	CreatedAtNot       *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                  `json:"updatedAt_gte,omitempty"`
	Type               *ActionTicketType        `json:"type,omitempty"`
	TypeNot            *ActionTicketType        `json:"type_not,omitempty"`
	TypeIn             []ActionTicketType       `json:"type_in,omitempty"`
	TypeNotIn          []ActionTicketType       `json:"type_not_in,omitempty"`
	Token              *string                  `json:"token,omitempty"`
	TokenNot           *string                  `json:"token_not,omitempty"`
	TokenIn            []string                 `json:"token_in,omitempty"`
	TokenNotIn         []string                 `json:"token_not_in,omitempty"`
	TokenLt            *string                  `json:"token_lt,omitempty"`
	TokenLte           *string                  `json:"token_lte,omitempty"`
	TokenGt            *string                  `json:"token_gt,omitempty"`
	TokenGte           *string                  `json:"token_gte,omitempty"`
	TokenContains      *string                  `json:"token_contains,omitempty"`
	TokenNotContains   *string                  `json:"token_not_contains,omitempty"`
	TokenStartsWith    *string                  `json:"token_starts_with,omitempty"`
	TokenNotStartsWith *string                  `json:"token_not_starts_with,omitempty"`
	TokenEndsWith      *string                  `json:"token_ends_with,omitempty"`
	TokenNotEndsWith   *string                  `json:"token_not_ends_with,omitempty"`
	Available          *bool                    `json:"available,omitempty"`
	AvailableNot       *bool                    `json:"available_not,omitempty"`
	Used               *bool                    `json:"used,omitempty"`
	UsedNot            *bool                    `json:"used_not,omitempty"`
	And                []ActionTicketWhereInput `json:"AND,omitempty"`
	Or                 []ActionTicketWhereInput `json:"OR,omitempty"`
	Not                []ActionTicketWhereInput `json:"NOT,omitempty"`
}

type PassTypeUpdateOneRequiredWithoutChildrenInput struct {
	Create  *PassTypeCreateWithoutChildrenInput     `json:"create,omitempty"`
	Update  *PassTypeUpdateWithoutChildrenDataInput `json:"update,omitempty"`
	Upsert  *PassTypeUpsertWithoutChildrenInput     `json:"upsert,omitempty"`
	Connect *PassTypeWhereUniqueInput               `json:"connect,omitempty"`
}

type StoryUpdateManyInput struct {
	Create     []StoryCreateInput                      `json:"create,omitempty"`
	Update     []StoryUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []StoryUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []StoryWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []StoryWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []StoryWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []StoryWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []StoryScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []StoryUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type PassTypeUpdateWithoutChildrenDataInput struct {
	Name             *TextUpdateOneRequiredInput `json:"name,omitempty"`
	ShortDescription *TextUpdateOneInput         `json:"shortDescription,omitempty"`
	Description      *TextUpdateOneInput         `json:"description,omitempty"`
	Disclaimer       *TextUpdateOneInput         `json:"disclaimer,omitempty"`
	Gallery          *PassTypeUpdategalleryInput `json:"gallery,omitempty"`
	CreatorId        *string                     `json:"creatorID,omitempty"`
	Attractions      *AttractionUpdateManyInput  `json:"attractions,omitempty"`
	Cost             *CostUpdateOneRequiredInput `json:"cost,omitempty"`
	Duration         *int32                      `json:"duration,omitempty"`
}

type PaymentMethodWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type TextUpdateOneRequiredInput struct {
	Create  *TextCreateInput       `json:"create,omitempty"`
	Update  *TextUpdateDataInput   `json:"update,omitempty"`
	Upsert  *TextUpsertNestedInput `json:"upsert,omitempty"`
	Connect *TextWhereUniqueInput  `json:"connect,omitempty"`
}

type PartnerScalarWhereInput struct {
	ID                        *string                   `json:"id,omitempty"`
	IDNot                     *string                   `json:"id_not,omitempty"`
	IDIn                      []string                  `json:"id_in,omitempty"`
	IDNotIn                   []string                  `json:"id_not_in,omitempty"`
	IDLt                      *string                   `json:"id_lt,omitempty"`
	IDLte                     *string                   `json:"id_lte,omitempty"`
	IDGt                      *string                   `json:"id_gt,omitempty"`
	IDGte                     *string                   `json:"id_gte,omitempty"`
	IDContains                *string                   `json:"id_contains,omitempty"`
	IDNotContains             *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith              *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string                   `json:"id_not_ends_with,omitempty"`
	CreatedAt                 *string                   `json:"createdAt,omitempty"`
	CreatedAtNot              *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt                 *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot              *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn               []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn            []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt               *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte              *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt               *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte              *string                   `json:"updatedAt_gte,omitempty"`
	BrandName                 *string                   `json:"brandName,omitempty"`
	BrandNameNot              *string                   `json:"brandName_not,omitempty"`
	BrandNameIn               []string                  `json:"brandName_in,omitempty"`
	BrandNameNotIn            []string                  `json:"brandName_not_in,omitempty"`
	BrandNameLt               *string                   `json:"brandName_lt,omitempty"`
	BrandNameLte              *string                   `json:"brandName_lte,omitempty"`
	BrandNameGt               *string                   `json:"brandName_gt,omitempty"`
	BrandNameGte              *string                   `json:"brandName_gte,omitempty"`
	BrandNameContains         *string                   `json:"brandName_contains,omitempty"`
	BrandNameNotContains      *string                   `json:"brandName_not_contains,omitempty"`
	BrandNameStartsWith       *string                   `json:"brandName_starts_with,omitempty"`
	BrandNameNotStartsWith    *string                   `json:"brandName_not_starts_with,omitempty"`
	BrandNameEndsWith         *string                   `json:"brandName_ends_with,omitempty"`
	BrandNameNotEndsWith      *string                   `json:"brandName_not_ends_with,omitempty"`
	Logo                      *string                   `json:"logo,omitempty"`
	LogoNot                   *string                   `json:"logo_not,omitempty"`
	LogoIn                    []string                  `json:"logo_in,omitempty"`
	LogoNotIn                 []string                  `json:"logo_not_in,omitempty"`
	LogoLt                    *string                   `json:"logo_lt,omitempty"`
	LogoLte                   *string                   `json:"logo_lte,omitempty"`
	LogoGt                    *string                   `json:"logo_gt,omitempty"`
	LogoGte                   *string                   `json:"logo_gte,omitempty"`
	LogoContains              *string                   `json:"logo_contains,omitempty"`
	LogoNotContains           *string                   `json:"logo_not_contains,omitempty"`
	LogoStartsWith            *string                   `json:"logo_starts_with,omitempty"`
	LogoNotStartsWith         *string                   `json:"logo_not_starts_with,omitempty"`
	LogoEndsWith              *string                   `json:"logo_ends_with,omitempty"`
	LogoNotEndsWith           *string                   `json:"logo_not_ends_with,omitempty"`
	SocialReason              *string                   `json:"socialReason,omitempty"`
	SocialReasonNot           *string                   `json:"socialReason_not,omitempty"`
	SocialReasonIn            []string                  `json:"socialReason_in,omitempty"`
	SocialReasonNotIn         []string                  `json:"socialReason_not_in,omitempty"`
	SocialReasonLt            *string                   `json:"socialReason_lt,omitempty"`
	SocialReasonLte           *string                   `json:"socialReason_lte,omitempty"`
	SocialReasonGt            *string                   `json:"socialReason_gt,omitempty"`
	SocialReasonGte           *string                   `json:"socialReason_gte,omitempty"`
	SocialReasonContains      *string                   `json:"socialReason_contains,omitempty"`
	SocialReasonNotContains   *string                   `json:"socialReason_not_contains,omitempty"`
	SocialReasonStartsWith    *string                   `json:"socialReason_starts_with,omitempty"`
	SocialReasonNotStartsWith *string                   `json:"socialReason_not_starts_with,omitempty"`
	SocialReasonEndsWith      *string                   `json:"socialReason_ends_with,omitempty"`
	SocialReasonNotEndsWith   *string                   `json:"socialReason_not_ends_with,omitempty"`
	Ruc                       *string                   `json:"ruc,omitempty"`
	RucNot                    *string                   `json:"ruc_not,omitempty"`
	RucIn                     []string                  `json:"ruc_in,omitempty"`
	RucNotIn                  []string                  `json:"ruc_not_in,omitempty"`
	RucLt                     *string                   `json:"ruc_lt,omitempty"`
	RucLte                    *string                   `json:"ruc_lte,omitempty"`
	RucGt                     *string                   `json:"ruc_gt,omitempty"`
	RucGte                    *string                   `json:"ruc_gte,omitempty"`
	RucContains               *string                   `json:"ruc_contains,omitempty"`
	RucNotContains            *string                   `json:"ruc_not_contains,omitempty"`
	RucStartsWith             *string                   `json:"ruc_starts_with,omitempty"`
	RucNotStartsWith          *string                   `json:"ruc_not_starts_with,omitempty"`
	RucEndsWith               *string                   `json:"ruc_ends_with,omitempty"`
	RucNotEndsWith            *string                   `json:"ruc_not_ends_with,omitempty"`
	Address                   *string                   `json:"address,omitempty"`
	AddressNot                *string                   `json:"address_not,omitempty"`
	AddressIn                 []string                  `json:"address_in,omitempty"`
	AddressNotIn              []string                  `json:"address_not_in,omitempty"`
	AddressLt                 *string                   `json:"address_lt,omitempty"`
	AddressLte                *string                   `json:"address_lte,omitempty"`
	AddressGt                 *string                   `json:"address_gt,omitempty"`
	AddressGte                *string                   `json:"address_gte,omitempty"`
	AddressContains           *string                   `json:"address_contains,omitempty"`
	AddressNotContains        *string                   `json:"address_not_contains,omitempty"`
	AddressStartsWith         *string                   `json:"address_starts_with,omitempty"`
	AddressNotStartsWith      *string                   `json:"address_not_starts_with,omitempty"`
	AddressEndsWith           *string                   `json:"address_ends_with,omitempty"`
	AddressNotEndsWith        *string                   `json:"address_not_ends_with,omitempty"`
	And                       []PartnerScalarWhereInput `json:"AND,omitempty"`
	Or                        []PartnerScalarWhereInput `json:"OR,omitempty"`
	Not                       []PartnerScalarWhereInput `json:"NOT,omitempty"`
}

type PassTypeUpdategalleryInput struct {
	Set []string `json:"set,omitempty"`
}

type PartnerUpdateDataInput struct {
	Attender     *PersonUpdateOneRequiredInput             `json:"attender,omitempty"`
	Owner        *PersonUpdateOneInput                     `json:"owner,omitempty"`
	Attractions  *AttractionUpdateManyWithoutOwnerInput    `json:"attractions,omitempty"`
	BrandName    *string                                   `json:"brandName,omitempty"`
	Logo         *string                                   `json:"logo,omitempty"`
	SocialReason *string                                   `json:"socialReason,omitempty"`
	Ruc          *string                                   `json:"ruc,omitempty"`
	Address      *string                                   `json:"address,omitempty"`
	Location     *LocationUpdateOneRequiredInput           `json:"location,omitempty"`
	Features     *FeatureUpdateManyInput                   `json:"features,omitempty"`
	ServiceHours *OpeningHoursUpdateOneInput               `json:"serviceHours,omitempty"`
	Registry     *EntryTicketUpdateManyWithoutPartnerInput `json:"registry,omitempty"`
}

type AttractionUpdateManyInput struct {
	Create     []AttractionCreateInput                      `json:"create,omitempty"`
	Update     []AttractionUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []AttractionUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []AttractionWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []AttractionWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []AttractionWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []AttractionWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []AttractionScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []AttractionUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type PartnerUpdateWithWhereUniqueNestedInput struct {
	Where PartnerWhereUniqueInput `json:"where"`
	Data  PartnerUpdateDataInput  `json:"data"`
}

type AttractionCreateOneWithoutFaqsInput struct {
	Create  *AttractionCreateWithoutFaqsInput `json:"create,omitempty"`
	Connect *AttractionWhereUniqueInput       `json:"connect,omitempty"`
}

type PlaceUpsertWithWhereUniqueNestedInput struct {
	Where  PlaceWhereUniqueInput `json:"where"`
	Update PlaceUpdateDataInput  `json:"update"`
	Create PlaceCreateInput      `json:"create"`
}

type AttractionUpdateDataInput struct {
	Owner            *PartnerUpdateOneRequiredWithoutAttractionsInput `json:"owner,omitempty"`
	Name             *TextUpdateOneRequiredInput                      `json:"name,omitempty"`
	Description      *TextUpdateOneInput                              `json:"description,omitempty"`
	ShortDescription *TextUpdateOneInput                              `json:"shortDescription,omitempty"`
	Faqs             *FaqUpdateOneRequiredWithoutAttractionInput      `json:"faqs,omitempty"`
	PrincipalImage   *string                                          `json:"principalImage,omitempty"`
	CoverImage       *string                                          `json:"coverImage,omitempty"`
	LandscapeImage   *string                                          `json:"landscapeImage,omitempty"`
	Gallery          *AttractionUpdategalleryInput                    `json:"gallery,omitempty"`
	Type             *AttractionUpdatetypeInput                       `json:"type,omitempty"`
	Place            *PlaceUpdateOneRequiredInput                     `json:"place,omitempty"`
}

type PlaceUpdateWithWhereUniqueNestedInput struct {
	Where PlaceWhereUniqueInput `json:"where"`
	Data  PlaceUpdateDataInput  `json:"data"`
}

type FaqUpdateOneRequiredWithoutAttractionInput struct {
	Create  *FaqCreateWithoutAttractionInput     `json:"create,omitempty"`
	Update  *FaqUpdateWithoutAttractionDataInput `json:"update,omitempty"`
	Upsert  *FaqUpsertWithoutAttractionInput     `json:"upsert,omitempty"`
	Connect *FaqWhereUniqueInput                 `json:"connect,omitempty"`
}

type LimaUpdateInput struct {
	Version         *string                            `json:"version,omitempty"`
	Available       *bool                              `json:"available,omitempty"`
	MainAttractions *AttractionUpdateManyInput         `json:"mainAttractions,omitempty"`
	MainPlaces      *PlaceUpdateManyInput              `json:"mainPlaces,omitempty"`
	MainPartners    *PartnerUpdateManyInput            `json:"mainPartners,omitempty"`
	HotStories      *StoryUpdateManyInput              `json:"hotStories,omitempty"`
	Contact         *LimaContactUpdateOneRequiredInput `json:"contact,omitempty"`
	Faq             *FaqUpdateOneRequiredInput         `json:"faq,omitempty"`
}

type FaqUpdateWithoutAttractionDataInput struct {
	Entries *FaqEntryUpdateManyWithoutFaqInput `json:"entries,omitempty"`
}

type FaqCreateOneInput struct {
	Create  *FaqCreateInput      `json:"create,omitempty"`
	Connect *FaqWhereUniqueInput `json:"connect,omitempty"`
}

type FaqEntryUpdateManyWithoutFaqInput struct {
	Create     []FaqEntryCreateWithoutFaqInput                `json:"create,omitempty"`
	Delete     []FaqEntryWhereUniqueInput                     `json:"delete,omitempty"`
	Connect    []FaqEntryWhereUniqueInput                     `json:"connect,omitempty"`
	Set        []FaqEntryWhereUniqueInput                     `json:"set,omitempty"`
	Disconnect []FaqEntryWhereUniqueInput                     `json:"disconnect,omitempty"`
	Update     []FaqEntryUpdateWithWhereUniqueWithoutFaqInput `json:"update,omitempty"`
	Upsert     []FaqEntryUpsertWithWhereUniqueWithoutFaqInput `json:"upsert,omitempty"`
	DeleteMany []FaqEntryScalarWhereInput                     `json:"deleteMany,omitempty"`
}

type LimaContactCreateOneInput struct {
	Create  *LimaContactCreateInput      `json:"create,omitempty"`
	Connect *LimaContactWhereUniqueInput `json:"connect,omitempty"`
}

type FaqEntryUpdateWithWhereUniqueWithoutFaqInput struct {
	Where FaqEntryWhereUniqueInput          `json:"where"`
	Data  FaqEntryUpdateWithoutFaqDataInput `json:"data"`
}

type StoryCreateInput struct {
	ID             *string                                `json:"id,omitempty"`
	Author         ExpertCreateOneWithoutStoriesInput     `json:"author"`
	Type           StoryType                              `json:"type"`
	Tags           *StoryCreatetagsInput                  `json:"tags,omitempty"`
	PodcastLink    *string                                `json:"podcastLink,omitempty"`
	AudioStream    *string                                `json:"audioStream,omitempty"`
	PrincipalImage string                                 `json:"principalImage"`
	Title          TextCreateOneInput                     `json:"title"`
	Body           TextCreateOneInput                     `json:"body"`
	Likes          int32                                  `json:"likes"`
	Views          int32                                  `json:"views"`
	Reviews        *PersonReviewsCreateManyInput          `json:"reviews,omitempty"`
	LinkedRoute    *RouteCreateOneWithoutLinkedStoryInput `json:"linkedRoute,omitempty"`
}

type FaqEntryUpdateWithoutFaqDataInput struct {
	Question *TextUpdateOneRequiredInput `json:"question,omitempty"`
	Answer   *TextUpdateOneRequiredInput `json:"answer,omitempty"`
}

type PartnerCreateInput struct {
	ID           *string                                   `json:"id,omitempty"`
	Attender     PersonCreateOneInput                      `json:"attender"`
	Owner        *PersonCreateOneInput                     `json:"owner,omitempty"`
	Attractions  *AttractionCreateManyWithoutOwnerInput    `json:"attractions,omitempty"`
	BrandName    string                                    `json:"brandName"`
	Logo         string                                    `json:"logo"`
	SocialReason string                                    `json:"socialReason"`
	Ruc          string                                    `json:"ruc"`
	Address      string                                    `json:"address"`
	Location     LocationCreateOneInput                    `json:"location"`
	Features     *FeatureCreateManyInput                   `json:"features,omitempty"`
	ServiceHours *OpeningHoursCreateOneInput               `json:"serviceHours,omitempty"`
	Registry     *EntryTicketCreateManyWithoutPartnerInput `json:"registry,omitempty"`
}

type FaqEntryUpsertWithWhereUniqueWithoutFaqInput struct {
	Where  FaqEntryWhereUniqueInput          `json:"where"`
	Update FaqEntryUpdateWithoutFaqDataInput `json:"update"`
	Create FaqEntryCreateWithoutFaqInput     `json:"create"`
}

type PartnerCreateManyInput struct {
	Create  []PartnerCreateInput      `json:"create,omitempty"`
	Connect []PartnerWhereUniqueInput `json:"connect,omitempty"`
}

type FaqEntryScalarWhereInput struct {
	ID              *string                    `json:"id,omitempty"`
	IDNot           *string                    `json:"id_not,omitempty"`
	IDIn            []string                   `json:"id_in,omitempty"`
	IDNotIn         []string                   `json:"id_not_in,omitempty"`
	IDLt            *string                    `json:"id_lt,omitempty"`
	IDLte           *string                    `json:"id_lte,omitempty"`
	IDGt            *string                    `json:"id_gt,omitempty"`
	IDGte           *string                    `json:"id_gte,omitempty"`
	IDContains      *string                    `json:"id_contains,omitempty"`
	IDNotContains   *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                    `json:"id_not_ends_with,omitempty"`
	And             []FaqEntryScalarWhereInput `json:"AND,omitempty"`
	Or              []FaqEntryScalarWhereInput `json:"OR,omitempty"`
	Not             []FaqEntryScalarWhereInput `json:"NOT,omitempty"`
}

type LimaCreateInput struct {
	ID              *string                    `json:"id,omitempty"`
	Version         string                     `json:"version"`
	Available       bool                       `json:"available"`
	MainAttractions *AttractionCreateManyInput `json:"mainAttractions,omitempty"`
	MainPlaces      *PlaceCreateManyInput      `json:"mainPlaces,omitempty"`
	MainPartners    *PartnerCreateManyInput    `json:"mainPartners,omitempty"`
	HotStories      *StoryCreateManyInput      `json:"hotStories,omitempty"`
	Contact         LimaContactCreateOneInput  `json:"contact"`
	Faq             FaqCreateOneInput          `json:"faq"`
}

type FaqUpsertWithoutAttractionInput struct {
	Update FaqUpdateWithoutAttractionDataInput `json:"update"`
	Create FaqCreateWithoutAttractionInput     `json:"create"`
}

type IDDocumentUpdateManyMutationInput struct {
	Type      *IDType `json:"type,omitempty"`
	Value     *string `json:"value,omitempty"`
	Validated *bool   `json:"validated,omitempty"`
}

type AttractionUpdategalleryInput struct {
	Set []string `json:"set,omitempty"`
}

type PersonUpdateWithoutIdentificationDataInput struct {
	QmId        *string                                   `json:"qmID,omitempty"`
	Name        *string                                   `json:"name,omitempty"`
	Photo       *string                                   `json:"photo,omitempty"`
	Birthdate   *string                                   `json:"birthdate,omitempty"`
	Country     *TextUpdateOneInput                       `json:"country,omitempty"`
	Phones      *PhoneChannelUpdateManyWithoutPersonInput `json:"phones,omitempty"`
	Emails      *EmailChannelUpdateManyWithoutPersonInput `json:"emails,omitempty"`
	Tags        *PersonUpdatetagsInput                    `json:"tags,omitempty"`
	Credentials *CredentialUpdateManyWithoutOwnerInput    `json:"credentials,omitempty"`
}

type AttractionUpdatetypeInput struct {
	Set []ExperienceType `json:"set,omitempty"`
}

type PersonUpdateOneRequiredWithoutIdentificationInput struct {
	Create  *PersonCreateWithoutIdentificationInput     `json:"create,omitempty"`
	Update  *PersonUpdateWithoutIdentificationDataInput `json:"update,omitempty"`
	Upsert  *PersonUpsertWithoutIdentificationInput     `json:"upsert,omitempty"`
	Connect *PersonWhereUniqueInput                     `json:"connect,omitempty"`
}

type PlaceUpdateOneRequiredInput struct {
	Create  *PlaceCreateInput       `json:"create,omitempty"`
	Update  *PlaceUpdateDataInput   `json:"update,omitempty"`
	Upsert  *PlaceUpsertNestedInput `json:"upsert,omitempty"`
	Connect *PlaceWhereUniqueInput  `json:"connect,omitempty"`
}

type PersonCreateWithoutIdentificationInput struct {
	ID          *string                                   `json:"id,omitempty"`
	QmId        *string                                   `json:"qmID,omitempty"`
	Name        string                                    `json:"name"`
	Photo       *string                                   `json:"photo,omitempty"`
	Birthdate   *string                                   `json:"birthdate,omitempty"`
	Country     *TextCreateOneInput                       `json:"country,omitempty"`
	Phones      *PhoneChannelCreateManyWithoutPersonInput `json:"phones,omitempty"`
	Emails      *EmailChannelCreateManyWithoutPersonInput `json:"emails,omitempty"`
	Tags        *PersonCreatetagsInput                    `json:"tags,omitempty"`
	Credentials *CredentialCreateManyWithoutOwnerInput    `json:"credentials,omitempty"`
}

type PlaceUpdateDataInput struct {
	Name             *string                             `json:"name,omitempty"`
	ShortName        *string                             `json:"shortName,omitempty"`
	Description      *TextUpdateOneRequiredInput         `json:"description,omitempty"`
	ShortDescription *TextUpdateOneInput                 `json:"shortDescription,omitempty"`
	Address          *string                             `json:"address,omitempty"`
	Location         *LocationUpdateOneRequiredInput     `json:"location,omitempty"`
	GoogleLink       *string                             `json:"googleLink,omitempty"`
	Website          *string                             `json:"website,omitempty"`
	Type             *ExperienceType                     `json:"type,omitempty"`
	ExtraTypes       *PlaceUpdateextraTypesInput         `json:"extraTypes,omitempty"`
	Routes           *RouteUpdateManyWithoutPlacesInput  `json:"routes,omitempty"`
	Reviews          *PersonReviewsUpdateManyInput       `json:"reviews,omitempty"`
	Tags             *PlaceUpdatetagsInput               `json:"tags,omitempty"`
	LikedBy          *PersonUpdateManyInput              `json:"likedBy,omitempty"`
	Popularity       *float64                            `json:"popularity,omitempty"`
	Ambassadors      *ExpertUpdateManyInput              `json:"ambassadors,omitempty"`
	ProviderWeb      *string                             `json:"providerWeb,omitempty"`
	ContactPhone     *string                             `json:"contactPhone,omitempty"`
	ContactEmail     *string                             `json:"contactEmail,omitempty"`
	AddressReference *string                             `json:"addressReference,omitempty"`
	OpeningHours     *OpeningHoursUpdateOneRequiredInput `json:"openingHours,omitempty"`
}

type PersonCreateOneWithoutIdentificationInput struct {
	Create  *PersonCreateWithoutIdentificationInput `json:"create,omitempty"`
	Connect *PersonWhereUniqueInput                 `json:"connect,omitempty"`
}

type PlaceUpdateextraTypesInput struct {
	Set []ExperienceType `json:"set,omitempty"`
}

type FeatureUpdateManyMutationInput struct {
	Image *string `json:"image,omitempty"`
}

type RouteUpdateManyWithoutPlacesInput struct {
	Create     []RouteCreateWithoutPlacesInput                `json:"create,omitempty"`
	Delete     []RouteWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []RouteWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []RouteWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []RouteWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []RouteUpdateWithWhereUniqueWithoutPlacesInput `json:"update,omitempty"`
	Upsert     []RouteUpsertWithWhereUniqueWithoutPlacesInput `json:"upsert,omitempty"`
	DeleteMany []RouteScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []RouteUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type FeatureUpdateInput struct {
	Name  *TextUpdateOneInput `json:"name,omitempty"`
	Image *string             `json:"image,omitempty"`
}

type RouteUpdateWithWhereUniqueWithoutPlacesInput struct {
	Where RouteWhereUniqueInput             `json:"where"`
	Data  RouteUpdateWithoutPlacesDataInput `json:"data"`
}

type FaqUpdateWithoutEntriesDataInput struct {
	Attraction *AttractionUpdateOneRequiredWithoutFaqsInput `json:"attraction,omitempty"`
}

type RouteUpdateWithoutPlacesDataInput struct {
	Name        *string                                `json:"name,omitempty"`
	Image       *string                                `json:"image,omitempty"`
	Type        *ExperienceType                        `json:"type,omitempty"`
	ExtraTypes  *RouteUpdateextraTypesInput            `json:"extraTypes,omitempty"`
	Creator     *ExpertUpdateOneRequiredInput          `json:"creator,omitempty"`
	LinkedStory *StoryUpdateOneWithoutLinkedRouteInput `json:"linkedStory,omitempty"`
	LikedBy     *PersonUpdateManyInput                 `json:"likedBy,omitempty"`
	Reviews     *PersonReviewsUpdateManyInput          `json:"reviews,omitempty"`
	Popularity  *float64                               `json:"popularity,omitempty"`
	Color       *string                                `json:"color,omitempty"`
}

type TicketWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type RouteUpdateextraTypesInput struct {
	Set []ExperienceType `json:"set,omitempty"`
}

type FaqCreateWithoutEntriesInput struct {
	ID         *string                             `json:"id,omitempty"`
	Attraction AttractionCreateOneWithoutFaqsInput `json:"attraction"`
}

type ExpertUpdateOneRequiredInput struct {
	Create  *ExpertCreateInput       `json:"create,omitempty"`
	Update  *ExpertUpdateDataInput   `json:"update,omitempty"`
	Upsert  *ExpertUpsertNestedInput `json:"upsert,omitempty"`
	Connect *ExpertWhereUniqueInput  `json:"connect,omitempty"`
}

type TravelerWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ExpertUpdateDataInput struct {
	Person  *PersonUpdateOneRequiredInput      `json:"person,omitempty"`
	Alias   *string                            `json:"alias,omitempty"`
	Stories *StoryUpdateManyWithoutAuthorInput `json:"stories,omitempty"`
}

type AttractionUpsertWithoutFaqsInput struct {
	Update AttractionUpdateWithoutFaqsDataInput `json:"update"`
	Create AttractionCreateWithoutFaqsInput     `json:"create"`
}

type StoryUpdateManyWithoutAuthorInput struct {
	Create     []StoryCreateWithoutAuthorInput                `json:"create,omitempty"`
	Delete     []StoryWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []StoryWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []StoryWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []StoryWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []StoryUpdateWithWhereUniqueWithoutAuthorInput `json:"update,omitempty"`
	Upsert     []StoryUpsertWithWhereUniqueWithoutAuthorInput `json:"upsert,omitempty"`
	DeleteMany []StoryScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []StoryUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type AttractionUpdateOneRequiredWithoutFaqsInput struct {
	Create  *AttractionCreateWithoutFaqsInput     `json:"create,omitempty"`
	Update  *AttractionUpdateWithoutFaqsDataInput `json:"update,omitempty"`
	Upsert  *AttractionUpsertWithoutFaqsInput     `json:"upsert,omitempty"`
	Connect *AttractionWhereUniqueInput           `json:"connect,omitempty"`
}

type PurchaseWhereInput struct {
	ID                           *string                  `json:"id,omitempty"`
	IDNot                        *string                  `json:"id_not,omitempty"`
	IDIn                         []string                 `json:"id_in,omitempty"`
	IDNotIn                      []string                 `json:"id_not_in,omitempty"`
	IDLt                         *string                  `json:"id_lt,omitempty"`
	IDLte                        *string                  `json:"id_lte,omitempty"`
	IDGt                         *string                  `json:"id_gt,omitempty"`
	IDGte                        *string                  `json:"id_gte,omitempty"`
	IDContains                   *string                  `json:"id_contains,omitempty"`
	IDNotContains                *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt                    *string                  `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                  `json:"updatedAt_gte,omitempty"`
	ChargeToken                  *string                  `json:"chargeToken,omitempty"`
	ChargeTokenNot               *string                  `json:"chargeToken_not,omitempty"`
	ChargeTokenIn                []string                 `json:"chargeToken_in,omitempty"`
	ChargeTokenNotIn             []string                 `json:"chargeToken_not_in,omitempty"`
	ChargeTokenLt                *string                  `json:"chargeToken_lt,omitempty"`
	ChargeTokenLte               *string                  `json:"chargeToken_lte,omitempty"`
	ChargeTokenGt                *string                  `json:"chargeToken_gt,omitempty"`
	ChargeTokenGte               *string                  `json:"chargeToken_gte,omitempty"`
	ChargeTokenContains          *string                  `json:"chargeToken_contains,omitempty"`
	ChargeTokenNotContains       *string                  `json:"chargeToken_not_contains,omitempty"`
	ChargeTokenStartsWith        *string                  `json:"chargeToken_starts_with,omitempty"`
	ChargeTokenNotStartsWith     *string                  `json:"chargeToken_not_starts_with,omitempty"`
	ChargeTokenEndsWith          *string                  `json:"chargeToken_ends_with,omitempty"`
	ChargeTokenNotEndsWith       *string                  `json:"chargeToken_not_ends_with,omitempty"`
	GatewayResponse              *string                  `json:"gatewayResponse,omitempty"`
	GatewayResponseNot           *string                  `json:"gatewayResponse_not,omitempty"`
	GatewayResponseIn            []string                 `json:"gatewayResponse_in,omitempty"`
	GatewayResponseNotIn         []string                 `json:"gatewayResponse_not_in,omitempty"`
	GatewayResponseLt            *string                  `json:"gatewayResponse_lt,omitempty"`
	GatewayResponseLte           *string                  `json:"gatewayResponse_lte,omitempty"`
	GatewayResponseGt            *string                  `json:"gatewayResponse_gt,omitempty"`
	GatewayResponseGte           *string                  `json:"gatewayResponse_gte,omitempty"`
	GatewayResponseContains      *string                  `json:"gatewayResponse_contains,omitempty"`
	GatewayResponseNotContains   *string                  `json:"gatewayResponse_not_contains,omitempty"`
	GatewayResponseStartsWith    *string                  `json:"gatewayResponse_starts_with,omitempty"`
	GatewayResponseNotStartsWith *string                  `json:"gatewayResponse_not_starts_with,omitempty"`
	GatewayResponseEndsWith      *string                  `json:"gatewayResponse_ends_with,omitempty"`
	GatewayResponseNotEndsWith   *string                  `json:"gatewayResponse_not_ends_with,omitempty"`
	ProductsEvery                *ProductEntryWhereInput  `json:"products_every,omitempty"`
	ProductsSome                 *ProductEntryWhereInput  `json:"products_some,omitempty"`
	ProductsNone                 *ProductEntryWhereInput  `json:"products_none,omitempty"`
	DiscountId                   *string                  `json:"discountID,omitempty"`
	DiscountIdNot                *string                  `json:"discountID_not,omitempty"`
	DiscountIdIn                 []string                 `json:"discountID_in,omitempty"`
	DiscountIdNotIn              []string                 `json:"discountID_not_in,omitempty"`
	DiscountIdLt                 *string                  `json:"discountID_lt,omitempty"`
	DiscountIdLte                *string                  `json:"discountID_lte,omitempty"`
	DiscountIdGt                 *string                  `json:"discountID_gt,omitempty"`
	DiscountIdGte                *string                  `json:"discountID_gte,omitempty"`
	DiscountIdContains           *string                  `json:"discountID_contains,omitempty"`
	DiscountIdNotContains        *string                  `json:"discountID_not_contains,omitempty"`
	DiscountIdStartsWith         *string                  `json:"discountID_starts_with,omitempty"`
	DiscountIdNotStartsWith      *string                  `json:"discountID_not_starts_with,omitempty"`
	DiscountIdEndsWith           *string                  `json:"discountID_ends_with,omitempty"`
	DiscountIdNotEndsWith        *string                  `json:"discountID_not_ends_with,omitempty"`
	Discount                     *int32                   `json:"discount,omitempty"`
	DiscountNot                  *int32                   `json:"discount_not,omitempty"`
	DiscountIn                   []int32                  `json:"discount_in,omitempty"`
	DiscountNotIn                []int32                  `json:"discount_not_in,omitempty"`
	DiscountLt                   *int32                   `json:"discount_lt,omitempty"`
	DiscountLte                  *int32                   `json:"discount_lte,omitempty"`
	DiscountGt                   *int32                   `json:"discount_gt,omitempty"`
	DiscountGte                  *int32                   `json:"discount_gte,omitempty"`
	PaymentMethod                *PaymentMethodWhereInput `json:"paymentMethod,omitempty"`
	And                          []PurchaseWhereInput     `json:"AND,omitempty"`
	Or                           []PurchaseWhereInput     `json:"OR,omitempty"`
	Not                          []PurchaseWhereInput     `json:"NOT,omitempty"`
}

type ActionTicketCreateInput struct {
	ID        *string          `json:"id,omitempty"`
	Type      ActionTicketType `json:"type"`
	Token     string           `json:"token"`
	Available bool             `json:"available"`
	Used      bool             `json:"used"`
}

type PaymentMethodWhereInput struct {
	ID                      *string                   `json:"id,omitempty"`
	IDNot                   *string                   `json:"id_not,omitempty"`
	IDIn                    []string                  `json:"id_in,omitempty"`
	IDNotIn                 []string                  `json:"id_not_in,omitempty"`
	IDLt                    *string                   `json:"id_lt,omitempty"`
	IDLte                   *string                   `json:"id_lte,omitempty"`
	IDGt                    *string                   `json:"id_gt,omitempty"`
	IDGte                   *string                   `json:"id_gte,omitempty"`
	IDContains              *string                   `json:"id_contains,omitempty"`
	IDNotContains           *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith            *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string                   `json:"id_not_ends_with,omitempty"`
	Type                    *PaymentMethodType        `json:"type,omitempty"`
	TypeNot                 *PaymentMethodType        `json:"type_not,omitempty"`
	TypeIn                  []PaymentMethodType       `json:"type_in,omitempty"`
	TypeNotIn               []PaymentMethodType       `json:"type_not_in,omitempty"`
	Value                   *string                   `json:"value,omitempty"`
	ValueNot                *string                   `json:"value_not,omitempty"`
	ValueIn                 []string                  `json:"value_in,omitempty"`
	ValueNotIn              []string                  `json:"value_not_in,omitempty"`
	ValueLt                 *string                   `json:"value_lt,omitempty"`
	ValueLte                *string                   `json:"value_lte,omitempty"`
	ValueGt                 *string                   `json:"value_gt,omitempty"`
	ValueGte                *string                   `json:"value_gte,omitempty"`
	ValueContains           *string                   `json:"value_contains,omitempty"`
	ValueNotContains        *string                   `json:"value_not_contains,omitempty"`
	ValueStartsWith         *string                   `json:"value_starts_with,omitempty"`
	ValueNotStartsWith      *string                   `json:"value_not_starts_with,omitempty"`
	ValueEndsWith           *string                   `json:"value_ends_with,omitempty"`
	ValueNotEndsWith        *string                   `json:"value_not_ends_with,omitempty"`
	CardNumber              *string                   `json:"cardNumber,omitempty"`
	CardNumberNot           *string                   `json:"cardNumber_not,omitempty"`
	CardNumberIn            []string                  `json:"cardNumber_in,omitempty"`
	CardNumberNotIn         []string                  `json:"cardNumber_not_in,omitempty"`
	CardNumberLt            *string                   `json:"cardNumber_lt,omitempty"`
	CardNumberLte           *string                   `json:"cardNumber_lte,omitempty"`
	CardNumberGt            *string                   `json:"cardNumber_gt,omitempty"`
	CardNumberGte           *string                   `json:"cardNumber_gte,omitempty"`
	CardNumberContains      *string                   `json:"cardNumber_contains,omitempty"`
	CardNumberNotContains   *string                   `json:"cardNumber_not_contains,omitempty"`
	CardNumberStartsWith    *string                   `json:"cardNumber_starts_with,omitempty"`
	CardNumberNotStartsWith *string                   `json:"cardNumber_not_starts_with,omitempty"`
	CardNumberEndsWith      *string                   `json:"cardNumber_ends_with,omitempty"`
	CardNumberNotEndsWith   *string                   `json:"cardNumber_not_ends_with,omitempty"`
	Code                    *string                   `json:"code,omitempty"`
	CodeNot                 *string                   `json:"code_not,omitempty"`
	CodeIn                  []string                  `json:"code_in,omitempty"`
	CodeNotIn               []string                  `json:"code_not_in,omitempty"`
	CodeLt                  *string                   `json:"code_lt,omitempty"`
	CodeLte                 *string                   `json:"code_lte,omitempty"`
	CodeGt                  *string                   `json:"code_gt,omitempty"`
	CodeGte                 *string                   `json:"code_gte,omitempty"`
	CodeContains            *string                   `json:"code_contains,omitempty"`
	CodeNotContains         *string                   `json:"code_not_contains,omitempty"`
	CodeStartsWith          *string                   `json:"code_starts_with,omitempty"`
	CodeNotStartsWith       *string                   `json:"code_not_starts_with,omitempty"`
	CodeEndsWith            *string                   `json:"code_ends_with,omitempty"`
	CodeNotEndsWith         *string                   `json:"code_not_ends_with,omitempty"`
	And                     []PaymentMethodWhereInput `json:"AND,omitempty"`
	Or                      []PaymentMethodWhereInput `json:"OR,omitempty"`
	Not                     []PaymentMethodWhereInput `json:"NOT,omitempty"`
}

type ActionTicketUpdateManyMutationInput struct {
	Type      *ActionTicketType `json:"type,omitempty"`
	Token     *string           `json:"token,omitempty"`
	Available *bool             `json:"available,omitempty"`
	Used      *bool             `json:"used,omitempty"`
}

type PassTypeWhereInput struct {
	ID                     *string               `json:"id,omitempty"`
	IDNot                  *string               `json:"id_not,omitempty"`
	IDIn                   []string              `json:"id_in,omitempty"`
	IDNotIn                []string              `json:"id_not_in,omitempty"`
	IDLt                   *string               `json:"id_lt,omitempty"`
	IDLte                  *string               `json:"id_lte,omitempty"`
	IDGt                   *string               `json:"id_gt,omitempty"`
	IDGte                  *string               `json:"id_gte,omitempty"`
	IDContains             *string               `json:"id_contains,omitempty"`
	IDNotContains          *string               `json:"id_not_contains,omitempty"`
	IDStartsWith           *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string               `json:"id_not_ends_with,omitempty"`
	CreatedAt              *string               `json:"createdAt,omitempty"`
	CreatedAtNot           *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string               `json:"updatedAt_gte,omitempty"`
	Name                   *TextWhereInput       `json:"name,omitempty"`
	ShortDescription       *TextWhereInput       `json:"shortDescription,omitempty"`
	Description            *TextWhereInput       `json:"description,omitempty"`
	Disclaimer             *TextWhereInput       `json:"disclaimer,omitempty"`
	CreatorId              *string               `json:"creatorID,omitempty"`
	CreatorIdNot           *string               `json:"creatorID_not,omitempty"`
	CreatorIdIn            []string              `json:"creatorID_in,omitempty"`
	CreatorIdNotIn         []string              `json:"creatorID_not_in,omitempty"`
	CreatorIdLt            *string               `json:"creatorID_lt,omitempty"`
	CreatorIdLte           *string               `json:"creatorID_lte,omitempty"`
	CreatorIdGt            *string               `json:"creatorID_gt,omitempty"`
	CreatorIdGte           *string               `json:"creatorID_gte,omitempty"`
	CreatorIdContains      *string               `json:"creatorID_contains,omitempty"`
	CreatorIdNotContains   *string               `json:"creatorID_not_contains,omitempty"`
	CreatorIdStartsWith    *string               `json:"creatorID_starts_with,omitempty"`
	CreatorIdNotStartsWith *string               `json:"creatorID_not_starts_with,omitempty"`
	CreatorIdEndsWith      *string               `json:"creatorID_ends_with,omitempty"`
	CreatorIdNotEndsWith   *string               `json:"creatorID_not_ends_with,omitempty"`
	AttractionsEvery       *AttractionWhereInput `json:"attractions_every,omitempty"`
	AttractionsSome        *AttractionWhereInput `json:"attractions_some,omitempty"`
	AttractionsNone        *AttractionWhereInput `json:"attractions_none,omitempty"`
	Cost                   *CostWhereInput       `json:"cost,omitempty"`
	Duration               *int32                `json:"duration,omitempty"`
	DurationNot            *int32                `json:"duration_not,omitempty"`
	DurationIn             []int32               `json:"duration_in,omitempty"`
	DurationNotIn          []int32               `json:"duration_not_in,omitempty"`
	DurationLt             *int32                `json:"duration_lt,omitempty"`
	DurationLte            *int32                `json:"duration_lte,omitempty"`
	DurationGt             *int32                `json:"duration_gt,omitempty"`
	DurationGte            *int32                `json:"duration_gte,omitempty"`
	ChildrenEvery          *PassWhereInput       `json:"children_every,omitempty"`
	ChildrenSome           *PassWhereInput       `json:"children_some,omitempty"`
	ChildrenNone           *PassWhereInput       `json:"children_none,omitempty"`
	And                    []PassTypeWhereInput  `json:"AND,omitempty"`
	Or                     []PassTypeWhereInput  `json:"OR,omitempty"`
	Not                    []PassTypeWhereInput  `json:"NOT,omitempty"`
}

type AttractionCreateWithoutFaqsInput struct {
	ID               *string                                 `json:"id,omitempty"`
	Owner            PartnerCreateOneWithoutAttractionsInput `json:"owner"`
	Name             TextCreateOneInput                      `json:"name"`
	Description      *TextCreateOneInput                     `json:"description,omitempty"`
	ShortDescription *TextCreateOneInput                     `json:"shortDescription,omitempty"`
	PrincipalImage   *string                                 `json:"principalImage,omitempty"`
	CoverImage       *string                                 `json:"coverImage,omitempty"`
	LandscapeImage   *string                                 `json:"landscapeImage,omitempty"`
	Gallery          *AttractionCreategalleryInput           `json:"gallery,omitempty"`
	Type             *AttractionCreatetypeInput              `json:"type,omitempty"`
	Place            PlaceCreateOneInput                     `json:"place"`
}

type TravelerWhereInput struct {
	ID                    *string                 `json:"id,omitempty"`
	IDNot                 *string                 `json:"id_not,omitempty"`
	IDIn                  []string                `json:"id_in,omitempty"`
	IDNotIn               []string                `json:"id_not_in,omitempty"`
	IDLt                  *string                 `json:"id_lt,omitempty"`
	IDLte                 *string                 `json:"id_lte,omitempty"`
	IDGt                  *string                 `json:"id_gt,omitempty"`
	IDGte                 *string                 `json:"id_gte,omitempty"`
	IDContains            *string                 `json:"id_contains,omitempty"`
	IDNotContains         *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt             *string                 `json:"createdAt,omitempty"`
	CreatedAtNot          *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                 `json:"updatedAt_gte,omitempty"`
	Unregistered          *bool                   `json:"unregistered,omitempty"`
	UnregisteredNot       *bool                   `json:"unregistered_not,omitempty"`
	RegistrationTicket    *ActionTicketWhereInput `json:"registrationTicket,omitempty"`
	Person                *PersonWhereInput       `json:"person,omitempty"`
	Username              *string                 `json:"username,omitempty"`
	UsernameNot           *string                 `json:"username_not,omitempty"`
	UsernameIn            []string                `json:"username_in,omitempty"`
	UsernameNotIn         []string                `json:"username_not_in,omitempty"`
	UsernameLt            *string                 `json:"username_lt,omitempty"`
	UsernameLte           *string                 `json:"username_lte,omitempty"`
	UsernameGt            *string                 `json:"username_gt,omitempty"`
	UsernameGte           *string                 `json:"username_gte,omitempty"`
	UsernameContains      *string                 `json:"username_contains,omitempty"`
	UsernameNotContains   *string                 `json:"username_not_contains,omitempty"`
	UsernameStartsWith    *string                 `json:"username_starts_with,omitempty"`
	UsernameNotStartsWith *string                 `json:"username_not_starts_with,omitempty"`
	UsernameEndsWith      *string                 `json:"username_ends_with,omitempty"`
	UsernameNotEndsWith   *string                 `json:"username_not_ends_with,omitempty"`
	CardsEvery            *CreditCardWhereInput   `json:"cards_every,omitempty"`
	CardsSome             *CreditCardWhereInput   `json:"cards_some,omitempty"`
	CardsNone             *CreditCardWhereInput   `json:"cards_none,omitempty"`
	PurchasesEvery        *PurchaseWhereInput     `json:"purchases_every,omitempty"`
	PurchasesSome         *PurchaseWhereInput     `json:"purchases_some,omitempty"`
	PurchasesNone         *PurchaseWhereInput     `json:"purchases_none,omitempty"`
	PassesEvery           *PassWhereInput         `json:"passes_every,omitempty"`
	PassesSome            *PassWhereInput         `json:"passes_some,omitempty"`
	PassesNone            *PassWhereInput         `json:"passes_none,omitempty"`
	RegistryEvery         *EntryTicketWhereInput  `json:"registry_every,omitempty"`
	RegistrySome          *EntryTicketWhereInput  `json:"registry_some,omitempty"`
	RegistryNone          *EntryTicketWhereInput  `json:"registry_none,omitempty"`
	And                   []TravelerWhereInput    `json:"AND,omitempty"`
	Or                    []TravelerWhereInput    `json:"OR,omitempty"`
	Not                   []TravelerWhereInput    `json:"NOT,omitempty"`
}

type PartnerCreateOneWithoutAttractionsInput struct {
	Create  *PartnerCreateWithoutAttractionsInput `json:"create,omitempty"`
	Connect *PartnerWhereUniqueInput              `json:"connect,omitempty"`
}

type TicketWhereInput struct {
	ID              *string               `json:"id,omitempty"`
	IDNot           *string               `json:"id_not,omitempty"`
	IDIn            []string              `json:"id_in,omitempty"`
	IDNotIn         []string              `json:"id_not_in,omitempty"`
	IDLt            *string               `json:"id_lt,omitempty"`
	IDLte           *string               `json:"id_lte,omitempty"`
	IDGt            *string               `json:"id_gt,omitempty"`
	IDGte           *string               `json:"id_gte,omitempty"`
	IDContains      *string               `json:"id_contains,omitempty"`
	IDNotContains   *string               `json:"id_not_contains,omitempty"`
	IDStartsWith    *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string               `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string               `json:"createdAt,omitempty"`
	CreatedAtNot    *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string               `json:"updatedAt_gte,omitempty"`
	Parent          *PassWhereInput       `json:"parent,omitempty"`
	Attraction      *AttractionWhereInput `json:"attraction,omitempty"`
	Description     *TextWhereInput       `json:"description,omitempty"`
	AvailableTime   *TextWhereInput       `json:"availableTime,omitempty"`
	MaxUses         *int32                `json:"maxUses,omitempty"`
	MaxUsesNot      *int32                `json:"maxUses_not,omitempty"`
	MaxUsesIn       []int32               `json:"maxUses_in,omitempty"`
	MaxUsesNotIn    []int32               `json:"maxUses_not_in,omitempty"`
	MaxUsesLt       *int32                `json:"maxUses_lt,omitempty"`
	MaxUsesLte      *int32                `json:"maxUses_lte,omitempty"`
	MaxUsesGt       *int32                `json:"maxUses_gt,omitempty"`
	MaxUsesGte      *int32                `json:"maxUses_gte,omitempty"`
	Visited         *bool                 `json:"visited,omitempty"`
	VisitedNot      *bool                 `json:"visited_not,omitempty"`
	Finished        *bool                 `json:"finished,omitempty"`
	FinishedNot     *bool                 `json:"finished_not,omitempty"`
	State           *TicketState          `json:"state,omitempty"`
	StateNot        *TicketState          `json:"state_not,omitempty"`
	StateIn         []TicketState         `json:"state_in,omitempty"`
	StateNotIn      []TicketState         `json:"state_not_in,omitempty"`
	And             []TicketWhereInput    `json:"AND,omitempty"`
	Or              []TicketWhereInput    `json:"OR,omitempty"`
	Not             []TicketWhereInput    `json:"NOT,omitempty"`
}

type PersonCreateOneInput struct {
	Create  *PersonCreateInput      `json:"create,omitempty"`
	Connect *PersonWhereUniqueInput `json:"connect,omitempty"`
}

type FaqEntryWhereInput struct {
	ID              *string              `json:"id,omitempty"`
	IDNot           *string              `json:"id_not,omitempty"`
	IDIn            []string             `json:"id_in,omitempty"`
	IDNotIn         []string             `json:"id_not_in,omitempty"`
	IDLt            *string              `json:"id_lt,omitempty"`
	IDLte           *string              `json:"id_lte,omitempty"`
	IDGt            *string              `json:"id_gt,omitempty"`
	IDGte           *string              `json:"id_gte,omitempty"`
	IDContains      *string              `json:"id_contains,omitempty"`
	IDNotContains   *string              `json:"id_not_contains,omitempty"`
	IDStartsWith    *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string              `json:"id_not_ends_with,omitempty"`
	Faq             *FaqWhereInput       `json:"faq,omitempty"`
	Question        *TextWhereInput      `json:"question,omitempty"`
	Answer          *TextWhereInput      `json:"answer,omitempty"`
	And             []FaqEntryWhereInput `json:"AND,omitempty"`
	Or              []FaqEntryWhereInput `json:"OR,omitempty"`
	Not             []FaqEntryWhereInput `json:"NOT,omitempty"`
}

type TextCreateOneInput struct {
	Create  *TextCreateInput      `json:"create,omitempty"`
	Connect *TextWhereUniqueInput `json:"connect,omitempty"`
}

type EntryTicketWhereInput struct {
	ID              *string                 `json:"id,omitempty"`
	IDNot           *string                 `json:"id_not,omitempty"`
	IDIn            []string                `json:"id_in,omitempty"`
	IDNotIn         []string                `json:"id_not_in,omitempty"`
	IDLt            *string                 `json:"id_lt,omitempty"`
	IDLte           *string                 `json:"id_lte,omitempty"`
	IDGt            *string                 `json:"id_gt,omitempty"`
	IDGte           *string                 `json:"id_gte,omitempty"`
	IDContains      *string                 `json:"id_contains,omitempty"`
	IDNotContains   *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string                 `json:"createdAt,omitempty"`
	CreatedAtNot    *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                 `json:"updatedAt_gte,omitempty"`
	At              *string                 `json:"at,omitempty"`
	AtNot           *string                 `json:"at_not,omitempty"`
	AtIn            []string                `json:"at_in,omitempty"`
	AtNotIn         []string                `json:"at_not_in,omitempty"`
	AtLt            *string                 `json:"at_lt,omitempty"`
	AtLte           *string                 `json:"at_lte,omitempty"`
	AtGt            *string                 `json:"at_gt,omitempty"`
	AtGte           *string                 `json:"at_gte,omitempty"`
	Ticket          *TicketWhereInput       `json:"ticket,omitempty"`
	Partner         *PartnerWhereInput      `json:"partner,omitempty"`
	Traveler        *TravelerWhereInput     `json:"traveler,omitempty"`
	And             []EntryTicketWhereInput `json:"AND,omitempty"`
	Or              []EntryTicketWhereInput `json:"OR,omitempty"`
	Not             []EntryTicketWhereInput `json:"NOT,omitempty"`
}

type PhoneChannelCreateManyWithoutPersonInput struct {
	Create  []PhoneChannelCreateWithoutPersonInput `json:"create,omitempty"`
	Connect []PhoneChannelWhereUniqueInput         `json:"connect,omitempty"`
}

type ExpertWhereInput struct {
	ID                 *string            `json:"id,omitempty"`
	IDNot              *string            `json:"id_not,omitempty"`
	IDIn               []string           `json:"id_in,omitempty"`
	IDNotIn            []string           `json:"id_not_in,omitempty"`
	IDLt               *string            `json:"id_lt,omitempty"`
	IDLte              *string            `json:"id_lte,omitempty"`
	IDGt               *string            `json:"id_gt,omitempty"`
	IDGte              *string            `json:"id_gte,omitempty"`
	IDContains         *string            `json:"id_contains,omitempty"`
	IDNotContains      *string            `json:"id_not_contains,omitempty"`
	IDStartsWith       *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string            `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string            `json:"createdAt,omitempty"`
	CreatedAtNot       *string            `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string            `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string            `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string            `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string            `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string            `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string            `json:"updatedAt_gte,omitempty"`
	Person             *PersonWhereInput  `json:"person,omitempty"`
	Alias              *string            `json:"alias,omitempty"`
	AliasNot           *string            `json:"alias_not,omitempty"`
	AliasIn            []string           `json:"alias_in,omitempty"`
	AliasNotIn         []string           `json:"alias_not_in,omitempty"`
	AliasLt            *string            `json:"alias_lt,omitempty"`
	AliasLte           *string            `json:"alias_lte,omitempty"`
	AliasGt            *string            `json:"alias_gt,omitempty"`
	AliasGte           *string            `json:"alias_gte,omitempty"`
	AliasContains      *string            `json:"alias_contains,omitempty"`
	AliasNotContains   *string            `json:"alias_not_contains,omitempty"`
	AliasStartsWith    *string            `json:"alias_starts_with,omitempty"`
	AliasNotStartsWith *string            `json:"alias_not_starts_with,omitempty"`
	AliasEndsWith      *string            `json:"alias_ends_with,omitempty"`
	AliasNotEndsWith   *string            `json:"alias_not_ends_with,omitempty"`
	StoriesEvery       *StoryWhereInput   `json:"stories_every,omitempty"`
	StoriesSome        *StoryWhereInput   `json:"stories_some,omitempty"`
	StoriesNone        *StoryWhereInput   `json:"stories_none,omitempty"`
	And                []ExpertWhereInput `json:"AND,omitempty"`
	Or                 []ExpertWhereInput `json:"OR,omitempty"`
	Not                []ExpertWhereInput `json:"NOT,omitempty"`
}

type EmailChannelCreateManyWithoutPersonInput struct {
	Create  []EmailChannelCreateWithoutPersonInput `json:"create,omitempty"`
	Connect []EmailChannelWhereUniqueInput         `json:"connect,omitempty"`
}

type OpeningHoursWhereInput struct {
	ID               *string                  `json:"id,omitempty"`
	IDNot            *string                  `json:"id_not,omitempty"`
	IDIn             []string                 `json:"id_in,omitempty"`
	IDNotIn          []string                 `json:"id_not_in,omitempty"`
	IDLt             *string                  `json:"id_lt,omitempty"`
	IDLte            *string                  `json:"id_lte,omitempty"`
	IDGt             *string                  `json:"id_gt,omitempty"`
	IDGte            *string                  `json:"id_gte,omitempty"`
	IDContains       *string                  `json:"id_contains,omitempty"`
	IDNotContains    *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith     *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith  *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith       *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith    *string                  `json:"id_not_ends_with,omitempty"`
	Mon              *string                  `json:"mon,omitempty"`
	MonNot           *string                  `json:"mon_not,omitempty"`
	MonIn            []string                 `json:"mon_in,omitempty"`
	MonNotIn         []string                 `json:"mon_not_in,omitempty"`
	MonLt            *string                  `json:"mon_lt,omitempty"`
	MonLte           *string                  `json:"mon_lte,omitempty"`
	MonGt            *string                  `json:"mon_gt,omitempty"`
	MonGte           *string                  `json:"mon_gte,omitempty"`
	MonContains      *string                  `json:"mon_contains,omitempty"`
	MonNotContains   *string                  `json:"mon_not_contains,omitempty"`
	MonStartsWith    *string                  `json:"mon_starts_with,omitempty"`
	MonNotStartsWith *string                  `json:"mon_not_starts_with,omitempty"`
	MonEndsWith      *string                  `json:"mon_ends_with,omitempty"`
	MonNotEndsWith   *string                  `json:"mon_not_ends_with,omitempty"`
	Tue              *string                  `json:"tue,omitempty"`
	TueNot           *string                  `json:"tue_not,omitempty"`
	TueIn            []string                 `json:"tue_in,omitempty"`
	TueNotIn         []string                 `json:"tue_not_in,omitempty"`
	TueLt            *string                  `json:"tue_lt,omitempty"`
	TueLte           *string                  `json:"tue_lte,omitempty"`
	TueGt            *string                  `json:"tue_gt,omitempty"`
	TueGte           *string                  `json:"tue_gte,omitempty"`
	TueContains      *string                  `json:"tue_contains,omitempty"`
	TueNotContains   *string                  `json:"tue_not_contains,omitempty"`
	TueStartsWith    *string                  `json:"tue_starts_with,omitempty"`
	TueNotStartsWith *string                  `json:"tue_not_starts_with,omitempty"`
	TueEndsWith      *string                  `json:"tue_ends_with,omitempty"`
	TueNotEndsWith   *string                  `json:"tue_not_ends_with,omitempty"`
	Wed              *string                  `json:"wed,omitempty"`
	WedNot           *string                  `json:"wed_not,omitempty"`
	WedIn            []string                 `json:"wed_in,omitempty"`
	WedNotIn         []string                 `json:"wed_not_in,omitempty"`
	WedLt            *string                  `json:"wed_lt,omitempty"`
	WedLte           *string                  `json:"wed_lte,omitempty"`
	WedGt            *string                  `json:"wed_gt,omitempty"`
	WedGte           *string                  `json:"wed_gte,omitempty"`
	WedContains      *string                  `json:"wed_contains,omitempty"`
	WedNotContains   *string                  `json:"wed_not_contains,omitempty"`
	WedStartsWith    *string                  `json:"wed_starts_with,omitempty"`
	WedNotStartsWith *string                  `json:"wed_not_starts_with,omitempty"`
	WedEndsWith      *string                  `json:"wed_ends_with,omitempty"`
	WedNotEndsWith   *string                  `json:"wed_not_ends_with,omitempty"`
	Thu              *string                  `json:"thu,omitempty"`
	ThuNot           *string                  `json:"thu_not,omitempty"`
	ThuIn            []string                 `json:"thu_in,omitempty"`
	ThuNotIn         []string                 `json:"thu_not_in,omitempty"`
	ThuLt            *string                  `json:"thu_lt,omitempty"`
	ThuLte           *string                  `json:"thu_lte,omitempty"`
	ThuGt            *string                  `json:"thu_gt,omitempty"`
	ThuGte           *string                  `json:"thu_gte,omitempty"`
	ThuContains      *string                  `json:"thu_contains,omitempty"`
	ThuNotContains   *string                  `json:"thu_not_contains,omitempty"`
	ThuStartsWith    *string                  `json:"thu_starts_with,omitempty"`
	ThuNotStartsWith *string                  `json:"thu_not_starts_with,omitempty"`
	ThuEndsWith      *string                  `json:"thu_ends_with,omitempty"`
	ThuNotEndsWith   *string                  `json:"thu_not_ends_with,omitempty"`
	Fri              *string                  `json:"fri,omitempty"`
	FriNot           *string                  `json:"fri_not,omitempty"`
	FriIn            []string                 `json:"fri_in,omitempty"`
	FriNotIn         []string                 `json:"fri_not_in,omitempty"`
	FriLt            *string                  `json:"fri_lt,omitempty"`
	FriLte           *string                  `json:"fri_lte,omitempty"`
	FriGt            *string                  `json:"fri_gt,omitempty"`
	FriGte           *string                  `json:"fri_gte,omitempty"`
	FriContains      *string                  `json:"fri_contains,omitempty"`
	FriNotContains   *string                  `json:"fri_not_contains,omitempty"`
	FriStartsWith    *string                  `json:"fri_starts_with,omitempty"`
	FriNotStartsWith *string                  `json:"fri_not_starts_with,omitempty"`
	FriEndsWith      *string                  `json:"fri_ends_with,omitempty"`
	FriNotEndsWith   *string                  `json:"fri_not_ends_with,omitempty"`
	Sat              *string                  `json:"sat,omitempty"`
	SatNot           *string                  `json:"sat_not,omitempty"`
	SatIn            []string                 `json:"sat_in,omitempty"`
	SatNotIn         []string                 `json:"sat_not_in,omitempty"`
	SatLt            *string                  `json:"sat_lt,omitempty"`
	SatLte           *string                  `json:"sat_lte,omitempty"`
	SatGt            *string                  `json:"sat_gt,omitempty"`
	SatGte           *string                  `json:"sat_gte,omitempty"`
	SatContains      *string                  `json:"sat_contains,omitempty"`
	SatNotContains   *string                  `json:"sat_not_contains,omitempty"`
	SatStartsWith    *string                  `json:"sat_starts_with,omitempty"`
	SatNotStartsWith *string                  `json:"sat_not_starts_with,omitempty"`
	SatEndsWith      *string                  `json:"sat_ends_with,omitempty"`
	SatNotEndsWith   *string                  `json:"sat_not_ends_with,omitempty"`
	Sun              *string                  `json:"sun,omitempty"`
	SunNot           *string                  `json:"sun_not,omitempty"`
	SunIn            []string                 `json:"sun_in,omitempty"`
	SunNotIn         []string                 `json:"sun_not_in,omitempty"`
	SunLt            *string                  `json:"sun_lt,omitempty"`
	SunLte           *string                  `json:"sun_lte,omitempty"`
	SunGt            *string                  `json:"sun_gt,omitempty"`
	SunGte           *string                  `json:"sun_gte,omitempty"`
	SunContains      *string                  `json:"sun_contains,omitempty"`
	SunNotContains   *string                  `json:"sun_not_contains,omitempty"`
	SunStartsWith    *string                  `json:"sun_starts_with,omitempty"`
	SunNotStartsWith *string                  `json:"sun_not_starts_with,omitempty"`
	SunEndsWith      *string                  `json:"sun_ends_with,omitempty"`
	SunNotEndsWith   *string                  `json:"sun_not_ends_with,omitempty"`
	Description      *TextWhereInput          `json:"description,omitempty"`
	And              []OpeningHoursWhereInput `json:"AND,omitempty"`
	Or               []OpeningHoursWhereInput `json:"OR,omitempty"`
	Not              []OpeningHoursWhereInput `json:"NOT,omitempty"`
}

type EmailChannelCreateextrasInput struct {
	Set []string `json:"set,omitempty"`
}

type FeatureWhereInput struct {
	ID                 *string             `json:"id,omitempty"`
	IDNot              *string             `json:"id_not,omitempty"`
	IDIn               []string            `json:"id_in,omitempty"`
	IDNotIn            []string            `json:"id_not_in,omitempty"`
	IDLt               *string             `json:"id_lt,omitempty"`
	IDLte              *string             `json:"id_lte,omitempty"`
	IDGt               *string             `json:"id_gt,omitempty"`
	IDGte              *string             `json:"id_gte,omitempty"`
	IDContains         *string             `json:"id_contains,omitempty"`
	IDNotContains      *string             `json:"id_not_contains,omitempty"`
	IDStartsWith       *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string             `json:"id_not_ends_with,omitempty"`
	Name               *TextWhereInput     `json:"name,omitempty"`
	Image              *string             `json:"image,omitempty"`
	ImageNot           *string             `json:"image_not,omitempty"`
	ImageIn            []string            `json:"image_in,omitempty"`
	ImageNotIn         []string            `json:"image_not_in,omitempty"`
	ImageLt            *string             `json:"image_lt,omitempty"`
	ImageLte           *string             `json:"image_lte,omitempty"`
	ImageGt            *string             `json:"image_gt,omitempty"`
	ImageGte           *string             `json:"image_gte,omitempty"`
	ImageContains      *string             `json:"image_contains,omitempty"`
	ImageNotContains   *string             `json:"image_not_contains,omitempty"`
	ImageStartsWith    *string             `json:"image_starts_with,omitempty"`
	ImageNotStartsWith *string             `json:"image_not_starts_with,omitempty"`
	ImageEndsWith      *string             `json:"image_ends_with,omitempty"`
	ImageNotEndsWith   *string             `json:"image_not_ends_with,omitempty"`
	And                []FeatureWhereInput `json:"AND,omitempty"`
	Or                 []FeatureWhereInput `json:"OR,omitempty"`
	Not                []FeatureWhereInput `json:"NOT,omitempty"`
}

type IDDocumentCreateWithoutPersonInput struct {
	ID        *string `json:"id,omitempty"`
	Type      IDType  `json:"type"`
	Value     string  `json:"value"`
	Validated *bool   `json:"validated,omitempty"`
}

type FaqCreateInput struct {
	ID         *string                             `json:"id,omitempty"`
	Attraction AttractionCreateOneWithoutFaqsInput `json:"attraction"`
	Entries    *FaqEntryCreateManyWithoutFaqInput  `json:"entries,omitempty"`
}

type CredentialCreateManyWithoutOwnerInput struct {
	Create  []CredentialCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []CredentialWhereUniqueInput        `json:"connect,omitempty"`
}

type RouteUpdateWithoutLinkedStoryDataInput struct {
	Name       *string                            `json:"name,omitempty"`
	Image      *string                            `json:"image,omitempty"`
	Type       *ExperienceType                    `json:"type,omitempty"`
	ExtraTypes *RouteUpdateextraTypesInput        `json:"extraTypes,omitempty"`
	Creator    *ExpertUpdateOneRequiredInput      `json:"creator,omitempty"`
	Places     *PlaceUpdateManyWithoutRoutesInput `json:"places,omitempty"`
	LikedBy    *PersonUpdateManyInput             `json:"likedBy,omitempty"`
	Reviews    *PersonReviewsUpdateManyInput      `json:"reviews,omitempty"`
	Popularity *float64                           `json:"popularity,omitempty"`
	Color      *string                            `json:"color,omitempty"`
}

type LocationCreateOneInput struct {
	Create  *LocationCreateInput      `json:"create,omitempty"`
	Connect *LocationWhereUniqueInput `json:"connect,omitempty"`
}

type PlaceUpdateManyWithoutRoutesInput struct {
	Create     []PlaceCreateWithoutRoutesInput                `json:"create,omitempty"`
	Delete     []PlaceWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []PlaceWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []PlaceWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []PlaceWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []PlaceUpdateWithWhereUniqueWithoutRoutesInput `json:"update,omitempty"`
	Upsert     []PlaceUpsertWithWhereUniqueWithoutRoutesInput `json:"upsert,omitempty"`
	DeleteMany []PlaceScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []PlaceUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type FeatureCreateManyInput struct {
	Create  []FeatureCreateInput      `json:"create,omitempty"`
	Connect []FeatureWhereUniqueInput `json:"connect,omitempty"`
}

type PlaceUpdateWithWhereUniqueWithoutRoutesInput struct {
	Where PlaceWhereUniqueInput             `json:"where"`
	Data  PlaceUpdateWithoutRoutesDataInput `json:"data"`
}

type OpeningHoursCreateOneInput struct {
	Create  *OpeningHoursCreateInput      `json:"create,omitempty"`
	Connect *OpeningHoursWhereUniqueInput `json:"connect,omitempty"`
}

type PlaceUpdateWithoutRoutesDataInput struct {
	Name             *string                             `json:"name,omitempty"`
	ShortName        *string                             `json:"shortName,omitempty"`
	Description      *TextUpdateOneRequiredInput         `json:"description,omitempty"`
	ShortDescription *TextUpdateOneInput                 `json:"shortDescription,omitempty"`
	Address          *string                             `json:"address,omitempty"`
	Location         *LocationUpdateOneRequiredInput     `json:"location,omitempty"`
	GoogleLink       *string                             `json:"googleLink,omitempty"`
	Website          *string                             `json:"website,omitempty"`
	Type             *ExperienceType                     `json:"type,omitempty"`
	ExtraTypes       *PlaceUpdateextraTypesInput         `json:"extraTypes,omitempty"`
	Reviews          *PersonReviewsUpdateManyInput       `json:"reviews,omitempty"`
	Tags             *PlaceUpdatetagsInput               `json:"tags,omitempty"`
	LikedBy          *PersonUpdateManyInput              `json:"likedBy,omitempty"`
	Popularity       *float64                            `json:"popularity,omitempty"`
	Ambassadors      *ExpertUpdateManyInput              `json:"ambassadors,omitempty"`
	ProviderWeb      *string                             `json:"providerWeb,omitempty"`
	ContactPhone     *string                             `json:"contactPhone,omitempty"`
	ContactEmail     *string                             `json:"contactEmail,omitempty"`
	AddressReference *string                             `json:"addressReference,omitempty"`
	OpeningHours     *OpeningHoursUpdateOneRequiredInput `json:"openingHours,omitempty"`
}

type EntryTicketCreateManyWithoutPartnerInput struct {
	Create  []EntryTicketCreateWithoutPartnerInput `json:"create,omitempty"`
	Connect []EntryTicketWhereUniqueInput          `json:"connect,omitempty"`
}

type PlaceUpdatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type TicketCreateOneInput struct {
	Create  *TicketCreateInput      `json:"create,omitempty"`
	Connect *TicketWhereUniqueInput `json:"connect,omitempty"`
}

type PersonUpdateManyInput struct {
	Create     []PersonCreateInput                      `json:"create,omitempty"`
	Update     []PersonUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []PersonUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []PersonWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []PersonWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []PersonWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []PersonWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []PersonScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []PersonUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type PassCreateOneWithoutTicketsInput struct {
	Create  *PassCreateWithoutTicketsInput `json:"create,omitempty"`
	Connect *PassWhereUniqueInput          `json:"connect,omitempty"`
}

type PersonUpdateWithWhereUniqueNestedInput struct {
	Where PersonWhereUniqueInput `json:"where"`
	Data  PersonUpdateDataInput  `json:"data"`
}

type PassTypeCreateOneWithoutChildrenInput struct {
	Create  *PassTypeCreateWithoutChildrenInput `json:"create,omitempty"`
	Connect *PassTypeWhereUniqueInput           `json:"connect,omitempty"`
}

type PersonUpsertWithWhereUniqueNestedInput struct {
	Where  PersonWhereUniqueInput `json:"where"`
	Update PersonUpdateDataInput  `json:"update"`
	Create PersonCreateInput      `json:"create"`
}

type PassTypeCreategalleryInput struct {
	Set []string `json:"set,omitempty"`
}

type PersonScalarWhereInput struct {
	ID                 *string                  `json:"id,omitempty"`
	IDNot              *string                  `json:"id_not,omitempty"`
	IDIn               []string                 `json:"id_in,omitempty"`
	IDNotIn            []string                 `json:"id_not_in,omitempty"`
	IDLt               *string                  `json:"id_lt,omitempty"`
	IDLte              *string                  `json:"id_lte,omitempty"`
	IDGt               *string                  `json:"id_gt,omitempty"`
	IDGte              *string                  `json:"id_gte,omitempty"`
	IDContains         *string                  `json:"id_contains,omitempty"`
	IDNotContains      *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                  `json:"createdAt,omitempty"`
	CreatedAtNot       *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                  `json:"updatedAt_gte,omitempty"`
	QmId               *string                  `json:"qmID,omitempty"`
	QmIdNot            *string                  `json:"qmID_not,omitempty"`
	QmIdIn             []string                 `json:"qmID_in,omitempty"`
	QmIdNotIn          []string                 `json:"qmID_not_in,omitempty"`
	QmIdLt             *string                  `json:"qmID_lt,omitempty"`
	QmIdLte            *string                  `json:"qmID_lte,omitempty"`
	QmIdGt             *string                  `json:"qmID_gt,omitempty"`
	QmIdGte            *string                  `json:"qmID_gte,omitempty"`
	QmIdContains       *string                  `json:"qmID_contains,omitempty"`
	QmIdNotContains    *string                  `json:"qmID_not_contains,omitempty"`
	QmIdStartsWith     *string                  `json:"qmID_starts_with,omitempty"`
	QmIdNotStartsWith  *string                  `json:"qmID_not_starts_with,omitempty"`
	QmIdEndsWith       *string                  `json:"qmID_ends_with,omitempty"`
	QmIdNotEndsWith    *string                  `json:"qmID_not_ends_with,omitempty"`
	Name               *string                  `json:"name,omitempty"`
	NameNot            *string                  `json:"name_not,omitempty"`
	NameIn             []string                 `json:"name_in,omitempty"`
	NameNotIn          []string                 `json:"name_not_in,omitempty"`
	NameLt             *string                  `json:"name_lt,omitempty"`
	NameLte            *string                  `json:"name_lte,omitempty"`
	NameGt             *string                  `json:"name_gt,omitempty"`
	NameGte            *string                  `json:"name_gte,omitempty"`
	NameContains       *string                  `json:"name_contains,omitempty"`
	NameNotContains    *string                  `json:"name_not_contains,omitempty"`
	NameStartsWith     *string                  `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string                  `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string                  `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string                  `json:"name_not_ends_with,omitempty"`
	Photo              *string                  `json:"photo,omitempty"`
	PhotoNot           *string                  `json:"photo_not,omitempty"`
	PhotoIn            []string                 `json:"photo_in,omitempty"`
	PhotoNotIn         []string                 `json:"photo_not_in,omitempty"`
	PhotoLt            *string                  `json:"photo_lt,omitempty"`
	PhotoLte           *string                  `json:"photo_lte,omitempty"`
	PhotoGt            *string                  `json:"photo_gt,omitempty"`
	PhotoGte           *string                  `json:"photo_gte,omitempty"`
	PhotoContains      *string                  `json:"photo_contains,omitempty"`
	PhotoNotContains   *string                  `json:"photo_not_contains,omitempty"`
	PhotoStartsWith    *string                  `json:"photo_starts_with,omitempty"`
	PhotoNotStartsWith *string                  `json:"photo_not_starts_with,omitempty"`
	PhotoEndsWith      *string                  `json:"photo_ends_with,omitempty"`
	PhotoNotEndsWith   *string                  `json:"photo_not_ends_with,omitempty"`
	Birthdate          *string                  `json:"birthdate,omitempty"`
	BirthdateNot       *string                  `json:"birthdate_not,omitempty"`
	BirthdateIn        []string                 `json:"birthdate_in,omitempty"`
	BirthdateNotIn     []string                 `json:"birthdate_not_in,omitempty"`
	BirthdateLt        *string                  `json:"birthdate_lt,omitempty"`
	BirthdateLte       *string                  `json:"birthdate_lte,omitempty"`
	BirthdateGt        *string                  `json:"birthdate_gt,omitempty"`
	BirthdateGte       *string                  `json:"birthdate_gte,omitempty"`
	And                []PersonScalarWhereInput `json:"AND,omitempty"`
	Or                 []PersonScalarWhereInput `json:"OR,omitempty"`
	Not                []PersonScalarWhereInput `json:"NOT,omitempty"`
}

type CostCreateOneInput struct {
	Create  *CostCreateInput      `json:"create,omitempty"`
	Connect *CostWhereUniqueInput `json:"connect,omitempty"`
}

type PersonUpdateManyWithWhereNestedInput struct {
	Where PersonScalarWhereInput    `json:"where"`
	Data  PersonUpdateManyDataInput `json:"data"`
}

type CurrencyCreateOneInput struct {
	Create  *CurrencyCreateInput      `json:"create,omitempty"`
	Connect *CurrencyWhereUniqueInput `json:"connect,omitempty"`
}

type PersonUpdateManyDataInput struct {
	QmId      *string                `json:"qmID,omitempty"`
	Name      *string                `json:"name,omitempty"`
	Photo     *string                `json:"photo,omitempty"`
	Birthdate *string                `json:"birthdate,omitempty"`
	Tags      *PersonUpdatetagsInput `json:"tags,omitempty"`
}

type PurchaseCreateOneInput struct {
	Create  *PurchaseCreateInput      `json:"create,omitempty"`
	Connect *PurchaseWhereUniqueInput `json:"connect,omitempty"`
}

type ExpertUpdateManyInput struct {
	Create     []ExpertCreateInput                      `json:"create,omitempty"`
	Update     []ExpertUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []ExpertUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []ExpertWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []ExpertWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []ExpertWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []ExpertWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []ExpertScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []ExpertUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type ProductEntryCreateManyInput struct {
	Create  []ProductEntryCreateInput      `json:"create,omitempty"`
	Connect []ProductEntryWhereUniqueInput `json:"connect,omitempty"`
}

type ExpertUpdateWithWhereUniqueNestedInput struct {
	Where ExpertWhereUniqueInput `json:"where"`
	Data  ExpertUpdateDataInput  `json:"data"`
}

type PaymentMethodCreateOneInput struct {
	Create  *PaymentMethodCreateInput      `json:"create,omitempty"`
	Connect *PaymentMethodWhereUniqueInput `json:"connect,omitempty"`
}

type ExpertUpsertWithWhereUniqueNestedInput struct {
	Where  ExpertWhereUniqueInput `json:"where"`
	Update ExpertUpdateDataInput  `json:"update"`
	Create ExpertCreateInput      `json:"create"`
}

type AttractionCreateOneInput struct {
	Create  *AttractionCreateInput      `json:"create,omitempty"`
	Connect *AttractionWhereUniqueInput `json:"connect,omitempty"`
}

type ExpertScalarWhereInput struct {
	ID                 *string                  `json:"id,omitempty"`
	IDNot              *string                  `json:"id_not,omitempty"`
	IDIn               []string                 `json:"id_in,omitempty"`
	IDNotIn            []string                 `json:"id_not_in,omitempty"`
	IDLt               *string                  `json:"id_lt,omitempty"`
	IDLte              *string                  `json:"id_lte,omitempty"`
	IDGt               *string                  `json:"id_gt,omitempty"`
	IDGte              *string                  `json:"id_gte,omitempty"`
	IDContains         *string                  `json:"id_contains,omitempty"`
	IDNotContains      *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                  `json:"createdAt,omitempty"`
	CreatedAtNot       *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                  `json:"updatedAt_gte,omitempty"`
	Alias              *string                  `json:"alias,omitempty"`
	AliasNot           *string                  `json:"alias_not,omitempty"`
	AliasIn            []string                 `json:"alias_in,omitempty"`
	AliasNotIn         []string                 `json:"alias_not_in,omitempty"`
	AliasLt            *string                  `json:"alias_lt,omitempty"`
	AliasLte           *string                  `json:"alias_lte,omitempty"`
	AliasGt            *string                  `json:"alias_gt,omitempty"`
	AliasGte           *string                  `json:"alias_gte,omitempty"`
	AliasContains      *string                  `json:"alias_contains,omitempty"`
	AliasNotContains   *string                  `json:"alias_not_contains,omitempty"`
	AliasStartsWith    *string                  `json:"alias_starts_with,omitempty"`
	AliasNotStartsWith *string                  `json:"alias_not_starts_with,omitempty"`
	AliasEndsWith      *string                  `json:"alias_ends_with,omitempty"`
	AliasNotEndsWith   *string                  `json:"alias_not_ends_with,omitempty"`
	And                []ExpertScalarWhereInput `json:"AND,omitempty"`
	Or                 []ExpertScalarWhereInput `json:"OR,omitempty"`
	Not                []ExpertScalarWhereInput `json:"NOT,omitempty"`
}

type TravelerCreateWithoutRegistryInput struct {
	ID                 *string                                `json:"id,omitempty"`
	Unregistered       *bool                                  `json:"unregistered,omitempty"`
	RegistrationTicket *ActionTicketCreateOneInput            `json:"registrationTicket,omitempty"`
	Person             PersonCreateOneInput                   `json:"person"`
	Username           *string                                `json:"username,omitempty"`
	Cards              *CreditCardCreateManyWithoutOwnerInput `json:"cards,omitempty"`
	Purchases          *PurchaseCreateManyInput               `json:"purchases,omitempty"`
	Passes             *PassCreateManyInput                   `json:"passes,omitempty"`
}

type ExpertUpdateManyWithWhereNestedInput struct {
	Where ExpertScalarWhereInput    `json:"where"`
	Data  ExpertUpdateManyDataInput `json:"data"`
}

type CreditCardCreateManyWithoutOwnerInput struct {
	Create  []CreditCardCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []CreditCardWhereUniqueInput        `json:"connect,omitempty"`
}

type ExpertUpdateManyDataInput struct {
	Alias *string `json:"alias,omitempty"`
}

type PurchaseCreateManyInput struct {
	Create  []PurchaseCreateInput      `json:"create,omitempty"`
	Connect []PurchaseWhereUniqueInput `json:"connect,omitempty"`
}

type OpeningHoursUpdateOneRequiredInput struct {
	Create  *OpeningHoursCreateInput       `json:"create,omitempty"`
	Update  *OpeningHoursUpdateDataInput   `json:"update,omitempty"`
	Upsert  *OpeningHoursUpsertNestedInput `json:"upsert,omitempty"`
	Connect *OpeningHoursWhereUniqueInput  `json:"connect,omitempty"`
}

type PassCreateInput struct {
	ID              *string                               `json:"id,omitempty"`
	Type            PassTypeCreateOneWithoutChildrenInput `json:"type"`
	Owner           PersonCreateOneInput                  `json:"owner"`
	PurchaseReceive *PurchaseCreateOneInput               `json:"purchaseReceive,omitempty"`
	ExpireAt        string                                `json:"expireAt"`
	State           *PassState                            `json:"state,omitempty"`
	Tickets         *TicketCreateManyWithoutParentInput   `json:"tickets,omitempty"`
}

type PlaceUpsertWithWhereUniqueWithoutRoutesInput struct {
	Where  PlaceWhereUniqueInput             `json:"where"`
	Update PlaceUpdateWithoutRoutesDataInput `json:"update"`
	Create PlaceCreateWithoutRoutesInput     `json:"create"`
}

type TicketCreateWithoutParentInput struct {
	ID            *string                  `json:"id,omitempty"`
	Attraction    AttractionCreateOneInput `json:"attraction"`
	Description   *TextCreateOneInput      `json:"description,omitempty"`
	AvailableTime *TextCreateOneInput      `json:"availableTime,omitempty"`
	MaxUses       int32                    `json:"maxUses"`
	Visited       bool                     `json:"visited"`
	Finished      bool                     `json:"finished"`
	State         TicketState              `json:"state"`
}

type PlaceScalarWhereInput struct {
	ID                            *string                 `json:"id,omitempty"`
	IDNot                         *string                 `json:"id_not,omitempty"`
	IDIn                          []string                `json:"id_in,omitempty"`
	IDNotIn                       []string                `json:"id_not_in,omitempty"`
	IDLt                          *string                 `json:"id_lt,omitempty"`
	IDLte                         *string                 `json:"id_lte,omitempty"`
	IDGt                          *string                 `json:"id_gt,omitempty"`
	IDGte                         *string                 `json:"id_gte,omitempty"`
	IDContains                    *string                 `json:"id_contains,omitempty"`
	IDNotContains                 *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith                  *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith               *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith                    *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith                 *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt                     *string                 `json:"createdAt,omitempty"`
	CreatedAtNot                  *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn                   []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                   *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte                  *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt                   *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte                  *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt                     *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot                  *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                   []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                   *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                  *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                   *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                  *string                 `json:"updatedAt_gte,omitempty"`
	Name                          *string                 `json:"name,omitempty"`
	NameNot                       *string                 `json:"name_not,omitempty"`
	NameIn                        []string                `json:"name_in,omitempty"`
	NameNotIn                     []string                `json:"name_not_in,omitempty"`
	NameLt                        *string                 `json:"name_lt,omitempty"`
	NameLte                       *string                 `json:"name_lte,omitempty"`
	NameGt                        *string                 `json:"name_gt,omitempty"`
	NameGte                       *string                 `json:"name_gte,omitempty"`
	NameContains                  *string                 `json:"name_contains,omitempty"`
	NameNotContains               *string                 `json:"name_not_contains,omitempty"`
	NameStartsWith                *string                 `json:"name_starts_with,omitempty"`
	NameNotStartsWith             *string                 `json:"name_not_starts_with,omitempty"`
	NameEndsWith                  *string                 `json:"name_ends_with,omitempty"`
	NameNotEndsWith               *string                 `json:"name_not_ends_with,omitempty"`
	ShortName                     *string                 `json:"shortName,omitempty"`
	ShortNameNot                  *string                 `json:"shortName_not,omitempty"`
	ShortNameIn                   []string                `json:"shortName_in,omitempty"`
	ShortNameNotIn                []string                `json:"shortName_not_in,omitempty"`
	ShortNameLt                   *string                 `json:"shortName_lt,omitempty"`
	ShortNameLte                  *string                 `json:"shortName_lte,omitempty"`
	ShortNameGt                   *string                 `json:"shortName_gt,omitempty"`
	ShortNameGte                  *string                 `json:"shortName_gte,omitempty"`
	ShortNameContains             *string                 `json:"shortName_contains,omitempty"`
	ShortNameNotContains          *string                 `json:"shortName_not_contains,omitempty"`
	ShortNameStartsWith           *string                 `json:"shortName_starts_with,omitempty"`
	ShortNameNotStartsWith        *string                 `json:"shortName_not_starts_with,omitempty"`
	ShortNameEndsWith             *string                 `json:"shortName_ends_with,omitempty"`
	ShortNameNotEndsWith          *string                 `json:"shortName_not_ends_with,omitempty"`
	Address                       *string                 `json:"address,omitempty"`
	AddressNot                    *string                 `json:"address_not,omitempty"`
	AddressIn                     []string                `json:"address_in,omitempty"`
	AddressNotIn                  []string                `json:"address_not_in,omitempty"`
	AddressLt                     *string                 `json:"address_lt,omitempty"`
	AddressLte                    *string                 `json:"address_lte,omitempty"`
	AddressGt                     *string                 `json:"address_gt,omitempty"`
	AddressGte                    *string                 `json:"address_gte,omitempty"`
	AddressContains               *string                 `json:"address_contains,omitempty"`
	AddressNotContains            *string                 `json:"address_not_contains,omitempty"`
	AddressStartsWith             *string                 `json:"address_starts_with,omitempty"`
	AddressNotStartsWith          *string                 `json:"address_not_starts_with,omitempty"`
	AddressEndsWith               *string                 `json:"address_ends_with,omitempty"`
	AddressNotEndsWith            *string                 `json:"address_not_ends_with,omitempty"`
	GoogleLink                    *string                 `json:"googleLink,omitempty"`
	GoogleLinkNot                 *string                 `json:"googleLink_not,omitempty"`
	GoogleLinkIn                  []string                `json:"googleLink_in,omitempty"`
	GoogleLinkNotIn               []string                `json:"googleLink_not_in,omitempty"`
	GoogleLinkLt                  *string                 `json:"googleLink_lt,omitempty"`
	GoogleLinkLte                 *string                 `json:"googleLink_lte,omitempty"`
	GoogleLinkGt                  *string                 `json:"googleLink_gt,omitempty"`
	GoogleLinkGte                 *string                 `json:"googleLink_gte,omitempty"`
	GoogleLinkContains            *string                 `json:"googleLink_contains,omitempty"`
	GoogleLinkNotContains         *string                 `json:"googleLink_not_contains,omitempty"`
	GoogleLinkStartsWith          *string                 `json:"googleLink_starts_with,omitempty"`
	GoogleLinkNotStartsWith       *string                 `json:"googleLink_not_starts_with,omitempty"`
	GoogleLinkEndsWith            *string                 `json:"googleLink_ends_with,omitempty"`
	GoogleLinkNotEndsWith         *string                 `json:"googleLink_not_ends_with,omitempty"`
	Website                       *string                 `json:"website,omitempty"`
	WebsiteNot                    *string                 `json:"website_not,omitempty"`
	WebsiteIn                     []string                `json:"website_in,omitempty"`
	WebsiteNotIn                  []string                `json:"website_not_in,omitempty"`
	WebsiteLt                     *string                 `json:"website_lt,omitempty"`
	WebsiteLte                    *string                 `json:"website_lte,omitempty"`
	WebsiteGt                     *string                 `json:"website_gt,omitempty"`
	WebsiteGte                    *string                 `json:"website_gte,omitempty"`
	WebsiteContains               *string                 `json:"website_contains,omitempty"`
	WebsiteNotContains            *string                 `json:"website_not_contains,omitempty"`
	WebsiteStartsWith             *string                 `json:"website_starts_with,omitempty"`
	WebsiteNotStartsWith          *string                 `json:"website_not_starts_with,omitempty"`
	WebsiteEndsWith               *string                 `json:"website_ends_with,omitempty"`
	WebsiteNotEndsWith            *string                 `json:"website_not_ends_with,omitempty"`
	Type                          *ExperienceType         `json:"type,omitempty"`
	TypeNot                       *ExperienceType         `json:"type_not,omitempty"`
	TypeIn                        []ExperienceType        `json:"type_in,omitempty"`
	TypeNotIn                     []ExperienceType        `json:"type_not_in,omitempty"`
	Popularity                    *float64                `json:"popularity,omitempty"`
	PopularityNot                 *float64                `json:"popularity_not,omitempty"`
	PopularityIn                  []float64               `json:"popularity_in,omitempty"`
	PopularityNotIn               []float64               `json:"popularity_not_in,omitempty"`
	PopularityLt                  *float64                `json:"popularity_lt,omitempty"`
	PopularityLte                 *float64                `json:"popularity_lte,omitempty"`
	PopularityGt                  *float64                `json:"popularity_gt,omitempty"`
	PopularityGte                 *float64                `json:"popularity_gte,omitempty"`
	ProviderWeb                   *string                 `json:"providerWeb,omitempty"`
	ProviderWebNot                *string                 `json:"providerWeb_not,omitempty"`
	ProviderWebIn                 []string                `json:"providerWeb_in,omitempty"`
	ProviderWebNotIn              []string                `json:"providerWeb_not_in,omitempty"`
	ProviderWebLt                 *string                 `json:"providerWeb_lt,omitempty"`
	ProviderWebLte                *string                 `json:"providerWeb_lte,omitempty"`
	ProviderWebGt                 *string                 `json:"providerWeb_gt,omitempty"`
	ProviderWebGte                *string                 `json:"providerWeb_gte,omitempty"`
	ProviderWebContains           *string                 `json:"providerWeb_contains,omitempty"`
	ProviderWebNotContains        *string                 `json:"providerWeb_not_contains,omitempty"`
	ProviderWebStartsWith         *string                 `json:"providerWeb_starts_with,omitempty"`
	ProviderWebNotStartsWith      *string                 `json:"providerWeb_not_starts_with,omitempty"`
	ProviderWebEndsWith           *string                 `json:"providerWeb_ends_with,omitempty"`
	ProviderWebNotEndsWith        *string                 `json:"providerWeb_not_ends_with,omitempty"`
	ContactPhone                  *string                 `json:"contactPhone,omitempty"`
	ContactPhoneNot               *string                 `json:"contactPhone_not,omitempty"`
	ContactPhoneIn                []string                `json:"contactPhone_in,omitempty"`
	ContactPhoneNotIn             []string                `json:"contactPhone_not_in,omitempty"`
	ContactPhoneLt                *string                 `json:"contactPhone_lt,omitempty"`
	ContactPhoneLte               *string                 `json:"contactPhone_lte,omitempty"`
	ContactPhoneGt                *string                 `json:"contactPhone_gt,omitempty"`
	ContactPhoneGte               *string                 `json:"contactPhone_gte,omitempty"`
	ContactPhoneContains          *string                 `json:"contactPhone_contains,omitempty"`
	ContactPhoneNotContains       *string                 `json:"contactPhone_not_contains,omitempty"`
	ContactPhoneStartsWith        *string                 `json:"contactPhone_starts_with,omitempty"`
	ContactPhoneNotStartsWith     *string                 `json:"contactPhone_not_starts_with,omitempty"`
	ContactPhoneEndsWith          *string                 `json:"contactPhone_ends_with,omitempty"`
	ContactPhoneNotEndsWith       *string                 `json:"contactPhone_not_ends_with,omitempty"`
	ContactEmail                  *string                 `json:"contactEmail,omitempty"`
	ContactEmailNot               *string                 `json:"contactEmail_not,omitempty"`
	ContactEmailIn                []string                `json:"contactEmail_in,omitempty"`
	ContactEmailNotIn             []string                `json:"contactEmail_not_in,omitempty"`
	ContactEmailLt                *string                 `json:"contactEmail_lt,omitempty"`
	ContactEmailLte               *string                 `json:"contactEmail_lte,omitempty"`
	ContactEmailGt                *string                 `json:"contactEmail_gt,omitempty"`
	ContactEmailGte               *string                 `json:"contactEmail_gte,omitempty"`
	ContactEmailContains          *string                 `json:"contactEmail_contains,omitempty"`
	ContactEmailNotContains       *string                 `json:"contactEmail_not_contains,omitempty"`
	ContactEmailStartsWith        *string                 `json:"contactEmail_starts_with,omitempty"`
	ContactEmailNotStartsWith     *string                 `json:"contactEmail_not_starts_with,omitempty"`
	ContactEmailEndsWith          *string                 `json:"contactEmail_ends_with,omitempty"`
	ContactEmailNotEndsWith       *string                 `json:"contactEmail_not_ends_with,omitempty"`
	AddressReference              *string                 `json:"addressReference,omitempty"`
	AddressReferenceNot           *string                 `json:"addressReference_not,omitempty"`
	AddressReferenceIn            []string                `json:"addressReference_in,omitempty"`
	AddressReferenceNotIn         []string                `json:"addressReference_not_in,omitempty"`
	AddressReferenceLt            *string                 `json:"addressReference_lt,omitempty"`
	AddressReferenceLte           *string                 `json:"addressReference_lte,omitempty"`
	AddressReferenceGt            *string                 `json:"addressReference_gt,omitempty"`
	AddressReferenceGte           *string                 `json:"addressReference_gte,omitempty"`
	AddressReferenceContains      *string                 `json:"addressReference_contains,omitempty"`
	AddressReferenceNotContains   *string                 `json:"addressReference_not_contains,omitempty"`
	AddressReferenceStartsWith    *string                 `json:"addressReference_starts_with,omitempty"`
	AddressReferenceNotStartsWith *string                 `json:"addressReference_not_starts_with,omitempty"`
	AddressReferenceEndsWith      *string                 `json:"addressReference_ends_with,omitempty"`
	AddressReferenceNotEndsWith   *string                 `json:"addressReference_not_ends_with,omitempty"`
	And                           []PlaceScalarWhereInput `json:"AND,omitempty"`
	Or                            []PlaceScalarWhereInput `json:"OR,omitempty"`
	Not                           []PlaceScalarWhereInput `json:"NOT,omitempty"`
}

type FaqCreateWithoutAttractionInput struct {
	ID      *string                            `json:"id,omitempty"`
	Entries *FaqEntryCreateManyWithoutFaqInput `json:"entries,omitempty"`
}

type PlaceUpdateManyWithWhereNestedInput struct {
	Where PlaceScalarWhereInput    `json:"where"`
	Data  PlaceUpdateManyDataInput `json:"data"`
}

type FaqEntryCreateWithoutFaqInput struct {
	ID       *string            `json:"id,omitempty"`
	Question TextCreateOneInput `json:"question"`
	Answer   TextCreateOneInput `json:"answer"`
}

type PlaceUpdateManyDataInput struct {
	Name             *string                     `json:"name,omitempty"`
	ShortName        *string                     `json:"shortName,omitempty"`
	Address          *string                     `json:"address,omitempty"`
	GoogleLink       *string                     `json:"googleLink,omitempty"`
	Website          *string                     `json:"website,omitempty"`
	Type             *ExperienceType             `json:"type,omitempty"`
	ExtraTypes       *PlaceUpdateextraTypesInput `json:"extraTypes,omitempty"`
	Tags             *PlaceUpdatetagsInput       `json:"tags,omitempty"`
	Popularity       *float64                    `json:"popularity,omitempty"`
	ProviderWeb      *string                     `json:"providerWeb,omitempty"`
	ContactPhone     *string                     `json:"contactPhone,omitempty"`
	ContactEmail     *string                     `json:"contactEmail,omitempty"`
	AddressReference *string                     `json:"addressReference,omitempty"`
}

type AttractionCreatetypeInput struct {
	Set []ExperienceType `json:"set,omitempty"`
}

type RouteUpsertWithoutLinkedStoryInput struct {
	Update RouteUpdateWithoutLinkedStoryDataInput `json:"update"`
	Create RouteCreateWithoutLinkedStoryInput     `json:"create"`
}

type PlaceCreateInput struct {
	ID               *string                            `json:"id,omitempty"`
	Name             string                             `json:"name"`
	ShortName        *string                            `json:"shortName,omitempty"`
	Description      TextCreateOneInput                 `json:"description"`
	ShortDescription *TextCreateOneInput                `json:"shortDescription,omitempty"`
	Address          string                             `json:"address"`
	Location         LocationCreateOneInput             `json:"location"`
	GoogleLink       *string                            `json:"googleLink,omitempty"`
	Website          *string                            `json:"website,omitempty"`
	Type             *ExperienceType                    `json:"type,omitempty"`
	ExtraTypes       *PlaceCreateextraTypesInput        `json:"extraTypes,omitempty"`
	Routes           *RouteCreateManyWithoutPlacesInput `json:"routes,omitempty"`
	Reviews          *PersonReviewsCreateManyInput      `json:"reviews,omitempty"`
	Tags             *PlaceCreatetagsInput              `json:"tags,omitempty"`
	LikedBy          *PersonCreateManyInput             `json:"likedBy,omitempty"`
	Popularity       *float64                           `json:"popularity,omitempty"`
	Ambassadors      *ExpertCreateManyInput             `json:"ambassadors,omitempty"`
	ProviderWeb      *string                            `json:"providerWeb,omitempty"`
	ContactPhone     *string                            `json:"contactPhone,omitempty"`
	ContactEmail     *string                            `json:"contactEmail,omitempty"`
	AddressReference *string                            `json:"addressReference,omitempty"`
	OpeningHours     OpeningHoursCreateOneInput         `json:"openingHours"`
}

type StoryUpsertWithWhereUniqueWithoutAuthorInput struct {
	Where  StoryWhereUniqueInput             `json:"where"`
	Update StoryUpdateWithoutAuthorDataInput `json:"update"`
	Create StoryCreateWithoutAuthorInput     `json:"create"`
}

type RouteCreateManyWithoutPlacesInput struct {
	Create  []RouteCreateWithoutPlacesInput `json:"create,omitempty"`
	Connect []RouteWhereUniqueInput         `json:"connect,omitempty"`
}

type StoryScalarWhereInput struct {
	ID                          *string                 `json:"id,omitempty"`
	IDNot                       *string                 `json:"id_not,omitempty"`
	IDIn                        []string                `json:"id_in,omitempty"`
	IDNotIn                     []string                `json:"id_not_in,omitempty"`
	IDLt                        *string                 `json:"id_lt,omitempty"`
	IDLte                       *string                 `json:"id_lte,omitempty"`
	IDGt                        *string                 `json:"id_gt,omitempty"`
	IDGte                       *string                 `json:"id_gte,omitempty"`
	IDContains                  *string                 `json:"id_contains,omitempty"`
	IDNotContains               *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt                   *string                 `json:"createdAt,omitempty"`
	CreatedAtNot                *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string                 `json:"updatedAt_gte,omitempty"`
	Type                        *StoryType              `json:"type,omitempty"`
	TypeNot                     *StoryType              `json:"type_not,omitempty"`
	TypeIn                      []StoryType             `json:"type_in,omitempty"`
	TypeNotIn                   []StoryType             `json:"type_not_in,omitempty"`
	PodcastLink                 *string                 `json:"podcastLink,omitempty"`
	PodcastLinkNot              *string                 `json:"podcastLink_not,omitempty"`
	PodcastLinkIn               []string                `json:"podcastLink_in,omitempty"`
	PodcastLinkNotIn            []string                `json:"podcastLink_not_in,omitempty"`
	PodcastLinkLt               *string                 `json:"podcastLink_lt,omitempty"`
	PodcastLinkLte              *string                 `json:"podcastLink_lte,omitempty"`
	PodcastLinkGt               *string                 `json:"podcastLink_gt,omitempty"`
	PodcastLinkGte              *string                 `json:"podcastLink_gte,omitempty"`
	PodcastLinkContains         *string                 `json:"podcastLink_contains,omitempty"`
	PodcastLinkNotContains      *string                 `json:"podcastLink_not_contains,omitempty"`
	PodcastLinkStartsWith       *string                 `json:"podcastLink_starts_with,omitempty"`
	PodcastLinkNotStartsWith    *string                 `json:"podcastLink_not_starts_with,omitempty"`
	PodcastLinkEndsWith         *string                 `json:"podcastLink_ends_with,omitempty"`
	PodcastLinkNotEndsWith      *string                 `json:"podcastLink_not_ends_with,omitempty"`
	AudioStream                 *string                 `json:"audioStream,omitempty"`
	AudioStreamNot              *string                 `json:"audioStream_not,omitempty"`
	AudioStreamIn               []string                `json:"audioStream_in,omitempty"`
	AudioStreamNotIn            []string                `json:"audioStream_not_in,omitempty"`
	AudioStreamLt               *string                 `json:"audioStream_lt,omitempty"`
	AudioStreamLte              *string                 `json:"audioStream_lte,omitempty"`
	AudioStreamGt               *string                 `json:"audioStream_gt,omitempty"`
	AudioStreamGte              *string                 `json:"audioStream_gte,omitempty"`
	AudioStreamContains         *string                 `json:"audioStream_contains,omitempty"`
	AudioStreamNotContains      *string                 `json:"audioStream_not_contains,omitempty"`
	AudioStreamStartsWith       *string                 `json:"audioStream_starts_with,omitempty"`
	AudioStreamNotStartsWith    *string                 `json:"audioStream_not_starts_with,omitempty"`
	AudioStreamEndsWith         *string                 `json:"audioStream_ends_with,omitempty"`
	AudioStreamNotEndsWith      *string                 `json:"audioStream_not_ends_with,omitempty"`
	PrincipalImage              *string                 `json:"principalImage,omitempty"`
	PrincipalImageNot           *string                 `json:"principalImage_not,omitempty"`
	PrincipalImageIn            []string                `json:"principalImage_in,omitempty"`
	PrincipalImageNotIn         []string                `json:"principalImage_not_in,omitempty"`
	PrincipalImageLt            *string                 `json:"principalImage_lt,omitempty"`
	PrincipalImageLte           *string                 `json:"principalImage_lte,omitempty"`
	PrincipalImageGt            *string                 `json:"principalImage_gt,omitempty"`
	PrincipalImageGte           *string                 `json:"principalImage_gte,omitempty"`
	PrincipalImageContains      *string                 `json:"principalImage_contains,omitempty"`
	PrincipalImageNotContains   *string                 `json:"principalImage_not_contains,omitempty"`
	PrincipalImageStartsWith    *string                 `json:"principalImage_starts_with,omitempty"`
	PrincipalImageNotStartsWith *string                 `json:"principalImage_not_starts_with,omitempty"`
	PrincipalImageEndsWith      *string                 `json:"principalImage_ends_with,omitempty"`
	PrincipalImageNotEndsWith   *string                 `json:"principalImage_not_ends_with,omitempty"`
	Likes                       *int32                  `json:"likes,omitempty"`
	LikesNot                    *int32                  `json:"likes_not,omitempty"`
	LikesIn                     []int32                 `json:"likes_in,omitempty"`
	LikesNotIn                  []int32                 `json:"likes_not_in,omitempty"`
	LikesLt                     *int32                  `json:"likes_lt,omitempty"`
	LikesLte                    *int32                  `json:"likes_lte,omitempty"`
	LikesGt                     *int32                  `json:"likes_gt,omitempty"`
	LikesGte                    *int32                  `json:"likes_gte,omitempty"`
	Views                       *int32                  `json:"views,omitempty"`
	ViewsNot                    *int32                  `json:"views_not,omitempty"`
	ViewsIn                     []int32                 `json:"views_in,omitempty"`
	ViewsNotIn                  []int32                 `json:"views_not_in,omitempty"`
	ViewsLt                     *int32                  `json:"views_lt,omitempty"`
	ViewsLte                    *int32                  `json:"views_lte,omitempty"`
	ViewsGt                     *int32                  `json:"views_gt,omitempty"`
	ViewsGte                    *int32                  `json:"views_gte,omitempty"`
	And                         []StoryScalarWhereInput `json:"AND,omitempty"`
	Or                          []StoryScalarWhereInput `json:"OR,omitempty"`
	Not                         []StoryScalarWhereInput `json:"NOT,omitempty"`
}

type RouteCreateextraTypesInput struct {
	Set []ExperienceType `json:"set,omitempty"`
}

type StoryUpdateManyWithWhereNestedInput struct {
	Where StoryScalarWhereInput    `json:"where"`
	Data  StoryUpdateManyDataInput `json:"data"`
}

type ExpertCreateInput struct {
	ID      *string                            `json:"id,omitempty"`
	Person  PersonCreateOneInput               `json:"person"`
	Alias   string                             `json:"alias"`
	Stories *StoryCreateManyWithoutAuthorInput `json:"stories,omitempty"`
}

type StoryUpdateManyDataInput struct {
	Type           *StoryType            `json:"type,omitempty"`
	Tags           *StoryUpdatetagsInput `json:"tags,omitempty"`
	PodcastLink    *string               `json:"podcastLink,omitempty"`
	AudioStream    *string               `json:"audioStream,omitempty"`
	PrincipalImage *string               `json:"principalImage,omitempty"`
	Likes          *int32                `json:"likes,omitempty"`
	Views          *int32                `json:"views,omitempty"`
}

type StoryCreateWithoutAuthorInput struct {
	ID             *string                                `json:"id,omitempty"`
	Type           StoryType                              `json:"type"`
	Tags           *StoryCreatetagsInput                  `json:"tags,omitempty"`
	PodcastLink    *string                                `json:"podcastLink,omitempty"`
	AudioStream    *string                                `json:"audioStream,omitempty"`
	PrincipalImage string                                 `json:"principalImage"`
	Title          TextCreateOneInput                     `json:"title"`
	Body           TextCreateOneInput                     `json:"body"`
	Likes          int32                                  `json:"likes"`
	Views          int32                                  `json:"views"`
	Reviews        *PersonReviewsCreateManyInput          `json:"reviews,omitempty"`
	LinkedRoute    *RouteCreateOneWithoutLinkedStoryInput `json:"linkedRoute,omitempty"`
}

type ExpertUpsertNestedInput struct {
	Update ExpertUpdateDataInput `json:"update"`
	Create ExpertCreateInput     `json:"create"`
}

type PersonReviewsCreateManyInput struct {
	Create  []PersonReviewsCreateInput      `json:"create,omitempty"`
	Connect []PersonReviewsWhereUniqueInput `json:"connect,omitempty"`
}

type StoryUpdateOneWithoutLinkedRouteInput struct {
	Create     *StoryCreateWithoutLinkedRouteInput     `json:"create,omitempty"`
	Update     *StoryUpdateWithoutLinkedRouteDataInput `json:"update,omitempty"`
	Upsert     *StoryUpsertWithoutLinkedRouteInput     `json:"upsert,omitempty"`
	Delete     *bool                                   `json:"delete,omitempty"`
	Disconnect *bool                                   `json:"disconnect,omitempty"`
	Connect    *StoryWhereUniqueInput                  `json:"connect,omitempty"`
}

type RouteCreateOneWithoutLinkedStoryInput struct {
	Create  *RouteCreateWithoutLinkedStoryInput `json:"create,omitempty"`
	Connect *RouteWhereUniqueInput              `json:"connect,omitempty"`
}

type StoryUpdateWithoutLinkedRouteDataInput struct {
	Author         *ExpertUpdateOneRequiredWithoutStoriesInput `json:"author,omitempty"`
	Type           *StoryType                                  `json:"type,omitempty"`
	Tags           *StoryUpdatetagsInput                       `json:"tags,omitempty"`
	PodcastLink    *string                                     `json:"podcastLink,omitempty"`
	AudioStream    *string                                     `json:"audioStream,omitempty"`
	PrincipalImage *string                                     `json:"principalImage,omitempty"`
	Title          *TextUpdateOneRequiredInput                 `json:"title,omitempty"`
	Body           *TextUpdateOneRequiredInput                 `json:"body,omitempty"`
	Likes          *int32                                      `json:"likes,omitempty"`
	Views          *int32                                      `json:"views,omitempty"`
	Reviews        *PersonReviewsUpdateManyInput               `json:"reviews,omitempty"`
}

type TravelerSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *TravelerWhereInput              `json:"node,omitempty"`
	And                        []TravelerSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TravelerSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TravelerSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ExpertUpdateOneRequiredWithoutStoriesInput struct {
	Create  *ExpertCreateWithoutStoriesInput     `json:"create,omitempty"`
	Update  *ExpertUpdateWithoutStoriesDataInput `json:"update,omitempty"`
	Upsert  *ExpertUpsertWithoutStoriesInput     `json:"upsert,omitempty"`
	Connect *ExpertWhereUniqueInput              `json:"connect,omitempty"`
}

type StorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *StoryWhereInput              `json:"node,omitempty"`
	And                        []StorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []StorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []StorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type ExpertUpdateWithoutStoriesDataInput struct {
	Person *PersonUpdateOneRequiredInput `json:"person,omitempty"`
	Alias  *string                       `json:"alias,omitempty"`
}

type PlaceSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *PlaceWhereInput              `json:"node,omitempty"`
	And                        []PlaceSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PlaceSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PlaceSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ExpertUpsertWithoutStoriesInput struct {
	Update ExpertUpdateWithoutStoriesDataInput `json:"update"`
	Create ExpertCreateWithoutStoriesInput     `json:"create"`
}

type PersonReviewsSubscriptionWhereInput struct {
	MutationIn                 []MutationType                        `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                               `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                              `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                              `json:"updatedFields_contains_some,omitempty"`
	Node                       *PersonReviewsWhereInput              `json:"node,omitempty"`
	And                        []PersonReviewsSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PersonReviewsSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PersonReviewsSubscriptionWhereInput `json:"NOT,omitempty"`
}

type StoryUpsertWithoutLinkedRouteInput struct {
	Update StoryUpdateWithoutLinkedRouteDataInput `json:"update"`
	Create StoryCreateWithoutLinkedRouteInput     `json:"create"`
}

type PassSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *PassWhereInput              `json:"node,omitempty"`
	And                        []PassSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PassSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PassSubscriptionWhereInput `json:"NOT,omitempty"`
}

type RouteUpsertWithWhereUniqueWithoutPlacesInput struct {
	Where  RouteWhereUniqueInput             `json:"where"`
	Update RouteUpdateWithoutPlacesDataInput `json:"update"`
	Create RouteCreateWithoutPlacesInput     `json:"create"`
}

type LimaContactSubscriptionWhereInput struct {
	MutationIn                 []MutationType                      `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                             `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                            `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                            `json:"updatedFields_contains_some,omitempty"`
	Node                       *LimaContactWhereInput              `json:"node,omitempty"`
	And                        []LimaContactSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []LimaContactSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []LimaContactSubscriptionWhereInput `json:"NOT,omitempty"`
}

type RouteScalarWhereInput struct {
	ID                 *string                 `json:"id,omitempty"`
	IDNot              *string                 `json:"id_not,omitempty"`
	IDIn               []string                `json:"id_in,omitempty"`
	IDNotIn            []string                `json:"id_not_in,omitempty"`
	IDLt               *string                 `json:"id_lt,omitempty"`
	IDLte              *string                 `json:"id_lte,omitempty"`
	IDGt               *string                 `json:"id_gt,omitempty"`
	IDGte              *string                 `json:"id_gte,omitempty"`
	IDContains         *string                 `json:"id_contains,omitempty"`
	IDNotContains      *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                 `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                 `json:"createdAt,omitempty"`
	CreatedAtNot       *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                 `json:"updatedAt_gte,omitempty"`
	Name               *string                 `json:"name,omitempty"`
	NameNot            *string                 `json:"name_not,omitempty"`
	NameIn             []string                `json:"name_in,omitempty"`
	NameNotIn          []string                `json:"name_not_in,omitempty"`
	NameLt             *string                 `json:"name_lt,omitempty"`
	NameLte            *string                 `json:"name_lte,omitempty"`
	NameGt             *string                 `json:"name_gt,omitempty"`
	NameGte            *string                 `json:"name_gte,omitempty"`
	NameContains       *string                 `json:"name_contains,omitempty"`
	NameNotContains    *string                 `json:"name_not_contains,omitempty"`
	NameStartsWith     *string                 `json:"name_starts_with,omitempty"`
	NameNotStartsWith  *string                 `json:"name_not_starts_with,omitempty"`
	NameEndsWith       *string                 `json:"name_ends_with,omitempty"`
	NameNotEndsWith    *string                 `json:"name_not_ends_with,omitempty"`
	Image              *string                 `json:"image,omitempty"`
	ImageNot           *string                 `json:"image_not,omitempty"`
	ImageIn            []string                `json:"image_in,omitempty"`
	ImageNotIn         []string                `json:"image_not_in,omitempty"`
	ImageLt            *string                 `json:"image_lt,omitempty"`
	ImageLte           *string                 `json:"image_lte,omitempty"`
	ImageGt            *string                 `json:"image_gt,omitempty"`
	ImageGte           *string                 `json:"image_gte,omitempty"`
	ImageContains      *string                 `json:"image_contains,omitempty"`
	ImageNotContains   *string                 `json:"image_not_contains,omitempty"`
	ImageStartsWith    *string                 `json:"image_starts_with,omitempty"`
	ImageNotStartsWith *string                 `json:"image_not_starts_with,omitempty"`
	ImageEndsWith      *string                 `json:"image_ends_with,omitempty"`
	ImageNotEndsWith   *string                 `json:"image_not_ends_with,omitempty"`
	Type               *ExperienceType         `json:"type,omitempty"`
	TypeNot            *ExperienceType         `json:"type_not,omitempty"`
	TypeIn             []ExperienceType        `json:"type_in,omitempty"`
	TypeNotIn          []ExperienceType        `json:"type_not_in,omitempty"`
	Popularity         *float64                `json:"popularity,omitempty"`
	PopularityNot      *float64                `json:"popularity_not,omitempty"`
	PopularityIn       []float64               `json:"popularity_in,omitempty"`
	PopularityNotIn    []float64               `json:"popularity_not_in,omitempty"`
	PopularityLt       *float64                `json:"popularity_lt,omitempty"`
	PopularityLte      *float64                `json:"popularity_lte,omitempty"`
	PopularityGt       *float64                `json:"popularity_gt,omitempty"`
	PopularityGte      *float64                `json:"popularity_gte,omitempty"`
	Color              *string                 `json:"color,omitempty"`
	ColorNot           *string                 `json:"color_not,omitempty"`
	ColorIn            []string                `json:"color_in,omitempty"`
	ColorNotIn         []string                `json:"color_not_in,omitempty"`
	ColorLt            *string                 `json:"color_lt,omitempty"`
	ColorLte           *string                 `json:"color_lte,omitempty"`
	ColorGt            *string                 `json:"color_gt,omitempty"`
	ColorGte           *string                 `json:"color_gte,omitempty"`
	ColorContains      *string                 `json:"color_contains,omitempty"`
	ColorNotContains   *string                 `json:"color_not_contains,omitempty"`
	ColorStartsWith    *string                 `json:"color_starts_with,omitempty"`
	ColorNotStartsWith *string                 `json:"color_not_starts_with,omitempty"`
	ColorEndsWith      *string                 `json:"color_ends_with,omitempty"`
	ColorNotEndsWith   *string                 `json:"color_not_ends_with,omitempty"`
	And                []RouteScalarWhereInput `json:"AND,omitempty"`
	Or                 []RouteScalarWhereInput `json:"OR,omitempty"`
	Not                []RouteScalarWhereInput `json:"NOT,omitempty"`
}

type FeatureSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *FeatureWhereInput              `json:"node,omitempty"`
	And                        []FeatureSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []FeatureSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []FeatureSubscriptionWhereInput `json:"NOT,omitempty"`
}

type RouteUpdateManyWithWhereNestedInput struct {
	Where RouteScalarWhereInput    `json:"where"`
	Data  RouteUpdateManyDataInput `json:"data"`
}

type EmailChannelWhereInput struct {
	ID                       *string                  `json:"id,omitempty"`
	IDNot                    *string                  `json:"id_not,omitempty"`
	IDIn                     []string                 `json:"id_in,omitempty"`
	IDNotIn                  []string                 `json:"id_not_in,omitempty"`
	IDLt                     *string                  `json:"id_lt,omitempty"`
	IDLte                    *string                  `json:"id_lte,omitempty"`
	IDGt                     *string                  `json:"id_gt,omitempty"`
	IDGte                    *string                  `json:"id_gte,omitempty"`
	IDContains               *string                  `json:"id_contains,omitempty"`
	IDNotContains            *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string                  `json:"createdAt,omitempty"`
	CreatedAtNot             *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                  `json:"updatedAt_gte,omitempty"`
	Person                   *PersonWhereInput        `json:"person,omitempty"`
	IsMain                   *bool                    `json:"isMain,omitempty"`
	IsMainNot                *bool                    `json:"isMain_not,omitempty"`
	DisplayName              *string                  `json:"displayName,omitempty"`
	DisplayNameNot           *string                  `json:"displayName_not,omitempty"`
	DisplayNameIn            []string                 `json:"displayName_in,omitempty"`
	DisplayNameNotIn         []string                 `json:"displayName_not_in,omitempty"`
	DisplayNameLt            *string                  `json:"displayName_lt,omitempty"`
	DisplayNameLte           *string                  `json:"displayName_lte,omitempty"`
	DisplayNameGt            *string                  `json:"displayName_gt,omitempty"`
	DisplayNameGte           *string                  `json:"displayName_gte,omitempty"`
	DisplayNameContains      *string                  `json:"displayName_contains,omitempty"`
	DisplayNameNotContains   *string                  `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith    *string                  `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith *string                  `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith      *string                  `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith   *string                  `json:"displayName_not_ends_with,omitempty"`
	Valid                    *bool                    `json:"valid,omitempty"`
	ValidNot                 *bool                    `json:"valid_not,omitempty"`
	Value                    *string                  `json:"value,omitempty"`
	ValueNot                 *string                  `json:"value_not,omitempty"`
	ValueIn                  []string                 `json:"value_in,omitempty"`
	ValueNotIn               []string                 `json:"value_not_in,omitempty"`
	ValueLt                  *string                  `json:"value_lt,omitempty"`
	ValueLte                 *string                  `json:"value_lte,omitempty"`
	ValueGt                  *string                  `json:"value_gt,omitempty"`
	ValueGte                 *string                  `json:"value_gte,omitempty"`
	ValueContains            *string                  `json:"value_contains,omitempty"`
	ValueNotContains         *string                  `json:"value_not_contains,omitempty"`
	ValueStartsWith          *string                  `json:"value_starts_with,omitempty"`
	ValueNotStartsWith       *string                  `json:"value_not_starts_with,omitempty"`
	ValueEndsWith            *string                  `json:"value_ends_with,omitempty"`
	ValueNotEndsWith         *string                  `json:"value_not_ends_with,omitempty"`
	And                      []EmailChannelWhereInput `json:"AND,omitempty"`
	Or                       []EmailChannelWhereInput `json:"OR,omitempty"`
	Not                      []EmailChannelWhereInput `json:"NOT,omitempty"`
}

type RouteUpdateManyDataInput struct {
	Name       *string                     `json:"name,omitempty"`
	Image      *string                     `json:"image,omitempty"`
	Type       *ExperienceType             `json:"type,omitempty"`
	ExtraTypes *RouteUpdateextraTypesInput `json:"extraTypes,omitempty"`
	Popularity *float64                    `json:"popularity,omitempty"`
	Color      *string                     `json:"color,omitempty"`
}

type PhoneChannelWhereInput struct {
	ID                       *string                  `json:"id,omitempty"`
	IDNot                    *string                  `json:"id_not,omitempty"`
	IDIn                     []string                 `json:"id_in,omitempty"`
	IDNotIn                  []string                 `json:"id_not_in,omitempty"`
	IDLt                     *string                  `json:"id_lt,omitempty"`
	IDLte                    *string                  `json:"id_lte,omitempty"`
	IDGt                     *string                  `json:"id_gt,omitempty"`
	IDGte                    *string                  `json:"id_gte,omitempty"`
	IDContains               *string                  `json:"id_contains,omitempty"`
	IDNotContains            *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string                  `json:"createdAt,omitempty"`
	CreatedAtNot             *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                  `json:"updatedAt_gte,omitempty"`
	Person                   *PersonWhereInput        `json:"person,omitempty"`
	IsMain                   *bool                    `json:"isMain,omitempty"`
	IsMainNot                *bool                    `json:"isMain_not,omitempty"`
	DisplayName              *string                  `json:"displayName,omitempty"`
	DisplayNameNot           *string                  `json:"displayName_not,omitempty"`
	DisplayNameIn            []string                 `json:"displayName_in,omitempty"`
	DisplayNameNotIn         []string                 `json:"displayName_not_in,omitempty"`
	DisplayNameLt            *string                  `json:"displayName_lt,omitempty"`
	DisplayNameLte           *string                  `json:"displayName_lte,omitempty"`
	DisplayNameGt            *string                  `json:"displayName_gt,omitempty"`
	DisplayNameGte           *string                  `json:"displayName_gte,omitempty"`
	DisplayNameContains      *string                  `json:"displayName_contains,omitempty"`
	DisplayNameNotContains   *string                  `json:"displayName_not_contains,omitempty"`
	DisplayNameStartsWith    *string                  `json:"displayName_starts_with,omitempty"`
	DisplayNameNotStartsWith *string                  `json:"displayName_not_starts_with,omitempty"`
	DisplayNameEndsWith      *string                  `json:"displayName_ends_with,omitempty"`
	DisplayNameNotEndsWith   *string                  `json:"displayName_not_ends_with,omitempty"`
	Valid                    *bool                    `json:"valid,omitempty"`
	ValidNot                 *bool                    `json:"valid_not,omitempty"`
	CountryCode              *string                  `json:"countryCode,omitempty"`
	CountryCodeNot           *string                  `json:"countryCode_not,omitempty"`
	CountryCodeIn            []string                 `json:"countryCode_in,omitempty"`
	CountryCodeNotIn         []string                 `json:"countryCode_not_in,omitempty"`
	CountryCodeLt            *string                  `json:"countryCode_lt,omitempty"`
	CountryCodeLte           *string                  `json:"countryCode_lte,omitempty"`
	CountryCodeGt            *string                  `json:"countryCode_gt,omitempty"`
	CountryCodeGte           *string                  `json:"countryCode_gte,omitempty"`
	CountryCodeContains      *string                  `json:"countryCode_contains,omitempty"`
	CountryCodeNotContains   *string                  `json:"countryCode_not_contains,omitempty"`
	CountryCodeStartsWith    *string                  `json:"countryCode_starts_with,omitempty"`
	CountryCodeNotStartsWith *string                  `json:"countryCode_not_starts_with,omitempty"`
	CountryCodeEndsWith      *string                  `json:"countryCode_ends_with,omitempty"`
	CountryCodeNotEndsWith   *string                  `json:"countryCode_not_ends_with,omitempty"`
	Number                   *string                  `json:"number,omitempty"`
	NumberNot                *string                  `json:"number_not,omitempty"`
	NumberIn                 []string                 `json:"number_in,omitempty"`
	NumberNotIn              []string                 `json:"number_not_in,omitempty"`
	NumberLt                 *string                  `json:"number_lt,omitempty"`
	NumberLte                *string                  `json:"number_lte,omitempty"`
	NumberGt                 *string                  `json:"number_gt,omitempty"`
	NumberGte                *string                  `json:"number_gte,omitempty"`
	NumberContains           *string                  `json:"number_contains,omitempty"`
	NumberNotContains        *string                  `json:"number_not_contains,omitempty"`
	NumberStartsWith         *string                  `json:"number_starts_with,omitempty"`
	NumberNotStartsWith      *string                  `json:"number_not_starts_with,omitempty"`
	NumberEndsWith           *string                  `json:"number_ends_with,omitempty"`
	NumberNotEndsWith        *string                  `json:"number_not_ends_with,omitempty"`
	And                      []PhoneChannelWhereInput `json:"AND,omitempty"`
	Or                       []PhoneChannelWhereInput `json:"OR,omitempty"`
	Not                      []PhoneChannelWhereInput `json:"NOT,omitempty"`
}

type PlaceUpsertNestedInput struct {
	Update PlaceUpdateDataInput `json:"update"`
	Create PlaceCreateInput     `json:"create"`
}

type CostWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AttractionUpsertWithWhereUniqueNestedInput struct {
	Where  AttractionWhereUniqueInput `json:"where"`
	Update AttractionUpdateDataInput  `json:"update"`
	Create AttractionCreateInput      `json:"create"`
}

type CostSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *CostWhereInput              `json:"node,omitempty"`
	And                        []CostSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CostSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CostSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AttractionScalarWhereInput struct {
	ID                          *string                      `json:"id,omitempty"`
	IDNot                       *string                      `json:"id_not,omitempty"`
	IDIn                        []string                     `json:"id_in,omitempty"`
	IDNotIn                     []string                     `json:"id_not_in,omitempty"`
	IDLt                        *string                      `json:"id_lt,omitempty"`
	IDLte                       *string                      `json:"id_lte,omitempty"`
	IDGt                        *string                      `json:"id_gt,omitempty"`
	IDGte                       *string                      `json:"id_gte,omitempty"`
	IDContains                  *string                      `json:"id_contains,omitempty"`
	IDNotContains               *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                      `json:"id_not_ends_with,omitempty"`
	CreatedAt                   *string                      `json:"createdAt,omitempty"`
	CreatedAtNot                *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string                      `json:"updatedAt_gte,omitempty"`
	PrincipalImage              *string                      `json:"principalImage,omitempty"`
	PrincipalImageNot           *string                      `json:"principalImage_not,omitempty"`
	PrincipalImageIn            []string                     `json:"principalImage_in,omitempty"`
	PrincipalImageNotIn         []string                     `json:"principalImage_not_in,omitempty"`
	PrincipalImageLt            *string                      `json:"principalImage_lt,omitempty"`
	PrincipalImageLte           *string                      `json:"principalImage_lte,omitempty"`
	PrincipalImageGt            *string                      `json:"principalImage_gt,omitempty"`
	PrincipalImageGte           *string                      `json:"principalImage_gte,omitempty"`
	PrincipalImageContains      *string                      `json:"principalImage_contains,omitempty"`
	PrincipalImageNotContains   *string                      `json:"principalImage_not_contains,omitempty"`
	PrincipalImageStartsWith    *string                      `json:"principalImage_starts_with,omitempty"`
	PrincipalImageNotStartsWith *string                      `json:"principalImage_not_starts_with,omitempty"`
	PrincipalImageEndsWith      *string                      `json:"principalImage_ends_with,omitempty"`
	PrincipalImageNotEndsWith   *string                      `json:"principalImage_not_ends_with,omitempty"`
	CoverImage                  *string                      `json:"coverImage,omitempty"`
	CoverImageNot               *string                      `json:"coverImage_not,omitempty"`
	CoverImageIn                []string                     `json:"coverImage_in,omitempty"`
	CoverImageNotIn             []string                     `json:"coverImage_not_in,omitempty"`
	CoverImageLt                *string                      `json:"coverImage_lt,omitempty"`
	CoverImageLte               *string                      `json:"coverImage_lte,omitempty"`
	CoverImageGt                *string                      `json:"coverImage_gt,omitempty"`
	CoverImageGte               *string                      `json:"coverImage_gte,omitempty"`
	CoverImageContains          *string                      `json:"coverImage_contains,omitempty"`
	CoverImageNotContains       *string                      `json:"coverImage_not_contains,omitempty"`
	CoverImageStartsWith        *string                      `json:"coverImage_starts_with,omitempty"`
	CoverImageNotStartsWith     *string                      `json:"coverImage_not_starts_with,omitempty"`
	CoverImageEndsWith          *string                      `json:"coverImage_ends_with,omitempty"`
	CoverImageNotEndsWith       *string                      `json:"coverImage_not_ends_with,omitempty"`
	LandscapeImage              *string                      `json:"landscapeImage,omitempty"`
	LandscapeImageNot           *string                      `json:"landscapeImage_not,omitempty"`
	LandscapeImageIn            []string                     `json:"landscapeImage_in,omitempty"`
	LandscapeImageNotIn         []string                     `json:"landscapeImage_not_in,omitempty"`
	LandscapeImageLt            *string                      `json:"landscapeImage_lt,omitempty"`
	LandscapeImageLte           *string                      `json:"landscapeImage_lte,omitempty"`
	LandscapeImageGt            *string                      `json:"landscapeImage_gt,omitempty"`
	LandscapeImageGte           *string                      `json:"landscapeImage_gte,omitempty"`
	LandscapeImageContains      *string                      `json:"landscapeImage_contains,omitempty"`
	LandscapeImageNotContains   *string                      `json:"landscapeImage_not_contains,omitempty"`
	LandscapeImageStartsWith    *string                      `json:"landscapeImage_starts_with,omitempty"`
	LandscapeImageNotStartsWith *string                      `json:"landscapeImage_not_starts_with,omitempty"`
	LandscapeImageEndsWith      *string                      `json:"landscapeImage_ends_with,omitempty"`
	LandscapeImageNotEndsWith   *string                      `json:"landscapeImage_not_ends_with,omitempty"`
	And                         []AttractionScalarWhereInput `json:"AND,omitempty"`
	Or                          []AttractionScalarWhereInput `json:"OR,omitempty"`
	Not                         []AttractionScalarWhereInput `json:"NOT,omitempty"`
}

type TravelerUpdateManyMutationInput struct {
	Unregistered *bool   `json:"unregistered,omitempty"`
	Username     *string `json:"username,omitempty"`
}

type AttractionUpdateManyWithWhereNestedInput struct {
	Where AttractionScalarWhereInput    `json:"where"`
	Data  AttractionUpdateManyDataInput `json:"data"`
}

type TicketUpdateManyMutationInput struct {
	MaxUses  *int32       `json:"maxUses,omitempty"`
	Visited  *bool        `json:"visited,omitempty"`
	Finished *bool        `json:"finished,omitempty"`
	State    *TicketState `json:"state,omitempty"`
}

type AttractionUpdateManyDataInput struct {
	PrincipalImage *string                       `json:"principalImage,omitempty"`
	CoverImage     *string                       `json:"coverImage,omitempty"`
	LandscapeImage *string                       `json:"landscapeImage,omitempty"`
	Gallery        *AttractionUpdategalleryInput `json:"gallery,omitempty"`
	Type           *AttractionUpdatetypeInput    `json:"type,omitempty"`
}

type TextUpdateInput struct {
	English *string `json:"english,omitempty"`
	Spanish *string `json:"spanish,omitempty"`
}

type CostUpdateOneRequiredInput struct {
	Create  *CostCreateInput       `json:"create,omitempty"`
	Update  *CostUpdateDataInput   `json:"update,omitempty"`
	Upsert  *CostUpsertNestedInput `json:"upsert,omitempty"`
	Connect *CostWhereUniqueInput  `json:"connect,omitempty"`
}

type RouteUpdateManyMutationInput struct {
	Name       *string                     `json:"name,omitempty"`
	Image      *string                     `json:"image,omitempty"`
	Type       *ExperienceType             `json:"type,omitempty"`
	ExtraTypes *RouteUpdateextraTypesInput `json:"extraTypes,omitempty"`
	Popularity *float64                    `json:"popularity,omitempty"`
	Color      *string                     `json:"color,omitempty"`
}

type CostUpdateDataInput struct {
	Value    *float64                        `json:"value,omitempty"`
	Currency *CurrencyUpdateOneRequiredInput `json:"currency,omitempty"`
}

type PurchaseUpdateManyMutationInput struct {
	ChargeToken     *string `json:"chargeToken,omitempty"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type CurrencyUpdateOneRequiredInput struct {
	Create  *CurrencyCreateInput       `json:"create,omitempty"`
	Update  *CurrencyUpdateDataInput   `json:"update,omitempty"`
	Upsert  *CurrencyUpsertNestedInput `json:"upsert,omitempty"`
	Connect *CurrencyWhereUniqueInput  `json:"connect,omitempty"`
}

type ErrorWhereInput struct {
	ID                    *string           `json:"id,omitempty"`
	IDNot                 *string           `json:"id_not,omitempty"`
	IDIn                  []string          `json:"id_in,omitempty"`
	IDNotIn               []string          `json:"id_not_in,omitempty"`
	IDLt                  *string           `json:"id_lt,omitempty"`
	IDLte                 *string           `json:"id_lte,omitempty"`
	IDGt                  *string           `json:"id_gt,omitempty"`
	IDGte                 *string           `json:"id_gte,omitempty"`
	IDContains            *string           `json:"id_contains,omitempty"`
	IDNotContains         *string           `json:"id_not_contains,omitempty"`
	IDStartsWith          *string           `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string           `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string           `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string           `json:"id_not_ends_with,omitempty"`
	CreatedAt             *string           `json:"createdAt,omitempty"`
	CreatedAtNot          *string           `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string           `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string           `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string           `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string           `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string           `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string           `json:"updatedAt_gte,omitempty"`
	Code                  *string           `json:"code,omitempty"`
	CodeNot               *string           `json:"code_not,omitempty"`
	CodeIn                []string          `json:"code_in,omitempty"`
	CodeNotIn             []string          `json:"code_not_in,omitempty"`
	CodeLt                *string           `json:"code_lt,omitempty"`
	CodeLte               *string           `json:"code_lte,omitempty"`
	CodeGt                *string           `json:"code_gt,omitempty"`
	CodeGte               *string           `json:"code_gte,omitempty"`
	CodeContains          *string           `json:"code_contains,omitempty"`
	CodeNotContains       *string           `json:"code_not_contains,omitempty"`
	CodeStartsWith        *string           `json:"code_starts_with,omitempty"`
	CodeNotStartsWith     *string           `json:"code_not_starts_with,omitempty"`
	CodeEndsWith          *string           `json:"code_ends_with,omitempty"`
	CodeNotEndsWith       *string           `json:"code_not_ends_with,omitempty"`
	Message               *TextWhereInput   `json:"message,omitempty"`
	Internal              *string           `json:"internal,omitempty"`
	InternalNot           *string           `json:"internal_not,omitempty"`
	InternalIn            []string          `json:"internal_in,omitempty"`
	InternalNotIn         []string          `json:"internal_not_in,omitempty"`
	InternalLt            *string           `json:"internal_lt,omitempty"`
	InternalLte           *string           `json:"internal_lte,omitempty"`
	InternalGt            *string           `json:"internal_gt,omitempty"`
	InternalGte           *string           `json:"internal_gte,omitempty"`
	InternalContains      *string           `json:"internal_contains,omitempty"`
	InternalNotContains   *string           `json:"internal_not_contains,omitempty"`
	InternalStartsWith    *string           `json:"internal_starts_with,omitempty"`
	InternalNotStartsWith *string           `json:"internal_not_starts_with,omitempty"`
	InternalEndsWith      *string           `json:"internal_ends_with,omitempty"`
	InternalNotEndsWith   *string           `json:"internal_not_ends_with,omitempty"`
	Explain               *string           `json:"explain,omitempty"`
	ExplainNot            *string           `json:"explain_not,omitempty"`
	ExplainIn             []string          `json:"explain_in,omitempty"`
	ExplainNotIn          []string          `json:"explain_not_in,omitempty"`
	ExplainLt             *string           `json:"explain_lt,omitempty"`
	ExplainLte            *string           `json:"explain_lte,omitempty"`
	ExplainGt             *string           `json:"explain_gt,omitempty"`
	ExplainGte            *string           `json:"explain_gte,omitempty"`
	ExplainContains       *string           `json:"explain_contains,omitempty"`
	ExplainNotContains    *string           `json:"explain_not_contains,omitempty"`
	ExplainStartsWith     *string           `json:"explain_starts_with,omitempty"`
	ExplainNotStartsWith  *string           `json:"explain_not_starts_with,omitempty"`
	ExplainEndsWith       *string           `json:"explain_ends_with,omitempty"`
	ExplainNotEndsWith    *string           `json:"explain_not_ends_with,omitempty"`
	Location              *string           `json:"location,omitempty"`
	LocationNot           *string           `json:"location_not,omitempty"`
	LocationIn            []string          `json:"location_in,omitempty"`
	LocationNotIn         []string          `json:"location_not_in,omitempty"`
	LocationLt            *string           `json:"location_lt,omitempty"`
	LocationLte           *string           `json:"location_lte,omitempty"`
	LocationGt            *string           `json:"location_gt,omitempty"`
	LocationGte           *string           `json:"location_gte,omitempty"`
	LocationContains      *string           `json:"location_contains,omitempty"`
	LocationNotContains   *string           `json:"location_not_contains,omitempty"`
	LocationStartsWith    *string           `json:"location_starts_with,omitempty"`
	LocationNotStartsWith *string           `json:"location_not_starts_with,omitempty"`
	LocationEndsWith      *string           `json:"location_ends_with,omitempty"`
	LocationNotEndsWith   *string           `json:"location_not_ends_with,omitempty"`
	And                   []ErrorWhereInput `json:"AND,omitempty"`
	Or                    []ErrorWhereInput `json:"OR,omitempty"`
	Not                   []ErrorWhereInput `json:"NOT,omitempty"`
}

type CurrencyUpdateDataInput struct {
	Name   *TextUpdateOneRequiredInput `json:"name,omitempty"`
	Code   *string                     `json:"code,omitempty"`
	Symbol *string                     `json:"symbol,omitempty"`
}

type PhoneChannelUpdateManyMutationInput struct {
	IsMain      *bool   `json:"isMain,omitempty"`
	DisplayName *string `json:"displayName,omitempty"`
	Valid       *bool   `json:"valid,omitempty"`
	CountryCode *string `json:"countryCode,omitempty"`
	Number      *string `json:"number,omitempty"`
}

type CurrencyUpsertNestedInput struct {
	Update CurrencyUpdateDataInput `json:"update"`
	Create CurrencyCreateInput     `json:"create"`
}

type PersonUpdateOneRequiredWithoutPhonesInput struct {
	Create  *PersonCreateWithoutPhonesInput     `json:"create,omitempty"`
	Update  *PersonUpdateWithoutPhonesDataInput `json:"update,omitempty"`
	Upsert  *PersonUpsertWithoutPhonesInput     `json:"upsert,omitempty"`
	Connect *PersonWhereUniqueInput             `json:"connect,omitempty"`
}

type CostUpsertNestedInput struct {
	Update CostUpdateDataInput `json:"update"`
	Create CostCreateInput     `json:"create"`
}

type PersonCreateOneWithoutPhonesInput struct {
	Create  *PersonCreateWithoutPhonesInput `json:"create,omitempty"`
	Connect *PersonWhereUniqueInput         `json:"connect,omitempty"`
}

type PassTypeUpsertWithoutChildrenInput struct {
	Update PassTypeUpdateWithoutChildrenDataInput `json:"update"`
	Create PassTypeCreateWithoutChildrenInput     `json:"create"`
}

type PersonReviewsUpdateInput struct {
	Person        *PersonUpdateOneRequiredInput `json:"person,omitempty"`
	Title         *TextUpdateOneRequiredInput   `json:"title,omitempty"`
	Description   *TextUpdateOneRequiredInput   `json:"description,omitempty"`
	ApproveNumber *int32                        `json:"approveNumber,omitempty"`
	DeclineNumber *int32                        `json:"declineNumber,omitempty"`
	Comments      *PersonReviewsUpdateManyInput `json:"comments,omitempty"`
}

type PurchaseUpdateOneInput struct {
	Create     *PurchaseCreateInput       `json:"create,omitempty"`
	Update     *PurchaseUpdateDataInput   `json:"update,omitempty"`
	Upsert     *PurchaseUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                      `json:"delete,omitempty"`
	Disconnect *bool                      `json:"disconnect,omitempty"`
	Connect    *PurchaseWhereUniqueInput  `json:"connect,omitempty"`
}

type PaymentMethodUpdateManyMutationInput struct {
	Type       *PaymentMethodType `json:"type,omitempty"`
	Value      *string            `json:"value,omitempty"`
	CardNumber *string            `json:"cardNumber,omitempty"`
	Code       *string            `json:"code,omitempty"`
}

type PurchaseUpdateDataInput struct {
	ChargeToken     *string                              `json:"chargeToken,omitempty"`
	GatewayResponse *string                              `json:"gatewayResponse,omitempty"`
	Products        *ProductEntryUpdateManyInput         `json:"products,omitempty"`
	DiscountId      *string                              `json:"discountID,omitempty"`
	Discount        *int32                               `json:"discount,omitempty"`
	PaymentMethod   *PaymentMethodUpdateOneRequiredInput `json:"paymentMethod,omitempty"`
}

type PassTypeUpdateManyMutationInput struct {
	Gallery   *PassTypeUpdategalleryInput `json:"gallery,omitempty"`
	CreatorId *string                     `json:"creatorID,omitempty"`
	Duration  *int32                      `json:"duration,omitempty"`
}

type ProductEntryUpdateManyInput struct {
	Create     []ProductEntryCreateInput                      `json:"create,omitempty"`
	Update     []ProductEntryUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []ProductEntryUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []ProductEntryWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []ProductEntryWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []ProductEntryWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []ProductEntryWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []ProductEntryScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []ProductEntryUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type PassUpdateWithWhereUniqueWithoutTypeInput struct {
	Where PassWhereUniqueInput           `json:"where"`
	Data  PassUpdateWithoutTypeDataInput `json:"data"`
}

type ProductEntryUpdateWithWhereUniqueNestedInput struct {
	Where ProductEntryWhereUniqueInput `json:"where"`
	Data  ProductEntryUpdateDataInput  `json:"data"`
}

type LimaContactWhereInput struct {
	ID                       *string                 `json:"id,omitempty"`
	IDNot                    *string                 `json:"id_not,omitempty"`
	IDIn                     []string                `json:"id_in,omitempty"`
	IDNotIn                  []string                `json:"id_not_in,omitempty"`
	IDLt                     *string                 `json:"id_lt,omitempty"`
	IDLte                    *string                 `json:"id_lte,omitempty"`
	IDGt                     *string                 `json:"id_gt,omitempty"`
	IDGte                    *string                 `json:"id_gte,omitempty"`
	IDContains               *string                 `json:"id_contains,omitempty"`
	IDNotContains            *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                 `json:"id_not_ends_with,omitempty"`
	Message                  *TextWhereInput         `json:"message,omitempty"`
	Email                    *string                 `json:"email,omitempty"`
	EmailNot                 *string                 `json:"email_not,omitempty"`
	EmailIn                  []string                `json:"email_in,omitempty"`
	EmailNotIn               []string                `json:"email_not_in,omitempty"`
	EmailLt                  *string                 `json:"email_lt,omitempty"`
	EmailLte                 *string                 `json:"email_lte,omitempty"`
	EmailGt                  *string                 `json:"email_gt,omitempty"`
	EmailGte                 *string                 `json:"email_gte,omitempty"`
	EmailContains            *string                 `json:"email_contains,omitempty"`
	EmailNotContains         *string                 `json:"email_not_contains,omitempty"`
	EmailStartsWith          *string                 `json:"email_starts_with,omitempty"`
	EmailNotStartsWith       *string                 `json:"email_not_starts_with,omitempty"`
	EmailEndsWith            *string                 `json:"email_ends_with,omitempty"`
	EmailNotEndsWith         *string                 `json:"email_not_ends_with,omitempty"`
	PhoneNumber              *string                 `json:"phoneNumber,omitempty"`
	PhoneNumberNot           *string                 `json:"phoneNumber_not,omitempty"`
	PhoneNumberIn            []string                `json:"phoneNumber_in,omitempty"`
	PhoneNumberNotIn         []string                `json:"phoneNumber_not_in,omitempty"`
	PhoneNumberLt            *string                 `json:"phoneNumber_lt,omitempty"`
	PhoneNumberLte           *string                 `json:"phoneNumber_lte,omitempty"`
	PhoneNumberGt            *string                 `json:"phoneNumber_gt,omitempty"`
	PhoneNumberGte           *string                 `json:"phoneNumber_gte,omitempty"`
	PhoneNumberContains      *string                 `json:"phoneNumber_contains,omitempty"`
	PhoneNumberNotContains   *string                 `json:"phoneNumber_not_contains,omitempty"`
	PhoneNumberStartsWith    *string                 `json:"phoneNumber_starts_with,omitempty"`
	PhoneNumberNotStartsWith *string                 `json:"phoneNumber_not_starts_with,omitempty"`
	PhoneNumberEndsWith      *string                 `json:"phoneNumber_ends_with,omitempty"`
	PhoneNumberNotEndsWith   *string                 `json:"phoneNumber_not_ends_with,omitempty"`
	And                      []LimaContactWhereInput `json:"AND,omitempty"`
	Or                       []LimaContactWhereInput `json:"OR,omitempty"`
	Not                      []LimaContactWhereInput `json:"NOT,omitempty"`
}

type ProductEntryUpdateDataInput struct {
	ParentId     *string  `json:"parentID,omitempty"`
	Name         *string  `json:"name,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Quantity     *int32   `json:"quantity,omitempty"`
	Cost         *float64 `json:"cost,omitempty"`
	CurrencyCode *string  `json:"currencyCode,omitempty"`
}

type PassUpdateManyMutationInput struct {
	ExpireAt *string    `json:"expireAt,omitempty"`
	State    *PassState `json:"state,omitempty"`
}

type ProductEntryUpsertWithWhereUniqueNestedInput struct {
	Where  ProductEntryWhereUniqueInput `json:"where"`
	Update ProductEntryUpdateDataInput  `json:"update"`
	Create ProductEntryCreateInput      `json:"create"`
}

type PartnerUpdateInput struct {
	Attender     *PersonUpdateOneRequiredInput             `json:"attender,omitempty"`
	Owner        *PersonUpdateOneInput                     `json:"owner,omitempty"`
	Attractions  *AttractionUpdateManyWithoutOwnerInput    `json:"attractions,omitempty"`
	BrandName    *string                                   `json:"brandName,omitempty"`
	Logo         *string                                   `json:"logo,omitempty"`
	SocialReason *string                                   `json:"socialReason,omitempty"`
	Ruc          *string                                   `json:"ruc,omitempty"`
	Address      *string                                   `json:"address,omitempty"`
	Location     *LocationUpdateOneRequiredInput           `json:"location,omitempty"`
	Features     *FeatureUpdateManyInput                   `json:"features,omitempty"`
	ServiceHours *OpeningHoursUpdateOneInput               `json:"serviceHours,omitempty"`
	Registry     *EntryTicketUpdateManyWithoutPartnerInput `json:"registry,omitempty"`
}

type ProductEntryScalarWhereInput struct {
	ID                        *string                        `json:"id,omitempty"`
	IDNot                     *string                        `json:"id_not,omitempty"`
	IDIn                      []string                       `json:"id_in,omitempty"`
	IDNotIn                   []string                       `json:"id_not_in,omitempty"`
	IDLt                      *string                        `json:"id_lt,omitempty"`
	IDLte                     *string                        `json:"id_lte,omitempty"`
	IDGt                      *string                        `json:"id_gt,omitempty"`
	IDGte                     *string                        `json:"id_gte,omitempty"`
	IDContains                *string                        `json:"id_contains,omitempty"`
	IDNotContains             *string                        `json:"id_not_contains,omitempty"`
	IDStartsWith              *string                        `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string                        `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string                        `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string                        `json:"id_not_ends_with,omitempty"`
	ParentId                  *string                        `json:"parentID,omitempty"`
	ParentIdNot               *string                        `json:"parentID_not,omitempty"`
	ParentIdIn                []string                       `json:"parentID_in,omitempty"`
	ParentIdNotIn             []string                       `json:"parentID_not_in,omitempty"`
	ParentIdLt                *string                        `json:"parentID_lt,omitempty"`
	ParentIdLte               *string                        `json:"parentID_lte,omitempty"`
	ParentIdGt                *string                        `json:"parentID_gt,omitempty"`
	ParentIdGte               *string                        `json:"parentID_gte,omitempty"`
	ParentIdContains          *string                        `json:"parentID_contains,omitempty"`
	ParentIdNotContains       *string                        `json:"parentID_not_contains,omitempty"`
	ParentIdStartsWith        *string                        `json:"parentID_starts_with,omitempty"`
	ParentIdNotStartsWith     *string                        `json:"parentID_not_starts_with,omitempty"`
	ParentIdEndsWith          *string                        `json:"parentID_ends_with,omitempty"`
	ParentIdNotEndsWith       *string                        `json:"parentID_not_ends_with,omitempty"`
	Name                      *string                        `json:"name,omitempty"`
	NameNot                   *string                        `json:"name_not,omitempty"`
	NameIn                    []string                       `json:"name_in,omitempty"`
	NameNotIn                 []string                       `json:"name_not_in,omitempty"`
	NameLt                    *string                        `json:"name_lt,omitempty"`
	NameLte                   *string                        `json:"name_lte,omitempty"`
	NameGt                    *string                        `json:"name_gt,omitempty"`
	NameGte                   *string                        `json:"name_gte,omitempty"`
	NameContains              *string                        `json:"name_contains,omitempty"`
	NameNotContains           *string                        `json:"name_not_contains,omitempty"`
	NameStartsWith            *string                        `json:"name_starts_with,omitempty"`
	NameNotStartsWith         *string                        `json:"name_not_starts_with,omitempty"`
	NameEndsWith              *string                        `json:"name_ends_with,omitempty"`
	NameNotEndsWith           *string                        `json:"name_not_ends_with,omitempty"`
	Description               *string                        `json:"description,omitempty"`
	DescriptionNot            *string                        `json:"description_not,omitempty"`
	DescriptionIn             []string                       `json:"description_in,omitempty"`
	DescriptionNotIn          []string                       `json:"description_not_in,omitempty"`
	DescriptionLt             *string                        `json:"description_lt,omitempty"`
	DescriptionLte            *string                        `json:"description_lte,omitempty"`
	DescriptionGt             *string                        `json:"description_gt,omitempty"`
	DescriptionGte            *string                        `json:"description_gte,omitempty"`
	DescriptionContains       *string                        `json:"description_contains,omitempty"`
	DescriptionNotContains    *string                        `json:"description_not_contains,omitempty"`
	DescriptionStartsWith     *string                        `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith  *string                        `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith       *string                        `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith    *string                        `json:"description_not_ends_with,omitempty"`
	Quantity                  *int32                         `json:"quantity,omitempty"`
	QuantityNot               *int32                         `json:"quantity_not,omitempty"`
	QuantityIn                []int32                        `json:"quantity_in,omitempty"`
	QuantityNotIn             []int32                        `json:"quantity_not_in,omitempty"`
	QuantityLt                *int32                         `json:"quantity_lt,omitempty"`
	QuantityLte               *int32                         `json:"quantity_lte,omitempty"`
	QuantityGt                *int32                         `json:"quantity_gt,omitempty"`
	QuantityGte               *int32                         `json:"quantity_gte,omitempty"`
	Cost                      *float64                       `json:"cost,omitempty"`
	CostNot                   *float64                       `json:"cost_not,omitempty"`
	CostIn                    []float64                      `json:"cost_in,omitempty"`
	CostNotIn                 []float64                      `json:"cost_not_in,omitempty"`
	CostLt                    *float64                       `json:"cost_lt,omitempty"`
	CostLte                   *float64                       `json:"cost_lte,omitempty"`
	CostGt                    *float64                       `json:"cost_gt,omitempty"`
	CostGte                   *float64                       `json:"cost_gte,omitempty"`
	CurrencyCode              *string                        `json:"currencyCode,omitempty"`
	CurrencyCodeNot           *string                        `json:"currencyCode_not,omitempty"`
	CurrencyCodeIn            []string                       `json:"currencyCode_in,omitempty"`
	CurrencyCodeNotIn         []string                       `json:"currencyCode_not_in,omitempty"`
	CurrencyCodeLt            *string                        `json:"currencyCode_lt,omitempty"`
	CurrencyCodeLte           *string                        `json:"currencyCode_lte,omitempty"`
	CurrencyCodeGt            *string                        `json:"currencyCode_gt,omitempty"`
	CurrencyCodeGte           *string                        `json:"currencyCode_gte,omitempty"`
	CurrencyCodeContains      *string                        `json:"currencyCode_contains,omitempty"`
	CurrencyCodeNotContains   *string                        `json:"currencyCode_not_contains,omitempty"`
	CurrencyCodeStartsWith    *string                        `json:"currencyCode_starts_with,omitempty"`
	CurrencyCodeNotStartsWith *string                        `json:"currencyCode_not_starts_with,omitempty"`
	CurrencyCodeEndsWith      *string                        `json:"currencyCode_ends_with,omitempty"`
	CurrencyCodeNotEndsWith   *string                        `json:"currencyCode_not_ends_with,omitempty"`
	And                       []ProductEntryScalarWhereInput `json:"AND,omitempty"`
	Or                        []ProductEntryScalarWhereInput `json:"OR,omitempty"`
	Not                       []ProductEntryScalarWhereInput `json:"NOT,omitempty"`
}

type LocationUpdateManyMutationInput struct {
	Longitude *float64 `json:"longitude,omitempty"`
	Latitude  *float64 `json:"latitude,omitempty"`
}

type ProductEntryUpdateManyWithWhereNestedInput struct {
	Where ProductEntryScalarWhereInput    `json:"where"`
	Data  ProductEntryUpdateManyDataInput `json:"data"`
}

type LimaContactUpdateInput struct {
	Message     *TextUpdateOneRequiredInput `json:"message,omitempty"`
	Email       *string                     `json:"email,omitempty"`
	PhoneNumber *string                     `json:"phoneNumber,omitempty"`
}

type ProductEntryUpdateManyDataInput struct {
	ParentId     *string  `json:"parentID,omitempty"`
	Name         *string  `json:"name,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Quantity     *int32   `json:"quantity,omitempty"`
	Cost         *float64 `json:"cost,omitempty"`
	CurrencyCode *string  `json:"currencyCode,omitempty"`
}

type PartnerWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PaymentMethodUpdateOneRequiredInput struct {
	Create  *PaymentMethodCreateInput       `json:"create,omitempty"`
	Update  *PaymentMethodUpdateDataInput   `json:"update,omitempty"`
	Upsert  *PaymentMethodUpsertNestedInput `json:"upsert,omitempty"`
	Connect *PaymentMethodWhereUniqueInput  `json:"connect,omitempty"`
}

type PassWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PaymentMethodUpdateDataInput struct {
	Type       *PaymentMethodType `json:"type,omitempty"`
	Value      *string            `json:"value,omitempty"`
	CardNumber *string            `json:"cardNumber,omitempty"`
	Code       *string            `json:"code,omitempty"`
}

type PassTypeWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PaymentMethodUpsertNestedInput struct {
	Update PaymentMethodUpdateDataInput `json:"update"`
	Create PaymentMethodCreateInput     `json:"create"`
}

type PartnerUpdateManyDataInput struct {
	BrandName    *string `json:"brandName,omitempty"`
	Logo         *string `json:"logo,omitempty"`
	SocialReason *string `json:"socialReason,omitempty"`
	Ruc          *string `json:"ruc,omitempty"`
	Address      *string `json:"address,omitempty"`
}

type PurchaseUpsertNestedInput struct {
	Update PurchaseUpdateDataInput `json:"update"`
	Create PurchaseCreateInput     `json:"create"`
}

type PartnerUpsertWithWhereUniqueNestedInput struct {
	Where  PartnerWhereUniqueInput `json:"where"`
	Update PartnerUpdateDataInput  `json:"update"`
	Create PartnerCreateInput      `json:"create"`
}

type PassUpsertWithoutTicketsInput struct {
	Update PassUpdateWithoutTicketsDataInput `json:"update"`
	Create PassCreateWithoutTicketsInput     `json:"create"`
}

type PartnerUpdateManyInput struct {
	Create     []PartnerCreateInput                      `json:"create,omitempty"`
	Update     []PartnerUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []PartnerUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []PartnerWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []PartnerWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []PartnerWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []PartnerWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []PartnerScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []PartnerUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type AttractionUpdateOneRequiredInput struct {
	Create  *AttractionCreateInput       `json:"create,omitempty"`
	Update  *AttractionUpdateDataInput   `json:"update,omitempty"`
	Upsert  *AttractionUpsertNestedInput `json:"upsert,omitempty"`
	Connect *AttractionWhereUniqueInput  `json:"connect,omitempty"`
}

type PlaceUpdateManyInput struct {
	Create     []PlaceCreateInput                      `json:"create,omitempty"`
	Update     []PlaceUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []PlaceUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []PlaceWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []PlaceWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []PlaceWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []PlaceWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []PlaceScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []PlaceUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type AttractionUpsertNestedInput struct {
	Update AttractionUpdateDataInput `json:"update"`
	Create AttractionCreateInput     `json:"create"`
}

type LimaContactCreateInput struct {
	ID          *string            `json:"id,omitempty"`
	Message     TextCreateOneInput `json:"message"`
	Email       string             `json:"email"`
	PhoneNumber string             `json:"phoneNumber"`
}

type TicketUpsertNestedInput struct {
	Update TicketUpdateDataInput `json:"update"`
	Create TicketCreateInput     `json:"create"`
}

type StoryCreateManyInput struct {
	Create  []StoryCreateInput      `json:"create,omitempty"`
	Connect []StoryWhereUniqueInput `json:"connect,omitempty"`
}

type TravelerUpdateOneRequiredWithoutRegistryInput struct {
	Create  *TravelerCreateWithoutRegistryInput     `json:"create,omitempty"`
	Update  *TravelerUpdateWithoutRegistryDataInput `json:"update,omitempty"`
	Upsert  *TravelerUpsertWithoutRegistryInput     `json:"upsert,omitempty"`
	Connect *TravelerWhereUniqueInput               `json:"connect,omitempty"`
}

type PlaceCreateManyInput struct {
	Create  []PlaceCreateInput      `json:"create,omitempty"`
	Connect []PlaceWhereUniqueInput `json:"connect,omitempty"`
}

type TravelerUpdateWithoutRegistryDataInput struct {
	Unregistered       *bool                                  `json:"unregistered,omitempty"`
	RegistrationTicket *ActionTicketUpdateOneInput            `json:"registrationTicket,omitempty"`
	Person             *PersonUpdateOneRequiredInput          `json:"person,omitempty"`
	Username           *string                                `json:"username,omitempty"`
	Cards              *CreditCardUpdateManyWithoutOwnerInput `json:"cards,omitempty"`
	Purchases          *PurchaseUpdateManyInput               `json:"purchases,omitempty"`
	Passes             *PassUpdateManyInput                   `json:"passes,omitempty"`
}

type PersonUpsertWithoutIdentificationInput struct {
	Update PersonUpdateWithoutIdentificationDataInput `json:"update"`
	Create PersonCreateWithoutIdentificationInput     `json:"create"`
}

type ActionTicketUpdateOneInput struct {
	Create     *ActionTicketCreateInput       `json:"create,omitempty"`
	Update     *ActionTicketUpdateDataInput   `json:"update,omitempty"`
	Upsert     *ActionTicketUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                          `json:"delete,omitempty"`
	Disconnect *bool                          `json:"disconnect,omitempty"`
	Connect    *ActionTicketWhereUniqueInput  `json:"connect,omitempty"`
}

type IDDocumentUpdateInput struct {
	Person    *PersonUpdateOneRequiredWithoutIdentificationInput `json:"person,omitempty"`
	Type      *IDType                                            `json:"type,omitempty"`
	Value     *string                                            `json:"value,omitempty"`
	Validated *bool                                              `json:"validated,omitempty"`
}

type ActionTicketUpdateDataInput struct {
	Type      *ActionTicketType `json:"type,omitempty"`
	Token     *string           `json:"token,omitempty"`
	Available *bool             `json:"available,omitempty"`
	Used      *bool             `json:"used,omitempty"`
}

type IDDocumentCreateInput struct {
	ID        *string                                   `json:"id,omitempty"`
	Person    PersonCreateOneWithoutIdentificationInput `json:"person"`
	Type      IDType                                    `json:"type"`
	Value     string                                    `json:"value"`
	Validated *bool                                     `json:"validated,omitempty"`
}

type ActionTicketUpsertNestedInput struct {
	Update ActionTicketUpdateDataInput `json:"update"`
	Create ActionTicketCreateInput     `json:"create"`
}

type FaqUpsertWithoutEntriesInput struct {
	Update FaqUpdateWithoutEntriesDataInput `json:"update"`
	Create FaqCreateWithoutEntriesInput     `json:"create"`
}

type CreditCardUpdateManyWithoutOwnerInput struct {
	Create     []CreditCardCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []CreditCardWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []CreditCardWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []CreditCardWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []CreditCardWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []CreditCardUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []CreditCardUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []CreditCardScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []CreditCardUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type FaqEntryUpdateInput struct {
	Faq      *FaqUpdateOneRequiredWithoutEntriesInput `json:"faq,omitempty"`
	Question *TextUpdateOneRequiredInput              `json:"question,omitempty"`
	Answer   *TextUpdateOneRequiredInput              `json:"answer,omitempty"`
}

type CreditCardUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where CreditCardWhereUniqueInput            `json:"where"`
	Data  CreditCardUpdateWithoutOwnerDataInput `json:"data"`
}

type FaqEntryCreateInput struct {
	ID       *string                         `json:"id,omitempty"`
	Faq      FaqCreateOneWithoutEntriesInput `json:"faq"`
	Question TextCreateOneInput              `json:"question"`
	Answer   TextCreateOneInput              `json:"answer"`
}

type CreditCardUpdateWithoutOwnerDataInput struct {
	CustomerToken *string         `json:"customerToken,omitempty"`
	CardNumber    *string         `json:"cardNumber,omitempty"`
	CardToken     *string         `json:"cardToken,omitempty"`
	Type          *CreditCardType `json:"type,omitempty"`
	LastUsed      *string         `json:"lastUsed,omitempty"`
}

type FaqUpdateInput struct {
	Attraction *AttractionUpdateOneRequiredWithoutFaqsInput `json:"attraction,omitempty"`
	Entries    *FaqEntryUpdateManyWithoutFaqInput           `json:"entries,omitempty"`
}

type CreditCardUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  CreditCardWhereUniqueInput            `json:"where"`
	Update CreditCardUpdateWithoutOwnerDataInput `json:"update"`
	Create CreditCardCreateWithoutOwnerInput     `json:"create"`
}

type PartnerCreateWithoutAttractionsInput struct {
	ID           *string                                   `json:"id,omitempty"`
	Attender     PersonCreateOneInput                      `json:"attender"`
	Owner        *PersonCreateOneInput                     `json:"owner,omitempty"`
	BrandName    string                                    `json:"brandName"`
	Logo         string                                    `json:"logo"`
	SocialReason string                                    `json:"socialReason"`
	Ruc          string                                    `json:"ruc"`
	Address      string                                    `json:"address"`
	Location     LocationCreateOneInput                    `json:"location"`
	Features     *FeatureCreateManyInput                   `json:"features,omitempty"`
	ServiceHours *OpeningHoursCreateOneInput               `json:"serviceHours,omitempty"`
	Registry     *EntryTicketCreateManyWithoutPartnerInput `json:"registry,omitempty"`
}

type CreditCardScalarWhereInput struct {
	ID                         *string                      `json:"id,omitempty"`
	IDNot                      *string                      `json:"id_not,omitempty"`
	IDIn                       []string                     `json:"id_in,omitempty"`
	IDNotIn                    []string                     `json:"id_not_in,omitempty"`
	IDLt                       *string                      `json:"id_lt,omitempty"`
	IDLte                      *string                      `json:"id_lte,omitempty"`
	IDGt                       *string                      `json:"id_gt,omitempty"`
	IDGte                      *string                      `json:"id_gte,omitempty"`
	IDContains                 *string                      `json:"id_contains,omitempty"`
	IDNotContains              *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith               *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith            *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith                 *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith              *string                      `json:"id_not_ends_with,omitempty"`
	CreatedAt                  *string                      `json:"createdAt,omitempty"`
	CreatedAtNot               *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn                []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn             []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte               *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt                *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte               *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt                  *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot               *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn             []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte               *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte               *string                      `json:"updatedAt_gte,omitempty"`
	CustomerToken              *string                      `json:"customerToken,omitempty"`
	CustomerTokenNot           *string                      `json:"customerToken_not,omitempty"`
	CustomerTokenIn            []string                     `json:"customerToken_in,omitempty"`
	CustomerTokenNotIn         []string                     `json:"customerToken_not_in,omitempty"`
	CustomerTokenLt            *string                      `json:"customerToken_lt,omitempty"`
	CustomerTokenLte           *string                      `json:"customerToken_lte,omitempty"`
	CustomerTokenGt            *string                      `json:"customerToken_gt,omitempty"`
	CustomerTokenGte           *string                      `json:"customerToken_gte,omitempty"`
	CustomerTokenContains      *string                      `json:"customerToken_contains,omitempty"`
	CustomerTokenNotContains   *string                      `json:"customerToken_not_contains,omitempty"`
	CustomerTokenStartsWith    *string                      `json:"customerToken_starts_with,omitempty"`
	CustomerTokenNotStartsWith *string                      `json:"customerToken_not_starts_with,omitempty"`
	CustomerTokenEndsWith      *string                      `json:"customerToken_ends_with,omitempty"`
	CustomerTokenNotEndsWith   *string                      `json:"customerToken_not_ends_with,omitempty"`
	CardNumber                 *string                      `json:"cardNumber,omitempty"`
	CardNumberNot              *string                      `json:"cardNumber_not,omitempty"`
	CardNumberIn               []string                     `json:"cardNumber_in,omitempty"`
	CardNumberNotIn            []string                     `json:"cardNumber_not_in,omitempty"`
	CardNumberLt               *string                      `json:"cardNumber_lt,omitempty"`
	CardNumberLte              *string                      `json:"cardNumber_lte,omitempty"`
	CardNumberGt               *string                      `json:"cardNumber_gt,omitempty"`
	CardNumberGte              *string                      `json:"cardNumber_gte,omitempty"`
	CardNumberContains         *string                      `json:"cardNumber_contains,omitempty"`
	CardNumberNotContains      *string                      `json:"cardNumber_not_contains,omitempty"`
	CardNumberStartsWith       *string                      `json:"cardNumber_starts_with,omitempty"`
	CardNumberNotStartsWith    *string                      `json:"cardNumber_not_starts_with,omitempty"`
	CardNumberEndsWith         *string                      `json:"cardNumber_ends_with,omitempty"`
	CardNumberNotEndsWith      *string                      `json:"cardNumber_not_ends_with,omitempty"`
	CardToken                  *string                      `json:"cardToken,omitempty"`
	CardTokenNot               *string                      `json:"cardToken_not,omitempty"`
	CardTokenIn                []string                     `json:"cardToken_in,omitempty"`
	CardTokenNotIn             []string                     `json:"cardToken_not_in,omitempty"`
	CardTokenLt                *string                      `json:"cardToken_lt,omitempty"`
	CardTokenLte               *string                      `json:"cardToken_lte,omitempty"`
	CardTokenGt                *string                      `json:"cardToken_gt,omitempty"`
	CardTokenGte               *string                      `json:"cardToken_gte,omitempty"`
	CardTokenContains          *string                      `json:"cardToken_contains,omitempty"`
	CardTokenNotContains       *string                      `json:"cardToken_not_contains,omitempty"`
	CardTokenStartsWith        *string                      `json:"cardToken_starts_with,omitempty"`
	CardTokenNotStartsWith     *string                      `json:"cardToken_not_starts_with,omitempty"`
	CardTokenEndsWith          *string                      `json:"cardToken_ends_with,omitempty"`
	CardTokenNotEndsWith       *string                      `json:"cardToken_not_ends_with,omitempty"`
	Type                       *CreditCardType              `json:"type,omitempty"`
	TypeNot                    *CreditCardType              `json:"type_not,omitempty"`
	TypeIn                     []CreditCardType             `json:"type_in,omitempty"`
	TypeNotIn                  []CreditCardType             `json:"type_not_in,omitempty"`
	LastUsed                   *string                      `json:"lastUsed,omitempty"`
	LastUsedNot                *string                      `json:"lastUsed_not,omitempty"`
	LastUsedIn                 []string                     `json:"lastUsed_in,omitempty"`
	LastUsedNotIn              []string                     `json:"lastUsed_not_in,omitempty"`
	LastUsedLt                 *string                      `json:"lastUsed_lt,omitempty"`
	LastUsedLte                *string                      `json:"lastUsed_lte,omitempty"`
	LastUsedGt                 *string                      `json:"lastUsed_gt,omitempty"`
	LastUsedGte                *string                      `json:"lastUsed_gte,omitempty"`
	And                        []CreditCardScalarWhereInput `json:"AND,omitempty"`
	Or                         []CreditCardScalarWhereInput `json:"OR,omitempty"`
	Not                        []CreditCardScalarWhereInput `json:"NOT,omitempty"`
}

type TextCreateInput struct {
	ID      *string `json:"id,omitempty"`
	English string  `json:"english"`
	Spanish *string `json:"spanish,omitempty"`
}

type CreditCardUpdateManyWithWhereNestedInput struct {
	Where CreditCardScalarWhereInput    `json:"where"`
	Data  CreditCardUpdateManyDataInput `json:"data"`
}

type EmailChannelCreateWithoutPersonInput struct {
	ID          *string                        `json:"id,omitempty"`
	IsMain      *bool                          `json:"isMain,omitempty"`
	DisplayName string                         `json:"displayName"`
	Valid       *bool                          `json:"valid,omitempty"`
	Value       string                         `json:"value"`
	Extras      *EmailChannelCreateextrasInput `json:"extras,omitempty"`
}

type CreditCardUpdateManyDataInput struct {
	CustomerToken *string         `json:"customerToken,omitempty"`
	CardNumber    *string         `json:"cardNumber,omitempty"`
	CardToken     *string         `json:"cardToken,omitempty"`
	Type          *CreditCardType `json:"type,omitempty"`
	LastUsed      *string         `json:"lastUsed,omitempty"`
}

type PersonCreatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type PurchaseUpdateManyInput struct {
	Create     []PurchaseCreateInput                      `json:"create,omitempty"`
	Update     []PurchaseUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []PurchaseUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []PurchaseWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []PurchaseWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []PurchaseWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []PurchaseWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []PurchaseScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []PurchaseUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type LocationCreateInput struct {
	ID          *string             `json:"id,omitempty"`
	Longitude   float64             `json:"longitude"`
	Latitude    float64             `json:"latitude"`
	Description *TextCreateOneInput `json:"description,omitempty"`
}

type PurchaseUpdateWithWhereUniqueNestedInput struct {
	Where PurchaseWhereUniqueInput `json:"where"`
	Data  PurchaseUpdateDataInput  `json:"data"`
}

type OpeningHoursCreateInput struct {
	ID          *string             `json:"id,omitempty"`
	Mon         *string             `json:"mon,omitempty"`
	Tue         *string             `json:"tue,omitempty"`
	Wed         *string             `json:"wed,omitempty"`
	Thu         *string             `json:"thu,omitempty"`
	Fri         *string             `json:"fri,omitempty"`
	Sat         *string             `json:"sat,omitempty"`
	Sun         *string             `json:"sun,omitempty"`
	Description *TextCreateOneInput `json:"description,omitempty"`
}

type PurchaseUpsertWithWhereUniqueNestedInput struct {
	Where  PurchaseWhereUniqueInput `json:"where"`
	Update PurchaseUpdateDataInput  `json:"update"`
	Create PurchaseCreateInput      `json:"create"`
}

type TicketCreateInput struct {
	ID            *string                          `json:"id,omitempty"`
	Parent        PassCreateOneWithoutTicketsInput `json:"parent"`
	Attraction    AttractionCreateOneInput         `json:"attraction"`
	Description   *TextCreateOneInput              `json:"description,omitempty"`
	AvailableTime *TextCreateOneInput              `json:"availableTime,omitempty"`
	MaxUses       int32                            `json:"maxUses"`
	Visited       bool                             `json:"visited"`
	Finished      bool                             `json:"finished"`
	State         TicketState                      `json:"state"`
}

type PurchaseScalarWhereInput struct {
	ID                           *string                    `json:"id,omitempty"`
	IDNot                        *string                    `json:"id_not,omitempty"`
	IDIn                         []string                   `json:"id_in,omitempty"`
	IDNotIn                      []string                   `json:"id_not_in,omitempty"`
	IDLt                         *string                    `json:"id_lt,omitempty"`
	IDLte                        *string                    `json:"id_lte,omitempty"`
	IDGt                         *string                    `json:"id_gt,omitempty"`
	IDGte                        *string                    `json:"id_gte,omitempty"`
	IDContains                   *string                    `json:"id_contains,omitempty"`
	IDNotContains                *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                    `json:"id_not_ends_with,omitempty"`
	CreatedAt                    *string                    `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                    `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                    `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                    `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                   `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                   `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                    `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                    `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                    `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                    `json:"updatedAt_gte,omitempty"`
	ChargeToken                  *string                    `json:"chargeToken,omitempty"`
	ChargeTokenNot               *string                    `json:"chargeToken_not,omitempty"`
	ChargeTokenIn                []string                   `json:"chargeToken_in,omitempty"`
	ChargeTokenNotIn             []string                   `json:"chargeToken_not_in,omitempty"`
	ChargeTokenLt                *string                    `json:"chargeToken_lt,omitempty"`
	ChargeTokenLte               *string                    `json:"chargeToken_lte,omitempty"`
	ChargeTokenGt                *string                    `json:"chargeToken_gt,omitempty"`
	ChargeTokenGte               *string                    `json:"chargeToken_gte,omitempty"`
	ChargeTokenContains          *string                    `json:"chargeToken_contains,omitempty"`
	ChargeTokenNotContains       *string                    `json:"chargeToken_not_contains,omitempty"`
	ChargeTokenStartsWith        *string                    `json:"chargeToken_starts_with,omitempty"`
	ChargeTokenNotStartsWith     *string                    `json:"chargeToken_not_starts_with,omitempty"`
	ChargeTokenEndsWith          *string                    `json:"chargeToken_ends_with,omitempty"`
	ChargeTokenNotEndsWith       *string                    `json:"chargeToken_not_ends_with,omitempty"`
	GatewayResponse              *string                    `json:"gatewayResponse,omitempty"`
	GatewayResponseNot           *string                    `json:"gatewayResponse_not,omitempty"`
	GatewayResponseIn            []string                   `json:"gatewayResponse_in,omitempty"`
	GatewayResponseNotIn         []string                   `json:"gatewayResponse_not_in,omitempty"`
	GatewayResponseLt            *string                    `json:"gatewayResponse_lt,omitempty"`
	GatewayResponseLte           *string                    `json:"gatewayResponse_lte,omitempty"`
	GatewayResponseGt            *string                    `json:"gatewayResponse_gt,omitempty"`
	GatewayResponseGte           *string                    `json:"gatewayResponse_gte,omitempty"`
	GatewayResponseContains      *string                    `json:"gatewayResponse_contains,omitempty"`
	GatewayResponseNotContains   *string                    `json:"gatewayResponse_not_contains,omitempty"`
	GatewayResponseStartsWith    *string                    `json:"gatewayResponse_starts_with,omitempty"`
	GatewayResponseNotStartsWith *string                    `json:"gatewayResponse_not_starts_with,omitempty"`
	GatewayResponseEndsWith      *string                    `json:"gatewayResponse_ends_with,omitempty"`
	GatewayResponseNotEndsWith   *string                    `json:"gatewayResponse_not_ends_with,omitempty"`
	DiscountId                   *string                    `json:"discountID,omitempty"`
	DiscountIdNot                *string                    `json:"discountID_not,omitempty"`
	DiscountIdIn                 []string                   `json:"discountID_in,omitempty"`
	DiscountIdNotIn              []string                   `json:"discountID_not_in,omitempty"`
	DiscountIdLt                 *string                    `json:"discountID_lt,omitempty"`
	DiscountIdLte                *string                    `json:"discountID_lte,omitempty"`
	DiscountIdGt                 *string                    `json:"discountID_gt,omitempty"`
	DiscountIdGte                *string                    `json:"discountID_gte,omitempty"`
	DiscountIdContains           *string                    `json:"discountID_contains,omitempty"`
	DiscountIdNotContains        *string                    `json:"discountID_not_contains,omitempty"`
	DiscountIdStartsWith         *string                    `json:"discountID_starts_with,omitempty"`
	DiscountIdNotStartsWith      *string                    `json:"discountID_not_starts_with,omitempty"`
	DiscountIdEndsWith           *string                    `json:"discountID_ends_with,omitempty"`
	DiscountIdNotEndsWith        *string                    `json:"discountID_not_ends_with,omitempty"`
	Discount                     *int32                     `json:"discount,omitempty"`
	DiscountNot                  *int32                     `json:"discount_not,omitempty"`
	DiscountIn                   []int32                    `json:"discount_in,omitempty"`
	DiscountNotIn                []int32                    `json:"discount_not_in,omitempty"`
	DiscountLt                   *int32                     `json:"discount_lt,omitempty"`
	DiscountLte                  *int32                     `json:"discount_lte,omitempty"`
	DiscountGt                   *int32                     `json:"discount_gt,omitempty"`
	DiscountGte                  *int32                     `json:"discount_gte,omitempty"`
	And                          []PurchaseScalarWhereInput `json:"AND,omitempty"`
	Or                           []PurchaseScalarWhereInput `json:"OR,omitempty"`
	Not                          []PurchaseScalarWhereInput `json:"NOT,omitempty"`
}

type PassTypeCreateWithoutChildrenInput struct {
	ID               *string                     `json:"id,omitempty"`
	Name             TextCreateOneInput          `json:"name"`
	ShortDescription *TextCreateOneInput         `json:"shortDescription,omitempty"`
	Description      *TextCreateOneInput         `json:"description,omitempty"`
	Disclaimer       *TextCreateOneInput         `json:"disclaimer,omitempty"`
	Gallery          *PassTypeCreategalleryInput `json:"gallery,omitempty"`
	CreatorId        string                      `json:"creatorID"`
	Attractions      *AttractionCreateManyInput  `json:"attractions,omitempty"`
	Cost             CostCreateOneInput          `json:"cost"`
	Duration         int32                       `json:"duration"`
}

type PurchaseUpdateManyWithWhereNestedInput struct {
	Where PurchaseScalarWhereInput    `json:"where"`
	Data  PurchaseUpdateManyDataInput `json:"data"`
}

type CostCreateInput struct {
	ID       *string                `json:"id,omitempty"`
	Value    float64                `json:"value"`
	Currency CurrencyCreateOneInput `json:"currency"`
}

type PurchaseUpdateManyDataInput struct {
	ChargeToken     *string `json:"chargeToken,omitempty"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type PurchaseCreateInput struct {
	ID              *string                      `json:"id,omitempty"`
	ChargeToken     string                       `json:"chargeToken"`
	GatewayResponse *string                      `json:"gatewayResponse,omitempty"`
	Products        *ProductEntryCreateManyInput `json:"products,omitempty"`
	DiscountId      *string                      `json:"discountID,omitempty"`
	Discount        *int32                       `json:"discount,omitempty"`
	PaymentMethod   PaymentMethodCreateOneInput  `json:"paymentMethod"`
}

type PassUpdateManyInput struct {
	Create     []PassCreateInput                      `json:"create,omitempty"`
	Update     []PassUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []PassUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []PassWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []PassWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []PassWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []PassWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []PassScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []PassUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type PaymentMethodCreateInput struct {
	ID         *string           `json:"id,omitempty"`
	Type       PaymentMethodType `json:"type"`
	Value      *string           `json:"value,omitempty"`
	CardNumber *string           `json:"cardNumber,omitempty"`
	Code       *string           `json:"code,omitempty"`
}

type PassUpdateWithWhereUniqueNestedInput struct {
	Where PassWhereUniqueInput `json:"where"`
	Data  PassUpdateDataInput  `json:"data"`
}

type ActionTicketCreateOneInput struct {
	Create  *ActionTicketCreateInput      `json:"create,omitempty"`
	Connect *ActionTicketWhereUniqueInput `json:"connect,omitempty"`
}

type PassUpdateDataInput struct {
	Type            *PassTypeUpdateOneRequiredWithoutChildrenInput `json:"type,omitempty"`
	Owner           *PersonUpdateOneRequiredInput                  `json:"owner,omitempty"`
	PurchaseReceive *PurchaseUpdateOneInput                        `json:"purchaseReceive,omitempty"`
	ExpireAt        *string                                        `json:"expireAt,omitempty"`
	State           *PassState                                     `json:"state,omitempty"`
	Tickets         *TicketUpdateManyWithoutParentInput            `json:"tickets,omitempty"`
}

type PassCreateManyInput struct {
	Create  []PassCreateInput      `json:"create,omitempty"`
	Connect []PassWhereUniqueInput `json:"connect,omitempty"`
}

type TicketUpdateManyWithoutParentInput struct {
	Create     []TicketCreateWithoutParentInput                `json:"create,omitempty"`
	Delete     []TicketWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []TicketWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []TicketWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []TicketWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []TicketUpdateWithWhereUniqueWithoutParentInput `json:"update,omitempty"`
	Upsert     []TicketUpsertWithWhereUniqueWithoutParentInput `json:"upsert,omitempty"`
	DeleteMany []TicketScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []TicketUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type FaqCreateOneWithoutAttractionInput struct {
	Create  *FaqCreateWithoutAttractionInput `json:"create,omitempty"`
	Connect *FaqWhereUniqueInput             `json:"connect,omitempty"`
}

type TicketUpdateWithWhereUniqueWithoutParentInput struct {
	Where TicketWhereUniqueInput             `json:"where"`
	Data  TicketUpdateWithoutParentDataInput `json:"data"`
}

type AttractionCreategalleryInput struct {
	Set []string `json:"set,omitempty"`
}

type TicketUpdateWithoutParentDataInput struct {
	Attraction    *AttractionUpdateOneRequiredInput `json:"attraction,omitempty"`
	Description   *TextUpdateOneInput               `json:"description,omitempty"`
	AvailableTime *TextUpdateOneInput               `json:"availableTime,omitempty"`
	MaxUses       *int32                            `json:"maxUses,omitempty"`
	Visited       *bool                             `json:"visited,omitempty"`
	Finished      *bool                             `json:"finished,omitempty"`
	State         *TicketState                      `json:"state,omitempty"`
}

type PlaceCreateextraTypesInput struct {
	Set []ExperienceType `json:"set,omitempty"`
}

type TicketUpsertWithWhereUniqueWithoutParentInput struct {
	Where  TicketWhereUniqueInput             `json:"where"`
	Update TicketUpdateWithoutParentDataInput `json:"update"`
	Create TicketCreateWithoutParentInput     `json:"create"`
}

type ExpertCreateOneInput struct {
	Create  *ExpertCreateInput      `json:"create,omitempty"`
	Connect *ExpertWhereUniqueInput `json:"connect,omitempty"`
}

type TicketScalarWhereInput struct {
	ID              *string                  `json:"id,omitempty"`
	IDNot           *string                  `json:"id_not,omitempty"`
	IDIn            []string                 `json:"id_in,omitempty"`
	IDNotIn         []string                 `json:"id_not_in,omitempty"`
	IDLt            *string                  `json:"id_lt,omitempty"`
	IDLte           *string                  `json:"id_lte,omitempty"`
	IDGt            *string                  `json:"id_gt,omitempty"`
	IDGte           *string                  `json:"id_gte,omitempty"`
	IDContains      *string                  `json:"id_contains,omitempty"`
	IDNotContains   *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                  `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string                  `json:"createdAt,omitempty"`
	CreatedAtNot    *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                  `json:"updatedAt_gte,omitempty"`
	MaxUses         *int32                   `json:"maxUses,omitempty"`
	MaxUsesNot      *int32                   `json:"maxUses_not,omitempty"`
	MaxUsesIn       []int32                  `json:"maxUses_in,omitempty"`
	MaxUsesNotIn    []int32                  `json:"maxUses_not_in,omitempty"`
	MaxUsesLt       *int32                   `json:"maxUses_lt,omitempty"`
	MaxUsesLte      *int32                   `json:"maxUses_lte,omitempty"`
	MaxUsesGt       *int32                   `json:"maxUses_gt,omitempty"`
	MaxUsesGte      *int32                   `json:"maxUses_gte,omitempty"`
	Visited         *bool                    `json:"visited,omitempty"`
	VisitedNot      *bool                    `json:"visited_not,omitempty"`
	Finished        *bool                    `json:"finished,omitempty"`
	FinishedNot     *bool                    `json:"finished_not,omitempty"`
	State           *TicketState             `json:"state,omitempty"`
	StateNot        *TicketState             `json:"state_not,omitempty"`
	StateIn         []TicketState            `json:"state_in,omitempty"`
	StateNotIn      []TicketState            `json:"state_not_in,omitempty"`
	And             []TicketScalarWhereInput `json:"AND,omitempty"`
	Or              []TicketScalarWhereInput `json:"OR,omitempty"`
	Not             []TicketScalarWhereInput `json:"NOT,omitempty"`
}

type StoryCreatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type TicketUpdateManyWithWhereNestedInput struct {
	Where TicketScalarWhereInput    `json:"where"`
	Data  TicketUpdateManyDataInput `json:"data"`
}

type RouteCreateWithoutLinkedStoryInput struct {
	ID         *string                            `json:"id,omitempty"`
	Name       string                             `json:"name"`
	Image      string                             `json:"image"`
	Type       ExperienceType                     `json:"type"`
	ExtraTypes *RouteCreateextraTypesInput        `json:"extraTypes,omitempty"`
	Creator    ExpertCreateOneInput               `json:"creator"`
	Places     *PlaceCreateManyWithoutRoutesInput `json:"places,omitempty"`
	LikedBy    *PersonCreateManyInput             `json:"likedBy,omitempty"`
	Reviews    *PersonReviewsCreateManyInput      `json:"reviews,omitempty"`
	Popularity *float64                           `json:"popularity,omitempty"`
	Color      string                             `json:"color"`
}

type TicketUpdateManyDataInput struct {
	MaxUses  *int32       `json:"maxUses,omitempty"`
	Visited  *bool        `json:"visited,omitempty"`
	Finished *bool        `json:"finished,omitempty"`
	State    *TicketState `json:"state,omitempty"`
}

type PurchaseSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *PurchaseWhereInput              `json:"node,omitempty"`
	And                        []PurchaseSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PurchaseSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PurchaseSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PassUpsertWithWhereUniqueNestedInput struct {
	Where  PassWhereUniqueInput `json:"where"`
	Update PassUpdateDataInput  `json:"update"`
	Create PassCreateInput      `json:"create"`
}

type PaymentMethodSubscriptionWhereInput struct {
	MutationIn                 []MutationType                        `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                               `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                              `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                              `json:"updatedFields_contains_some,omitempty"`
	Node                       *PaymentMethodWhereInput              `json:"node,omitempty"`
	And                        []PaymentMethodSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PaymentMethodSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PaymentMethodSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PassScalarWhereInput struct {
	ID              *string                `json:"id,omitempty"`
	IDNot           *string                `json:"id_not,omitempty"`
	IDIn            []string               `json:"id_in,omitempty"`
	IDNotIn         []string               `json:"id_not_in,omitempty"`
	IDLt            *string                `json:"id_lt,omitempty"`
	IDLte           *string                `json:"id_lte,omitempty"`
	IDGt            *string                `json:"id_gt,omitempty"`
	IDGte           *string                `json:"id_gte,omitempty"`
	IDContains      *string                `json:"id_contains,omitempty"`
	IDNotContains   *string                `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string                `json:"createdAt,omitempty"`
	CreatedAtNot    *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                `json:"updatedAt_gte,omitempty"`
	ExpireAt        *string                `json:"expireAt,omitempty"`
	ExpireAtNot     *string                `json:"expireAt_not,omitempty"`
	ExpireAtIn      []string               `json:"expireAt_in,omitempty"`
	ExpireAtNotIn   []string               `json:"expireAt_not_in,omitempty"`
	ExpireAtLt      *string                `json:"expireAt_lt,omitempty"`
	ExpireAtLte     *string                `json:"expireAt_lte,omitempty"`
	ExpireAtGt      *string                `json:"expireAt_gt,omitempty"`
	ExpireAtGte     *string                `json:"expireAt_gte,omitempty"`
	State           *PassState             `json:"state,omitempty"`
	StateNot        *PassState             `json:"state_not,omitempty"`
	StateIn         []PassState            `json:"state_in,omitempty"`
	StateNotIn      []PassState            `json:"state_not_in,omitempty"`
	And             []PassScalarWhereInput `json:"AND,omitempty"`
	Or              []PassScalarWhereInput `json:"OR,omitempty"`
	Not             []PassScalarWhereInput `json:"NOT,omitempty"`
}

type IDDocumentSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *IDDocumentWhereInput              `json:"node,omitempty"`
	And                        []IDDocumentSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []IDDocumentSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []IDDocumentSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PassUpdateManyWithWhereNestedInput struct {
	Where PassScalarWhereInput    `json:"where"`
	Data  PassUpdateManyDataInput `json:"data"`
}

type TextWhereInput struct {
	ID                   *string          `json:"id,omitempty"`
	IDNot                *string          `json:"id_not,omitempty"`
	IDIn                 []string         `json:"id_in,omitempty"`
	IDNotIn              []string         `json:"id_not_in,omitempty"`
	IDLt                 *string          `json:"id_lt,omitempty"`
	IDLte                *string          `json:"id_lte,omitempty"`
	IDGt                 *string          `json:"id_gt,omitempty"`
	IDGte                *string          `json:"id_gte,omitempty"`
	IDContains           *string          `json:"id_contains,omitempty"`
	IDNotContains        *string          `json:"id_not_contains,omitempty"`
	IDStartsWith         *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string          `json:"id_not_ends_with,omitempty"`
	English              *string          `json:"english,omitempty"`
	EnglishNot           *string          `json:"english_not,omitempty"`
	EnglishIn            []string         `json:"english_in,omitempty"`
	EnglishNotIn         []string         `json:"english_not_in,omitempty"`
	EnglishLt            *string          `json:"english_lt,omitempty"`
	EnglishLte           *string          `json:"english_lte,omitempty"`
	EnglishGt            *string          `json:"english_gt,omitempty"`
	EnglishGte           *string          `json:"english_gte,omitempty"`
	EnglishContains      *string          `json:"english_contains,omitempty"`
	EnglishNotContains   *string          `json:"english_not_contains,omitempty"`
	EnglishStartsWith    *string          `json:"english_starts_with,omitempty"`
	EnglishNotStartsWith *string          `json:"english_not_starts_with,omitempty"`
	EnglishEndsWith      *string          `json:"english_ends_with,omitempty"`
	EnglishNotEndsWith   *string          `json:"english_not_ends_with,omitempty"`
	Spanish              *string          `json:"spanish,omitempty"`
	SpanishNot           *string          `json:"spanish_not,omitempty"`
	SpanishIn            []string         `json:"spanish_in,omitempty"`
	SpanishNotIn         []string         `json:"spanish_not_in,omitempty"`
	SpanishLt            *string          `json:"spanish_lt,omitempty"`
	SpanishLte           *string          `json:"spanish_lte,omitempty"`
	SpanishGt            *string          `json:"spanish_gt,omitempty"`
	SpanishGte           *string          `json:"spanish_gte,omitempty"`
	SpanishContains      *string          `json:"spanish_contains,omitempty"`
	SpanishNotContains   *string          `json:"spanish_not_contains,omitempty"`
	SpanishStartsWith    *string          `json:"spanish_starts_with,omitempty"`
	SpanishNotStartsWith *string          `json:"spanish_not_starts_with,omitempty"`
	SpanishEndsWith      *string          `json:"spanish_ends_with,omitempty"`
	SpanishNotEndsWith   *string          `json:"spanish_not_ends_with,omitempty"`
	And                  []TextWhereInput `json:"AND,omitempty"`
	Or                   []TextWhereInput `json:"OR,omitempty"`
	Not                  []TextWhereInput `json:"NOT,omitempty"`
}

type PassUpdateManyDataInput struct {
	ExpireAt *string    `json:"expireAt,omitempty"`
	State    *PassState `json:"state,omitempty"`
}

type CreditCardSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *CreditCardWhereInput              `json:"node,omitempty"`
	And                        []CreditCardSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CreditCardSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CreditCardSubscriptionWhereInput `json:"NOT,omitempty"`
}

type TravelerUpsertWithoutRegistryInput struct {
	Update TravelerUpdateWithoutRegistryDataInput `json:"update"`
	Create TravelerCreateWithoutRegistryInput     `json:"create"`
}

type TravelerUpdateInput struct {
	Unregistered       *bool                                      `json:"unregistered,omitempty"`
	RegistrationTicket *ActionTicketUpdateOneInput                `json:"registrationTicket,omitempty"`
	Person             *PersonUpdateOneRequiredInput              `json:"person,omitempty"`
	Username           *string                                    `json:"username,omitempty"`
	Cards              *CreditCardUpdateManyWithoutOwnerInput     `json:"cards,omitempty"`
	Purchases          *PurchaseUpdateManyInput                   `json:"purchases,omitempty"`
	Passes             *PassUpdateManyInput                       `json:"passes,omitempty"`
	Registry           *EntryTicketUpdateManyWithoutTravelerInput `json:"registry,omitempty"`
}

type EntryTicketUpsertWithWhereUniqueWithoutPartnerInput struct {
	Where  EntryTicketWhereUniqueInput              `json:"where"`
	Update EntryTicketUpdateWithoutPartnerDataInput `json:"update"`
	Create EntryTicketCreateWithoutPartnerInput     `json:"create"`
}

type EmailChannelWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type EntryTicketScalarWhereInput struct {
	ID              *string                       `json:"id,omitempty"`
	IDNot           *string                       `json:"id_not,omitempty"`
	IDIn            []string                      `json:"id_in,omitempty"`
	IDNotIn         []string                      `json:"id_not_in,omitempty"`
	IDLt            *string                       `json:"id_lt,omitempty"`
	IDLte           *string                       `json:"id_lte,omitempty"`
	IDGt            *string                       `json:"id_gt,omitempty"`
	IDGte           *string                       `json:"id_gte,omitempty"`
	IDContains      *string                       `json:"id_contains,omitempty"`
	IDNotContains   *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                       `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string                       `json:"createdAt,omitempty"`
	CreatedAtNot    *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                       `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                       `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                       `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                      `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                      `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                       `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                       `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                       `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                       `json:"updatedAt_gte,omitempty"`
	At              *string                       `json:"at,omitempty"`
	AtNot           *string                       `json:"at_not,omitempty"`
	AtIn            []string                      `json:"at_in,omitempty"`
	AtNotIn         []string                      `json:"at_not_in,omitempty"`
	AtLt            *string                       `json:"at_lt,omitempty"`
	AtLte           *string                       `json:"at_lte,omitempty"`
	AtGt            *string                       `json:"at_gt,omitempty"`
	AtGte           *string                       `json:"at_gte,omitempty"`
	And             []EntryTicketScalarWhereInput `json:"AND,omitempty"`
	Or              []EntryTicketScalarWhereInput `json:"OR,omitempty"`
	Not             []EntryTicketScalarWhereInput `json:"NOT,omitempty"`
}

type ErrorWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type EntryTicketUpdateManyWithWhereNestedInput struct {
	Where EntryTicketScalarWhereInput    `json:"where"`
	Data  EntryTicketUpdateManyDataInput `json:"data"`
}

type PersonUpsertWithoutPhonesInput struct {
	Update PersonUpdateWithoutPhonesDataInput `json:"update"`
	Create PersonCreateWithoutPhonesInput     `json:"create"`
}

type EntryTicketUpdateManyDataInput struct {
	At *string `json:"at,omitempty"`
}

type FaqEntryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PartnerUpsertWithoutAttractionsInput struct {
	Update PartnerUpdateWithoutAttractionsDataInput `json:"update"`
	Create PartnerCreateWithoutAttractionsInput     `json:"create"`
}

type IDDocumentWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AttractionUpdateManyMutationInput struct {
	PrincipalImage *string                       `json:"principalImage,omitempty"`
	CoverImage     *string                       `json:"coverImage,omitempty"`
	LandscapeImage *string                       `json:"landscapeImage,omitempty"`
	Gallery        *AttractionUpdategalleryInput `json:"gallery,omitempty"`
	Type           *AttractionUpdatetypeInput    `json:"type,omitempty"`
}

type PassTypeUpdateInput struct {
	Name             *TextUpdateOneRequiredInput     `json:"name,omitempty"`
	ShortDescription *TextUpdateOneInput             `json:"shortDescription,omitempty"`
	Description      *TextUpdateOneInput             `json:"description,omitempty"`
	Disclaimer       *TextUpdateOneInput             `json:"disclaimer,omitempty"`
	Gallery          *PassTypeUpdategalleryInput     `json:"gallery,omitempty"`
	CreatorId        *string                         `json:"creatorID,omitempty"`
	Attractions      *AttractionUpdateManyInput      `json:"attractions,omitempty"`
	Cost             *CostUpdateOneRequiredInput     `json:"cost,omitempty"`
	Duration         *int32                          `json:"duration,omitempty"`
	Children         *PassUpdateManyWithoutTypeInput `json:"children,omitempty"`
}

type CostUpdateInput struct {
	Value    *float64                        `json:"value,omitempty"`
	Currency *CurrencyUpdateOneRequiredInput `json:"currency,omitempty"`
}

type PassUpdateInput struct {
	Type            *PassTypeUpdateOneRequiredWithoutChildrenInput `json:"type,omitempty"`
	Owner           *PersonUpdateOneRequiredInput                  `json:"owner,omitempty"`
	PurchaseReceive *PurchaseUpdateOneInput                        `json:"purchaseReceive,omitempty"`
	ExpireAt        *string                                        `json:"expireAt,omitempty"`
	State           *PassState                                     `json:"state,omitempty"`
	Tickets         *TicketUpdateManyWithoutParentInput            `json:"tickets,omitempty"`
}

type CostUpdateManyMutationInput struct {
	Value *float64 `json:"value,omitempty"`
}

type LimaContactUpdateManyMutationInput struct {
	Email       *string `json:"email,omitempty"`
	PhoneNumber *string `json:"phoneNumber,omitempty"`
}

type CredentialCreateInput struct {
	ID             *string                                `json:"id,omitempty"`
	DisplayName    *string                                `json:"displayName,omitempty"`
	Owner          PersonCreateOneWithoutCredentialsInput `json:"owner"`
	IsMain         bool                                   `json:"isMain"`
	Type           *CredentialType                        `json:"type,omitempty"`
	Validated      *bool                                  `json:"validated,omitempty"`
	ValidationId   *string                                `json:"validationID,omitempty"`
	Value          string                                 `json:"value"`
	RawPassword    *string                                `json:"rawPassword,omitempty"`
	HashedPassword string                                 `json:"hashedPassword"`
}

type LimaContactUpsertNestedInput struct {
	Update LimaContactUpdateDataInput `json:"update"`
	Create LimaContactCreateInput     `json:"create"`
}

type PersonCreateOneWithoutCredentialsInput struct {
	Create  *PersonCreateWithoutCredentialsInput `json:"create,omitempty"`
	Connect *PersonWhereUniqueInput              `json:"connect,omitempty"`
}

type StoryUpdateWithWhereUniqueNestedInput struct {
	Where StoryWhereUniqueInput `json:"where"`
	Data  StoryUpdateDataInput  `json:"data"`
}

type PersonCreateWithoutCredentialsInput struct {
	ID             *string                                   `json:"id,omitempty"`
	QmId           *string                                   `json:"qmID,omitempty"`
	Name           string                                    `json:"name"`
	Photo          *string                                   `json:"photo,omitempty"`
	Birthdate      *string                                   `json:"birthdate,omitempty"`
	Country        *TextCreateOneInput                       `json:"country,omitempty"`
	Phones         *PhoneChannelCreateManyWithoutPersonInput `json:"phones,omitempty"`
	Emails         *EmailChannelCreateManyWithoutPersonInput `json:"emails,omitempty"`
	IDentification IDDocumentCreateOneWithoutPersonInput     `json:"identification"`
	Tags           *PersonCreatetagsInput                    `json:"tags,omitempty"`
}

type PersonWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type CredentialUpdateInput struct {
	DisplayName    *string                                         `json:"displayName,omitempty"`
	Owner          *PersonUpdateOneRequiredWithoutCredentialsInput `json:"owner,omitempty"`
	IsMain         *bool                                           `json:"isMain,omitempty"`
	Type           *CredentialType                                 `json:"type,omitempty"`
	Validated      *bool                                           `json:"validated,omitempty"`
	ValidationId   *string                                         `json:"validationID,omitempty"`
	Value          *string                                         `json:"value,omitempty"`
	RawPassword    *string                                         `json:"rawPassword,omitempty"`
	HashedPassword *string                                         `json:"hashedPassword,omitempty"`
}

type PhoneChannelWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PersonUpdateOneRequiredWithoutCredentialsInput struct {
	Create  *PersonCreateWithoutCredentialsInput     `json:"create,omitempty"`
	Update  *PersonUpdateWithoutCredentialsDataInput `json:"update,omitempty"`
	Upsert  *PersonUpsertWithoutCredentialsInput     `json:"upsert,omitempty"`
	Connect *PersonWhereUniqueInput                  `json:"connect,omitempty"`
}

type ProductEntryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PersonUpdateWithoutCredentialsDataInput struct {
	QmId           *string                                        `json:"qmID,omitempty"`
	Name           *string                                        `json:"name,omitempty"`
	Photo          *string                                        `json:"photo,omitempty"`
	Birthdate      *string                                        `json:"birthdate,omitempty"`
	Country        *TextUpdateOneInput                            `json:"country,omitempty"`
	Phones         *PhoneChannelUpdateManyWithoutPersonInput      `json:"phones,omitempty"`
	Emails         *EmailChannelUpdateManyWithoutPersonInput      `json:"emails,omitempty"`
	IDentification *IDDocumentUpdateOneRequiredWithoutPersonInput `json:"identification,omitempty"`
	Tags           *PersonUpdatetagsInput                         `json:"tags,omitempty"`
}

type RouteWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PersonUpsertWithoutCredentialsInput struct {
	Update PersonUpdateWithoutCredentialsDataInput `json:"update"`
	Create PersonCreateWithoutCredentialsInput     `json:"create"`
}

type TextWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type CredentialUpdateManyMutationInput struct {
	DisplayName    *string         `json:"displayName,omitempty"`
	IsMain         *bool           `json:"isMain,omitempty"`
	Type           *CredentialType `json:"type,omitempty"`
	Validated      *bool           `json:"validated,omitempty"`
	ValidationId   *string         `json:"validationID,omitempty"`
	Value          *string         `json:"value,omitempty"`
	RawPassword    *string         `json:"rawPassword,omitempty"`
	HashedPassword *string         `json:"hashedPassword,omitempty"`
}

type FaqCreateOneWithoutEntriesInput struct {
	Create  *FaqCreateWithoutEntriesInput `json:"create,omitempty"`
	Connect *FaqWhereUniqueInput          `json:"connect,omitempty"`
}

type CreditCardCreateInput struct {
	ID            *string                            `json:"id,omitempty"`
	Owner         TravelerCreateOneWithoutCardsInput `json:"owner"`
	CustomerToken string                             `json:"customerToken"`
	CardNumber    string                             `json:"cardNumber"`
	CardToken     string                             `json:"cardToken"`
	Type          *CreditCardType                    `json:"type,omitempty"`
	LastUsed      *string                            `json:"lastUsed,omitempty"`
}

type ActionTicketUpdateInput struct {
	Type      *ActionTicketType `json:"type,omitempty"`
	Token     *string           `json:"token,omitempty"`
	Available *bool             `json:"available,omitempty"`
	Used      *bool             `json:"used,omitempty"`
}

type TravelerCreateOneWithoutCardsInput struct {
	Create  *TravelerCreateWithoutCardsInput `json:"create,omitempty"`
	Connect *TravelerWhereUniqueInput        `json:"connect,omitempty"`
}

type PersonCreateInput struct {
	ID             *string                                   `json:"id,omitempty"`
	QmId           *string                                   `json:"qmID,omitempty"`
	Name           string                                    `json:"name"`
	Photo          *string                                   `json:"photo,omitempty"`
	Birthdate      *string                                   `json:"birthdate,omitempty"`
	Country        *TextCreateOneInput                       `json:"country,omitempty"`
	Phones         *PhoneChannelCreateManyWithoutPersonInput `json:"phones,omitempty"`
	Emails         *EmailChannelCreateManyWithoutPersonInput `json:"emails,omitempty"`
	IDentification IDDocumentCreateOneWithoutPersonInput     `json:"identification"`
	Tags           *PersonCreatetagsInput                    `json:"tags,omitempty"`
	Credentials    *CredentialCreateManyWithoutOwnerInput    `json:"credentials,omitempty"`
}

type TravelerCreateWithoutCardsInput struct {
	ID                 *string                                    `json:"id,omitempty"`
	Unregistered       *bool                                      `json:"unregistered,omitempty"`
	RegistrationTicket *ActionTicketCreateOneInput                `json:"registrationTicket,omitempty"`
	Person             PersonCreateOneInput                       `json:"person"`
	Username           *string                                    `json:"username,omitempty"`
	Purchases          *PurchaseCreateManyInput                   `json:"purchases,omitempty"`
	Passes             *PassCreateManyInput                       `json:"passes,omitempty"`
	Registry           *EntryTicketCreateManyWithoutTravelerInput `json:"registry,omitempty"`
}

type IDDocumentCreateOneWithoutPersonInput struct {
	Create  *IDDocumentCreateWithoutPersonInput `json:"create,omitempty"`
	Connect *IDDocumentWhereUniqueInput         `json:"connect,omitempty"`
}

type EntryTicketCreateManyWithoutTravelerInput struct {
	Create  []EntryTicketCreateWithoutTravelerInput `json:"create,omitempty"`
	Connect []EntryTicketWhereUniqueInput           `json:"connect,omitempty"`
}

type FeatureCreateInput struct {
	ID    *string             `json:"id,omitempty"`
	Name  *TextCreateOneInput `json:"name,omitempty"`
	Image *string             `json:"image,omitempty"`
}

type EntryTicketCreateWithoutTravelerInput struct {
	ID      *string                              `json:"id,omitempty"`
	At      string                               `json:"at"`
	Ticket  TicketCreateOneInput                 `json:"ticket"`
	Partner PartnerCreateOneWithoutRegistryInput `json:"partner"`
}

type PassCreateWithoutTicketsInput struct {
	ID              *string                               `json:"id,omitempty"`
	Type            PassTypeCreateOneWithoutChildrenInput `json:"type"`
	Owner           PersonCreateOneInput                  `json:"owner"`
	PurchaseReceive *PurchaseCreateOneInput               `json:"purchaseReceive,omitempty"`
	ExpireAt        string                                `json:"expireAt"`
	State           *PassState                            `json:"state,omitempty"`
}

type PartnerCreateOneWithoutRegistryInput struct {
	Create  *PartnerCreateWithoutRegistryInput `json:"create,omitempty"`
	Connect *PartnerWhereUniqueInput           `json:"connect,omitempty"`
}

type CurrencyCreateInput struct {
	ID     *string            `json:"id,omitempty"`
	Name   TextCreateOneInput `json:"name"`
	Code   *string            `json:"code,omitempty"`
	Symbol string             `json:"symbol"`
}

type PartnerCreateWithoutRegistryInput struct {
	ID           *string                                `json:"id,omitempty"`
	Attender     PersonCreateOneInput                   `json:"attender"`
	Owner        *PersonCreateOneInput                  `json:"owner,omitempty"`
	Attractions  *AttractionCreateManyWithoutOwnerInput `json:"attractions,omitempty"`
	BrandName    string                                 `json:"brandName"`
	Logo         string                                 `json:"logo"`
	SocialReason string                                 `json:"socialReason"`
	Ruc          string                                 `json:"ruc"`
	Address      string                                 `json:"address"`
	Location     LocationCreateOneInput                 `json:"location"`
	Features     *FeatureCreateManyInput                `json:"features,omitempty"`
	ServiceHours *OpeningHoursCreateOneInput            `json:"serviceHours,omitempty"`
}

type TravelerCreateOneWithoutRegistryInput struct {
	Create  *TravelerCreateWithoutRegistryInput `json:"create,omitempty"`
	Connect *TravelerWhereUniqueInput           `json:"connect,omitempty"`
}

type AttractionCreateManyWithoutOwnerInput struct {
	Create  []AttractionCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []AttractionWhereUniqueInput        `json:"connect,omitempty"`
}

type TicketCreateManyWithoutParentInput struct {
	Create  []TicketCreateWithoutParentInput `json:"create,omitempty"`
	Connect []TicketWhereUniqueInput         `json:"connect,omitempty"`
}

type AttractionCreateWithoutOwnerInput struct {
	ID               *string                            `json:"id,omitempty"`
	Name             TextCreateOneInput                 `json:"name"`
	Description      *TextCreateOneInput                `json:"description,omitempty"`
	ShortDescription *TextCreateOneInput                `json:"shortDescription,omitempty"`
	Faqs             FaqCreateOneWithoutAttractionInput `json:"faqs"`
	PrincipalImage   *string                            `json:"principalImage,omitempty"`
	CoverImage       *string                            `json:"coverImage,omitempty"`
	LandscapeImage   *string                            `json:"landscapeImage,omitempty"`
	Gallery          *AttractionCreategalleryInput      `json:"gallery,omitempty"`
	Type             *AttractionCreatetypeInput         `json:"type,omitempty"`
	Place            PlaceCreateOneInput                `json:"place"`
}

type PlaceCreateOneInput struct {
	Create  *PlaceCreateInput      `json:"create,omitempty"`
	Connect *PlaceWhereUniqueInput `json:"connect,omitempty"`
}

type CreditCardUpdateInput struct {
	Owner         *TravelerUpdateOneRequiredWithoutCardsInput `json:"owner,omitempty"`
	CustomerToken *string                                     `json:"customerToken,omitempty"`
	CardNumber    *string                                     `json:"cardNumber,omitempty"`
	CardToken     *string                                     `json:"cardToken,omitempty"`
	Type          *CreditCardType                             `json:"type,omitempty"`
	LastUsed      *string                                     `json:"lastUsed,omitempty"`
}

type StoryCreateManyWithoutAuthorInput struct {
	Create  []StoryCreateWithoutAuthorInput `json:"create,omitempty"`
	Connect []StoryWhereUniqueInput         `json:"connect,omitempty"`
}

type TravelerUpdateOneRequiredWithoutCardsInput struct {
	Create  *TravelerCreateWithoutCardsInput     `json:"create,omitempty"`
	Update  *TravelerUpdateWithoutCardsDataInput `json:"update,omitempty"`
	Upsert  *TravelerUpsertWithoutCardsInput     `json:"upsert,omitempty"`
	Connect *TravelerWhereUniqueInput            `json:"connect,omitempty"`
}

type LocationWhereInput struct {
	ID              *string              `json:"id,omitempty"`
	IDNot           *string              `json:"id_not,omitempty"`
	IDIn            []string             `json:"id_in,omitempty"`
	IDNotIn         []string             `json:"id_not_in,omitempty"`
	IDLt            *string              `json:"id_lt,omitempty"`
	IDLte           *string              `json:"id_lte,omitempty"`
	IDGt            *string              `json:"id_gt,omitempty"`
	IDGte           *string              `json:"id_gte,omitempty"`
	IDContains      *string              `json:"id_contains,omitempty"`
	IDNotContains   *string              `json:"id_not_contains,omitempty"`
	IDStartsWith    *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string              `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string              `json:"createdAt,omitempty"`
	CreatedAtNot    *string              `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string             `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string             `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string              `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string              `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string              `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string              `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string              `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string              `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string             `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string             `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string              `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string              `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string              `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string              `json:"updatedAt_gte,omitempty"`
	Longitude       *float64             `json:"longitude,omitempty"`
	LongitudeNot    *float64             `json:"longitude_not,omitempty"`
	LongitudeIn     []float64            `json:"longitude_in,omitempty"`
	LongitudeNotIn  []float64            `json:"longitude_not_in,omitempty"`
	LongitudeLt     *float64             `json:"longitude_lt,omitempty"`
	LongitudeLte    *float64             `json:"longitude_lte,omitempty"`
	LongitudeGt     *float64             `json:"longitude_gt,omitempty"`
	LongitudeGte    *float64             `json:"longitude_gte,omitempty"`
	Latitude        *float64             `json:"latitude,omitempty"`
	LatitudeNot     *float64             `json:"latitude_not,omitempty"`
	LatitudeIn      []float64            `json:"latitude_in,omitempty"`
	LatitudeNotIn   []float64            `json:"latitude_not_in,omitempty"`
	LatitudeLt      *float64             `json:"latitude_lt,omitempty"`
	LatitudeLte     *float64             `json:"latitude_lte,omitempty"`
	LatitudeGt      *float64             `json:"latitude_gt,omitempty"`
	LatitudeGte     *float64             `json:"latitude_gte,omitempty"`
	Description     *TextWhereInput      `json:"description,omitempty"`
	And             []LocationWhereInput `json:"AND,omitempty"`
	Or              []LocationWhereInput `json:"OR,omitempty"`
	Not             []LocationWhereInput `json:"NOT,omitempty"`
}

type TravelerUpdateWithoutCardsDataInput struct {
	Unregistered       *bool                                      `json:"unregistered,omitempty"`
	RegistrationTicket *ActionTicketUpdateOneInput                `json:"registrationTicket,omitempty"`
	Person             *PersonUpdateOneRequiredInput              `json:"person,omitempty"`
	Username           *string                                    `json:"username,omitempty"`
	Purchases          *PurchaseUpdateManyInput                   `json:"purchases,omitempty"`
	Passes             *PassUpdateManyInput                       `json:"passes,omitempty"`
	Registry           *EntryTicketUpdateManyWithoutTravelerInput `json:"registry,omitempty"`
}

type OpeningHoursSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *OpeningHoursWhereInput              `json:"node,omitempty"`
	And                        []OpeningHoursSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []OpeningHoursSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []OpeningHoursSubscriptionWhereInput `json:"NOT,omitempty"`
}

type EntryTicketUpdateManyWithoutTravelerInput struct {
	Create     []EntryTicketCreateWithoutTravelerInput                `json:"create,omitempty"`
	Delete     []EntryTicketWhereUniqueInput                          `json:"delete,omitempty"`
	Connect    []EntryTicketWhereUniqueInput                          `json:"connect,omitempty"`
	Set        []EntryTicketWhereUniqueInput                          `json:"set,omitempty"`
	Disconnect []EntryTicketWhereUniqueInput                          `json:"disconnect,omitempty"`
	Update     []EntryTicketUpdateWithWhereUniqueWithoutTravelerInput `json:"update,omitempty"`
	Upsert     []EntryTicketUpsertWithWhereUniqueWithoutTravelerInput `json:"upsert,omitempty"`
	DeleteMany []EntryTicketScalarWhereInput                          `json:"deleteMany,omitempty"`
	UpdateMany []EntryTicketUpdateManyWithWhereNestedInput            `json:"updateMany,omitempty"`
}

type EntryTicketSubscriptionWhereInput struct {
	MutationIn                 []MutationType                      `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                             `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                            `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                            `json:"updatedFields_contains_some,omitempty"`
	Node                       *EntryTicketWhereInput              `json:"node,omitempty"`
	And                        []EntryTicketSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []EntryTicketSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []EntryTicketSubscriptionWhereInput `json:"NOT,omitempty"`
}

type EntryTicketUpdateWithWhereUniqueWithoutTravelerInput struct {
	Where EntryTicketWhereUniqueInput               `json:"where"`
	Data  EntryTicketUpdateWithoutTravelerDataInput `json:"data"`
}

type TicketUpdateInput struct {
	Parent        *PassUpdateOneRequiredWithoutTicketsInput `json:"parent,omitempty"`
	Attraction    *AttractionUpdateOneRequiredInput         `json:"attraction,omitempty"`
	Description   *TextUpdateOneInput                       `json:"description,omitempty"`
	AvailableTime *TextUpdateOneInput                       `json:"availableTime,omitempty"`
	MaxUses       *int32                                    `json:"maxUses,omitempty"`
	Visited       *bool                                     `json:"visited,omitempty"`
	Finished      *bool                                     `json:"finished,omitempty"`
	State         *TicketState                              `json:"state,omitempty"`
}

type EntryTicketUpdateWithoutTravelerDataInput struct {
	At      *string                                       `json:"at,omitempty"`
	Ticket  *TicketUpdateOneRequiredInput                 `json:"ticket,omitempty"`
	Partner *PartnerUpdateOneRequiredWithoutRegistryInput `json:"partner,omitempty"`
}

type PlaceUpdateManyMutationInput struct {
	Name             *string                     `json:"name,omitempty"`
	ShortName        *string                     `json:"shortName,omitempty"`
	Address          *string                     `json:"address,omitempty"`
	GoogleLink       *string                     `json:"googleLink,omitempty"`
	Website          *string                     `json:"website,omitempty"`
	Type             *ExperienceType             `json:"type,omitempty"`
	ExtraTypes       *PlaceUpdateextraTypesInput `json:"extraTypes,omitempty"`
	Tags             *PlaceUpdatetagsInput       `json:"tags,omitempty"`
	Popularity       *float64                    `json:"popularity,omitempty"`
	ProviderWeb      *string                     `json:"providerWeb,omitempty"`
	ContactPhone     *string                     `json:"contactPhone,omitempty"`
	ContactEmail     *string                     `json:"contactEmail,omitempty"`
	AddressReference *string                     `json:"addressReference,omitempty"`
}

type PartnerUpdateOneRequiredWithoutRegistryInput struct {
	Create  *PartnerCreateWithoutRegistryInput     `json:"create,omitempty"`
	Update  *PartnerUpdateWithoutRegistryDataInput `json:"update,omitempty"`
	Upsert  *PartnerUpsertWithoutRegistryInput     `json:"upsert,omitempty"`
	Connect *PartnerWhereUniqueInput               `json:"connect,omitempty"`
}

type FeatureWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PartnerUpdateWithoutRegistryDataInput struct {
	Attender     *PersonUpdateOneRequiredInput          `json:"attender,omitempty"`
	Owner        *PersonUpdateOneInput                  `json:"owner,omitempty"`
	Attractions  *AttractionUpdateManyWithoutOwnerInput `json:"attractions,omitempty"`
	BrandName    *string                                `json:"brandName,omitempty"`
	Logo         *string                                `json:"logo,omitempty"`
	SocialReason *string                                `json:"socialReason,omitempty"`
	Ruc          *string                                `json:"ruc,omitempty"`
	Address      *string                                `json:"address,omitempty"`
	Location     *LocationUpdateOneRequiredInput        `json:"location,omitempty"`
	Features     *FeatureUpdateManyInput                `json:"features,omitempty"`
	ServiceHours *OpeningHoursUpdateOneInput            `json:"serviceHours,omitempty"`
}

type PassCreateManyWithoutTypeInput struct {
	Create  []PassCreateWithoutTypeInput `json:"create,omitempty"`
	Connect []PassWhereUniqueInput       `json:"connect,omitempty"`
}

type AttractionUpdateManyWithoutOwnerInput struct {
	Create     []AttractionCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []AttractionWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []AttractionWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []AttractionWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []AttractionWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []AttractionUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []AttractionUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []AttractionScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []AttractionUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type FaqUpsertNestedInput struct {
	Update FaqUpdateDataInput `json:"update"`
	Create FaqCreateInput     `json:"create"`
}

type AttractionUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where AttractionWhereUniqueInput            `json:"where"`
	Data  AttractionUpdateWithoutOwnerDataInput `json:"data"`
}

type PartnerUpdateManyWithWhereNestedInput struct {
	Where PartnerScalarWhereInput    `json:"where"`
	Data  PartnerUpdateManyDataInput `json:"data"`
}

type AttractionUpdateWithoutOwnerDataInput struct {
	Name             *TextUpdateOneRequiredInput                 `json:"name,omitempty"`
	Description      *TextUpdateOneInput                         `json:"description,omitempty"`
	ShortDescription *TextUpdateOneInput                         `json:"shortDescription,omitempty"`
	Faqs             *FaqUpdateOneRequiredWithoutAttractionInput `json:"faqs,omitempty"`
	PrincipalImage   *string                                     `json:"principalImage,omitempty"`
	CoverImage       *string                                     `json:"coverImage,omitempty"`
	LandscapeImage   *string                                     `json:"landscapeImage,omitempty"`
	Gallery          *AttractionUpdategalleryInput               `json:"gallery,omitempty"`
	Type             *AttractionUpdatetypeInput                  `json:"type,omitempty"`
	Place            *PlaceUpdateOneRequiredInput                `json:"place,omitempty"`
}

type PlaceWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AttractionUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  AttractionWhereUniqueInput            `json:"where"`
	Update AttractionUpdateWithoutOwnerDataInput `json:"update"`
	Create AttractionCreateWithoutOwnerInput     `json:"create"`
}

type StoryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PartnerUpsertWithoutRegistryInput struct {
	Update PartnerUpdateWithoutRegistryDataInput `json:"update"`
	Create PartnerCreateWithoutRegistryInput     `json:"create"`
}

type AttractionUpdateWithoutFaqsDataInput struct {
	Owner            *PartnerUpdateOneRequiredWithoutAttractionsInput `json:"owner,omitempty"`
	Name             *TextUpdateOneRequiredInput                      `json:"name,omitempty"`
	Description      *TextUpdateOneInput                              `json:"description,omitempty"`
	ShortDescription *TextUpdateOneInput                              `json:"shortDescription,omitempty"`
	PrincipalImage   *string                                          `json:"principalImage,omitempty"`
	CoverImage       *string                                          `json:"coverImage,omitempty"`
	LandscapeImage   *string                                          `json:"landscapeImage,omitempty"`
	Gallery          *AttractionUpdategalleryInput                    `json:"gallery,omitempty"`
	Type             *AttractionUpdatetypeInput                       `json:"type,omitempty"`
	Place            *PlaceUpdateOneRequiredInput                     `json:"place,omitempty"`
}

type EntryTicketUpsertWithWhereUniqueWithoutTravelerInput struct {
	Where  EntryTicketWhereUniqueInput               `json:"where"`
	Update EntryTicketUpdateWithoutTravelerDataInput `json:"update"`
	Create EntryTicketCreateWithoutTravelerInput     `json:"create"`
}

type PhoneChannelCreateWithoutPersonInput struct {
	ID          *string `json:"id,omitempty"`
	IsMain      *bool   `json:"isMain,omitempty"`
	DisplayName string  `json:"displayName"`
	Valid       *bool   `json:"valid,omitempty"`
	CountryCode string  `json:"countryCode"`
	Number      *string `json:"number,omitempty"`
}

type TravelerUpsertWithoutCardsInput struct {
	Update TravelerUpdateWithoutCardsDataInput `json:"update"`
	Create TravelerCreateWithoutCardsInput     `json:"create"`
}

type EntryTicketCreateWithoutPartnerInput struct {
	ID       *string                               `json:"id,omitempty"`
	At       string                                `json:"at"`
	Ticket   TicketCreateOneInput                  `json:"ticket"`
	Traveler TravelerCreateOneWithoutRegistryInput `json:"traveler"`
}

type CreditCardUpdateManyMutationInput struct {
	CustomerToken *string         `json:"customerToken,omitempty"`
	CardNumber    *string         `json:"cardNumber,omitempty"`
	CardToken     *string         `json:"cardToken,omitempty"`
	Type          *CreditCardType `json:"type,omitempty"`
	LastUsed      *string         `json:"lastUsed,omitempty"`
}

type ProductEntryCreateInput struct {
	ID           *string `json:"id,omitempty"`
	ParentId     string  `json:"parentID"`
	Name         string  `json:"name"`
	Description  *string `json:"description,omitempty"`
	Quantity     int32   `json:"quantity"`
	Cost         float64 `json:"cost"`
	CurrencyCode string  `json:"currencyCode"`
}

type CurrencyUpdateInput struct {
	Name   *TextUpdateOneRequiredInput `json:"name,omitempty"`
	Code   *string                     `json:"code,omitempty"`
	Symbol *string                     `json:"symbol,omitempty"`
}

type FaqEntryCreateManyWithoutFaqInput struct {
	Create  []FaqEntryCreateWithoutFaqInput `json:"create,omitempty"`
	Connect []FaqEntryWhereUniqueInput      `json:"connect,omitempty"`
}

type CurrencyUpdateManyMutationInput struct {
	Code   *string `json:"code,omitempty"`
	Symbol *string `json:"symbol,omitempty"`
}

type PersonReviewsCreateInput struct {
	ID            *string                       `json:"id,omitempty"`
	Person        PersonCreateOneInput          `json:"person"`
	Title         TextCreateOneInput            `json:"title"`
	Description   TextCreateOneInput            `json:"description"`
	ApproveNumber *int32                        `json:"approveNumber,omitempty"`
	DeclineNumber *int32                        `json:"declineNumber,omitempty"`
	Comments      *PersonReviewsCreateManyInput `json:"comments,omitempty"`
}

type EmailChannelCreateInput struct {
	ID          *string                           `json:"id,omitempty"`
	Person      PersonCreateOneWithoutEmailsInput `json:"person"`
	IsMain      *bool                             `json:"isMain,omitempty"`
	DisplayName string                            `json:"displayName"`
	Valid       *bool                             `json:"valid,omitempty"`
	Value       string                            `json:"value"`
	Extras      *EmailChannelCreateextrasInput    `json:"extras,omitempty"`
}

type IDDocumentWhereInput struct {
	ID                 *string                `json:"id,omitempty"`
	IDNot              *string                `json:"id_not,omitempty"`
	IDIn               []string               `json:"id_in,omitempty"`
	IDNotIn            []string               `json:"id_not_in,omitempty"`
	IDLt               *string                `json:"id_lt,omitempty"`
	IDLte              *string                `json:"id_lte,omitempty"`
	IDGt               *string                `json:"id_gt,omitempty"`
	IDGte              *string                `json:"id_gte,omitempty"`
	IDContains         *string                `json:"id_contains,omitempty"`
	IDNotContains      *string                `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                `json:"id_not_ends_with,omitempty"`
	CreatedAt          *string                `json:"createdAt,omitempty"`
	CreatedAtNot       *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn        []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn     []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt        *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte       *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt        *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte       *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt          *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot       *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn        []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn     []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt        *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte       *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt        *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte       *string                `json:"updatedAt_gte,omitempty"`
	Person             *PersonWhereInput      `json:"person,omitempty"`
	Type               *IDType                `json:"type,omitempty"`
	TypeNot            *IDType                `json:"type_not,omitempty"`
	TypeIn             []IDType               `json:"type_in,omitempty"`
	TypeNotIn          []IDType               `json:"type_not_in,omitempty"`
	Value              *string                `json:"value,omitempty"`
	ValueNot           *string                `json:"value_not,omitempty"`
	ValueIn            []string               `json:"value_in,omitempty"`
	ValueNotIn         []string               `json:"value_not_in,omitempty"`
	ValueLt            *string                `json:"value_lt,omitempty"`
	ValueLte           *string                `json:"value_lte,omitempty"`
	ValueGt            *string                `json:"value_gt,omitempty"`
	ValueGte           *string                `json:"value_gte,omitempty"`
	ValueContains      *string                `json:"value_contains,omitempty"`
	ValueNotContains   *string                `json:"value_not_contains,omitempty"`
	ValueStartsWith    *string                `json:"value_starts_with,omitempty"`
	ValueNotStartsWith *string                `json:"value_not_starts_with,omitempty"`
	ValueEndsWith      *string                `json:"value_ends_with,omitempty"`
	ValueNotEndsWith   *string                `json:"value_not_ends_with,omitempty"`
	Validated          *bool                  `json:"validated,omitempty"`
	ValidatedNot       *bool                  `json:"validated_not,omitempty"`
	And                []IDDocumentWhereInput `json:"AND,omitempty"`
	Or                 []IDDocumentWhereInput `json:"OR,omitempty"`
	Not                []IDDocumentWhereInput `json:"NOT,omitempty"`
}

type PersonCreateOneWithoutEmailsInput struct {
	Create  *PersonCreateWithoutEmailsInput `json:"create,omitempty"`
	Connect *PersonWhereUniqueInput         `json:"connect,omitempty"`
}

type EntryTicketWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PersonCreateWithoutEmailsInput struct {
	ID             *string                                   `json:"id,omitempty"`
	QmId           *string                                   `json:"qmID,omitempty"`
	Name           string                                    `json:"name"`
	Photo          *string                                   `json:"photo,omitempty"`
	Birthdate      *string                                   `json:"birthdate,omitempty"`
	Country        *TextCreateOneInput                       `json:"country,omitempty"`
	Phones         *PhoneChannelCreateManyWithoutPersonInput `json:"phones,omitempty"`
	IDentification IDDocumentCreateOneWithoutPersonInput     `json:"identification"`
	Tags           *PersonCreatetagsInput                    `json:"tags,omitempty"`
	Credentials    *CredentialCreateManyWithoutOwnerInput    `json:"credentials,omitempty"`
}

type PassUpdateWithoutTypeDataInput struct {
	Owner           *PersonUpdateOneRequiredInput       `json:"owner,omitempty"`
	PurchaseReceive *PurchaseUpdateOneInput             `json:"purchaseReceive,omitempty"`
	ExpireAt        *string                             `json:"expireAt,omitempty"`
	State           *PassState                          `json:"state,omitempty"`
	Tickets         *TicketUpdateManyWithoutParentInput `json:"tickets,omitempty"`
}

type EmailChannelUpdateInput struct {
	Person      *PersonUpdateOneRequiredWithoutEmailsInput `json:"person,omitempty"`
	IsMain      *bool                                      `json:"isMain,omitempty"`
	DisplayName *string                                    `json:"displayName,omitempty"`
	Valid       *bool                                      `json:"valid,omitempty"`
	Value       *string                                    `json:"value,omitempty"`
	Extras      *EmailChannelUpdateextrasInput             `json:"extras,omitempty"`
}

type StoryUpsertWithWhereUniqueNestedInput struct {
	Where  StoryWhereUniqueInput `json:"where"`
	Update StoryUpdateDataInput  `json:"update"`
	Create StoryCreateInput      `json:"create"`
}

type PersonUpdateOneRequiredWithoutEmailsInput struct {
	Create  *PersonCreateWithoutEmailsInput     `json:"create,omitempty"`
	Update  *PersonUpdateWithoutEmailsDataInput `json:"update,omitempty"`
	Upsert  *PersonUpsertWithoutEmailsInput     `json:"upsert,omitempty"`
	Connect *PersonWhereUniqueInput             `json:"connect,omitempty"`
}

type PurchaseWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PersonUpdateWithoutEmailsDataInput struct {
	QmId           *string                                        `json:"qmID,omitempty"`
	Name           *string                                        `json:"name,omitempty"`
	Photo          *string                                        `json:"photo,omitempty"`
	Birthdate      *string                                        `json:"birthdate,omitempty"`
	Country        *TextUpdateOneInput                            `json:"country,omitempty"`
	Phones         *PhoneChannelUpdateManyWithoutPersonInput      `json:"phones,omitempty"`
	IDentification *IDDocumentUpdateOneRequiredWithoutPersonInput `json:"identification,omitempty"`
	Tags           *PersonUpdatetagsInput                         `json:"tags,omitempty"`
	Credentials    *CredentialUpdateManyWithoutOwnerInput         `json:"credentials,omitempty"`
}

type AttractionCreateInput struct {
	ID               *string                                 `json:"id,omitempty"`
	Owner            PartnerCreateOneWithoutAttractionsInput `json:"owner"`
	Name             TextCreateOneInput                      `json:"name"`
	Description      *TextCreateOneInput                     `json:"description,omitempty"`
	ShortDescription *TextCreateOneInput                     `json:"shortDescription,omitempty"`
	Faqs             FaqCreateOneWithoutAttractionInput      `json:"faqs"`
	PrincipalImage   *string                                 `json:"principalImage,omitempty"`
	CoverImage       *string                                 `json:"coverImage,omitempty"`
	LandscapeImage   *string                                 `json:"landscapeImage,omitempty"`
	Gallery          *AttractionCreategalleryInput           `json:"gallery,omitempty"`
	Type             *AttractionCreatetypeInput              `json:"type,omitempty"`
	Place            PlaceCreateOneInput                     `json:"place"`
}

type PersonUpsertWithoutEmailsInput struct {
	Update PersonUpdateWithoutEmailsDataInput `json:"update"`
	Create PersonCreateWithoutEmailsInput     `json:"create"`
}

type AttractionCreateManyInput struct {
	Create  []AttractionCreateInput      `json:"create,omitempty"`
	Connect []AttractionWhereUniqueInput `json:"connect,omitempty"`
}

type EmailChannelUpdateManyMutationInput struct {
	IsMain      *bool                          `json:"isMain,omitempty"`
	DisplayName *string                        `json:"displayName,omitempty"`
	Valid       *bool                          `json:"valid,omitempty"`
	Value       *string                        `json:"value,omitempty"`
	Extras      *EmailChannelUpdateextrasInput `json:"extras,omitempty"`
}

type RouteCreateWithoutPlacesInput struct {
	ID          *string                                `json:"id,omitempty"`
	Name        string                                 `json:"name"`
	Image       string                                 `json:"image"`
	Type        ExperienceType                         `json:"type"`
	ExtraTypes  *RouteCreateextraTypesInput            `json:"extraTypes,omitempty"`
	Creator     ExpertCreateOneInput                   `json:"creator"`
	LinkedStory *StoryCreateOneWithoutLinkedRouteInput `json:"linkedStory,omitempty"`
	LikedBy     *PersonCreateManyInput                 `json:"likedBy,omitempty"`
	Reviews     *PersonReviewsCreateManyInput          `json:"reviews,omitempty"`
	Popularity  *float64                               `json:"popularity,omitempty"`
	Color       string                                 `json:"color"`
}

type EntryTicketCreateInput struct {
	ID       *string                               `json:"id,omitempty"`
	At       string                                `json:"at"`
	Ticket   TicketCreateOneInput                  `json:"ticket"`
	Partner  PartnerCreateOneWithoutRegistryInput  `json:"partner"`
	Traveler TravelerCreateOneWithoutRegistryInput `json:"traveler"`
}

type AttractionSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *AttractionWhereInput              `json:"node,omitempty"`
	And                        []AttractionSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AttractionSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AttractionSubscriptionWhereInput `json:"NOT,omitempty"`
}

type EntryTicketUpdateInput struct {
	At       *string                                        `json:"at,omitempty"`
	Ticket   *TicketUpdateOneRequiredInput                  `json:"ticket,omitempty"`
	Partner  *PartnerUpdateOneRequiredWithoutRegistryInput  `json:"partner,omitempty"`
	Traveler *TravelerUpdateOneRequiredWithoutRegistryInput `json:"traveler,omitempty"`
}

type LocationWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type EntryTicketUpdateManyMutationInput struct {
	At *string `json:"at,omitempty"`
}

type FaqUpdateOneRequiredWithoutEntriesInput struct {
	Create  *FaqCreateWithoutEntriesInput     `json:"create,omitempty"`
	Update  *FaqUpdateWithoutEntriesDataInput `json:"update,omitempty"`
	Upsert  *FaqUpsertWithoutEntriesInput     `json:"upsert,omitempty"`
	Connect *FaqWhereUniqueInput              `json:"connect,omitempty"`
}

type ExpertUpdateInput struct {
	Person  *PersonUpdateOneRequiredInput      `json:"person,omitempty"`
	Alias   *string                            `json:"alias,omitempty"`
	Stories *StoryUpdateManyWithoutAuthorInput `json:"stories,omitempty"`
}

type ErrorUpdateManyMutationInput struct {
	Code     *string `json:"code,omitempty"`
	Internal *string `json:"internal,omitempty"`
	Explain  *string `json:"explain,omitempty"`
	Location *string `json:"location,omitempty"`
}

type ErrorUpdateInput struct {
	Code     *string                     `json:"code,omitempty"`
	Message  *TextUpdateOneRequiredInput `json:"message,omitempty"`
	Internal *string                     `json:"internal,omitempty"`
	Explain  *string                     `json:"explain,omitempty"`
	Location *string                     `json:"location,omitempty"`
}

type ErrorCreateInput struct {
	ID       *string            `json:"id,omitempty"`
	Code     string             `json:"code"`
	Message  TextCreateOneInput `json:"message"`
	Internal *string            `json:"internal,omitempty"`
	Explain  *string            `json:"explain,omitempty"`
	Location *string            `json:"location,omitempty"`
}

type CredentialCreateWithoutOwnerInput struct {
	ID             *string         `json:"id,omitempty"`
	DisplayName    *string         `json:"displayName,omitempty"`
	IsMain         bool            `json:"isMain"`
	Type           *CredentialType `json:"type,omitempty"`
	Validated      *bool           `json:"validated,omitempty"`
	ValidationId   *string         `json:"validationID,omitempty"`
	Value          string          `json:"value"`
	RawPassword    *string         `json:"rawPassword,omitempty"`
	HashedPassword string          `json:"hashedPassword"`
}

type PersonReviewsWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PhoneChannelUpdateInput struct {
	Person      *PersonUpdateOneRequiredWithoutPhonesInput `json:"person,omitempty"`
	IsMain      *bool                                      `json:"isMain,omitempty"`
	DisplayName *string                                    `json:"displayName,omitempty"`
	Valid       *bool                                      `json:"valid,omitempty"`
	CountryCode *string                                    `json:"countryCode,omitempty"`
	Number      *string                                    `json:"number,omitempty"`
}

type PhoneChannelSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *PhoneChannelWhereInput              `json:"node,omitempty"`
	And                        []PhoneChannelSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PhoneChannelSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PhoneChannelSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CreditCardCreateWithoutOwnerInput struct {
	ID            *string         `json:"id,omitempty"`
	CustomerToken string          `json:"customerToken"`
	CardNumber    string          `json:"cardNumber"`
	CardToken     string          `json:"cardToken"`
	Type          *CreditCardType `json:"type,omitempty"`
	LastUsed      *string         `json:"lastUsed,omitempty"`
}

type TravelerPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TravelerPreviousValuesExec) Exec(ctx context.Context) (*TravelerPreviousValues, error) {
	var v TravelerPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerPreviousValuesExecArray) Exec(ctx context.Context) ([]TravelerPreviousValues, error) {
	var v []TravelerPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TravelerPreviousValues struct {
	ID           string `json:"id"`
	CreatedAt    string `json:"createdAt"`
	UpdatedAt    string `json:"updatedAt"`
	Unregistered bool   `json:"unregistered"`
	Username     string `json:"username"`
}

type CreditCardEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CreditCardEdgeExec) Node() *CreditCardExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CreditCard"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "customerToken", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (instance CreditCardEdgeExec) Exec(ctx context.Context) (*CreditCardEdge, error) {
	var v CreditCardEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardEdgeExecArray) Exec(ctx context.Context) ([]CreditCardEdge, error) {
	var v []CreditCardEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCardEdge struct {
	Node   CreditCard `json:"node"`
	Cursor string     `json:"cursor"`
}

type LocationExec struct {
	exec *prisma.Exec
}

func (instance *LocationExec) Description() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"description",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance LocationExec) Exec(ctx context.Context) (*Location, error) {
	var v Location
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationExecArray struct {
	exec *prisma.Exec
}

func (instance LocationExecArray) Exec(ctx context.Context) ([]Location, error) {
	var v []Location
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Location struct {
	ID        string  `json:"id"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type PersonExec struct {
	exec *prisma.Exec
}

func (instance *PersonExec) Country() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"country",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

type PhonesParamsExec struct {
	Where   *PhoneChannelWhereInput
	OrderBy *PhoneChannelOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PersonExec) Phones(params *PhonesParamsExec) *PhoneChannelExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PhoneChannelWhereInput", "PhoneChannelOrderByInput", "PhoneChannel"},
		"phones",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExecArray{ret}
}

type EmailsParamsExec struct {
	Where   *EmailChannelWhereInput
	OrderBy *EmailChannelOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PersonExec) Emails(params *EmailsParamsExec) *EmailChannelExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"EmailChannelWhereInput", "EmailChannelOrderByInput", "EmailChannel"},
		"emails",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "value", "extras"})

	return &EmailChannelExecArray{ret}
}

func (instance *PersonExec) IDentification() *IDDocumentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IDDocument"},
		"identification",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDDocumentExec{ret}
}

type CredentialsParamsExec struct {
	Where   *CredentialWhereInput
	OrderBy *CredentialOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PersonExec) Credentials(params *CredentialsParamsExec) *CredentialExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CredentialWhereInput", "CredentialOrderByInput", "Credential"},
		"credentials",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExecArray{ret}
}

func (instance PersonExec) Exec(ctx context.Context) (*Person, error) {
	var v Person
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonExecArray struct {
	exec *prisma.Exec
}

func (instance PersonExecArray) Exec(ctx context.Context) ([]Person, error) {
	var v []Person
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Person struct {
	ID        string   `json:"id"`
	CreatedAt string   `json:"createdAt"`
	UpdatedAt string   `json:"updatedAt"`
	QmId      *string  `json:"qmID,omitempty"`
	Name      string   `json:"name"`
	Photo     *string  `json:"photo,omitempty"`
	Birthdate *string  `json:"birthdate,omitempty"`
	Tags      []string `json:"tags,omitempty"`
}

type TextPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TextPreviousValuesExec) Exec(ctx context.Context) (*TextPreviousValues, error) {
	var v TextPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TextPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TextPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TextPreviousValuesExecArray) Exec(ctx context.Context) ([]TextPreviousValues, error) {
	var v []TextPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TextPreviousValues struct {
	ID      string  `json:"id"`
	English string  `json:"english"`
	Spanish *string `json:"spanish,omitempty"`
}

type CreditCardConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CreditCardConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CreditCardConnectionExec) Edges() *CreditCardEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CreditCardWhereInput", "CreditCardOrderByInput", "CreditCardEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "CreditCard"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &CreditCardEdgeExecArray{nodes}
}

func (instance *CreditCardConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCreditCard"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CreditCardConnectionExec) Exec(ctx context.Context) (*CreditCardConnection, error) {
	var v CreditCardConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardConnectionExecArray) Exec(ctx context.Context) ([]CreditCardConnection, error) {
	var v []CreditCardConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCardConnection struct {
	PageInfo PageInfo         `json:"pageInfo"`
	Edges    []CreditCardEdge `json:"edges"`
}

type OpeningHoursExec struct {
	exec *prisma.Exec
}

func (instance *OpeningHoursExec) Description() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"description",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance OpeningHoursExec) Exec(ctx context.Context) (*OpeningHours, error) {
	var v OpeningHours
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OpeningHoursExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OpeningHoursExecArray struct {
	exec *prisma.Exec
}

func (instance OpeningHoursExecArray) Exec(ctx context.Context) ([]OpeningHours, error) {
	var v []OpeningHours
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OpeningHours struct {
	ID  string  `json:"id"`
	Mon *string `json:"mon,omitempty"`
	Tue *string `json:"tue,omitempty"`
	Wed *string `json:"wed,omitempty"`
	Thu *string `json:"thu,omitempty"`
	Fri *string `json:"fri,omitempty"`
	Sat *string `json:"sat,omitempty"`
	Sun *string `json:"sun,omitempty"`
}

type TravelerEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TravelerEdgeExec) Node() *TravelerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Traveler"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "unregistered", "username"})

	return &TravelerExec{ret}
}

func (instance TravelerEdgeExec) Exec(ctx context.Context) (*TravelerEdge, error) {
	var v TravelerEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerEdgeExecArray) Exec(ctx context.Context) ([]TravelerEdge, error) {
	var v []TravelerEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TravelerEdge struct {
	Node   Traveler `json:"node"`
	Cursor string   `json:"cursor"`
}

type TravelerSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TravelerSubscriptionPayloadExec) Node() *TravelerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Traveler"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "unregistered", "username"})

	return &TravelerExec{ret}
}

func (instance *TravelerSubscriptionPayloadExec) PreviousValues() *TravelerPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TravelerPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "unregistered", "username"})

	return &TravelerPreviousValuesExec{ret}
}

func (instance TravelerSubscriptionPayloadExec) Exec(ctx context.Context) (*TravelerSubscriptionPayload, error) {
	var v TravelerSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TravelerSubscriptionPayload, error) {
	var v []TravelerSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TravelerSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Traveler    `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type TicketEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TicketEdgeExec) Node() *TicketExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Ticket"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "visited", "finished", "state"})

	return &TicketExec{ret}
}

func (instance TicketEdgeExec) Exec(ctx context.Context) (*TicketEdge, error) {
	var v TicketEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TicketEdgeExecArray) Exec(ctx context.Context) ([]TicketEdge, error) {
	var v []TicketEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TicketEdge struct {
	Node   Ticket `json:"node"`
	Cursor string `json:"cursor"`
}

type CredentialEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CredentialEdgeExec) Node() *CredentialExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Credential"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

func (instance CredentialEdgeExec) Exec(ctx context.Context) (*CredentialEdge, error) {
	var v CredentialEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialEdgeExecArray) Exec(ctx context.Context) ([]CredentialEdge, error) {
	var v []CredentialEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CredentialEdge struct {
	Node   Credential `json:"node"`
	Cursor string     `json:"cursor"`
}

type ActionTicketExec struct {
	exec *prisma.Exec
}

func (instance ActionTicketExec) Exec(ctx context.Context) (*ActionTicket, error) {
	var v ActionTicket
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ActionTicketExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ActionTicketExecArray struct {
	exec *prisma.Exec
}

func (instance ActionTicketExecArray) Exec(ctx context.Context) ([]ActionTicket, error) {
	var v []ActionTicket
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ActionTicket struct {
	ID        string           `json:"id"`
	CreatedAt string           `json:"createdAt"`
	UpdatedAt string           `json:"updatedAt"`
	Type      ActionTicketType `json:"type"`
	Token     string           `json:"token"`
	Available bool             `json:"available"`
	Used      bool             `json:"used"`
}

type TextConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TextConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TextConnectionExec) Edges() *TextEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"TextWhereInput", "TextOrderByInput", "TextEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Text"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &TextEdgeExecArray{nodes}
}

func (instance *TextConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateText"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance TextConnectionExec) Exec(ctx context.Context) (*TextConnection, error) {
	var v TextConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TextConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TextConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TextConnectionExecArray) Exec(ctx context.Context) ([]TextConnection, error) {
	var v []TextConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TextConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []TextEdge `json:"edges"`
}

type ActionTicketSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ActionTicketSubscriptionPayloadExec) Node() *ActionTicketExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ActionTicket"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "token", "available", "used"})

	return &ActionTicketExec{ret}
}

func (instance *ActionTicketSubscriptionPayloadExec) PreviousValues() *ActionTicketPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ActionTicketPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "type", "token", "available", "used"})

	return &ActionTicketPreviousValuesExec{ret}
}

func (instance ActionTicketSubscriptionPayloadExec) Exec(ctx context.Context) (*ActionTicketSubscriptionPayload, error) {
	var v ActionTicketSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ActionTicketSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ActionTicketSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ActionTicketSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ActionTicketSubscriptionPayload, error) {
	var v []ActionTicketSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ActionTicketSubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *ActionTicket `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type ActionTicketPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ActionTicketPreviousValuesExec) Exec(ctx context.Context) (*ActionTicketPreviousValues, error) {
	var v ActionTicketPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ActionTicketPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ActionTicketPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ActionTicketPreviousValuesExecArray) Exec(ctx context.Context) ([]ActionTicketPreviousValues, error) {
	var v []ActionTicketPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ActionTicketPreviousValues struct {
	ID        string           `json:"id"`
	CreatedAt string           `json:"createdAt"`
	UpdatedAt string           `json:"updatedAt"`
	Type      ActionTicketType `json:"type"`
	Token     string           `json:"token"`
	Available bool             `json:"available"`
	Used      bool             `json:"used"`
}

type StoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *StoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *StoryConnectionExec) Edges() *StoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"StoryWhereInput", "StoryOrderByInput", "StoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Story"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &StoryEdgeExecArray{nodes}
}

func (instance *StoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateStory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance StoryConnectionExec) Exec(ctx context.Context) (*StoryConnection, error) {
	var v StoryConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance StoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type StoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance StoryConnectionExecArray) Exec(ctx context.Context) ([]StoryConnection, error) {
	var v []StoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type StoryConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []StoryEdge `json:"edges"`
}

type CredentialConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CredentialConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CredentialConnectionExec) Edges() *CredentialEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CredentialWhereInput", "CredentialOrderByInput", "CredentialEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Credential"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &CredentialEdgeExecArray{nodes}
}

func (instance *CredentialConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCredential"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CredentialConnectionExec) Exec(ctx context.Context) (*CredentialConnection, error) {
	var v CredentialConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialConnectionExecArray) Exec(ctx context.Context) ([]CredentialConnection, error) {
	var v []CredentialConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CredentialConnection struct {
	PageInfo PageInfo         `json:"pageInfo"`
	Edges    []CredentialEdge `json:"edges"`
}

type RouteEdgeExec struct {
	exec *prisma.Exec
}

func (instance *RouteEdgeExec) Node() *RouteExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Route"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "image", "type", "extraTypes", "popularity", "color"})

	return &RouteExec{ret}
}

func (instance RouteEdgeExec) Exec(ctx context.Context) (*RouteEdge, error) {
	var v RouteEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RouteEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RouteEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance RouteEdgeExecArray) Exec(ctx context.Context) ([]RouteEdge, error) {
	var v []RouteEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RouteEdge struct {
	Node   Route  `json:"node"`
	Cursor string `json:"cursor"`
}

type AttractionSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AttractionSubscriptionPayloadExec) Node() *AttractionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Attraction"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionExec{ret}
}

func (instance *AttractionSubscriptionPayloadExec) PreviousValues() *AttractionPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AttractionPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionPreviousValuesExec{ret}
}

func (instance AttractionSubscriptionPayloadExec) Exec(ctx context.Context) (*AttractionSubscriptionPayload, error) {
	var v AttractionSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AttractionSubscriptionPayload, error) {
	var v []AttractionSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AttractionSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Attraction  `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type AttractionPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AttractionPreviousValuesExec) Exec(ctx context.Context) (*AttractionPreviousValues, error) {
	var v AttractionPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionPreviousValuesExecArray) Exec(ctx context.Context) ([]AttractionPreviousValues, error) {
	var v []AttractionPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AttractionPreviousValues struct {
	ID             string           `json:"id"`
	CreatedAt      string           `json:"createdAt"`
	UpdatedAt      string           `json:"updatedAt"`
	PrincipalImage *string          `json:"principalImage,omitempty"`
	CoverImage     *string          `json:"coverImage,omitempty"`
	LandscapeImage *string          `json:"landscapeImage,omitempty"`
	Gallery        []string         `json:"gallery,omitempty"`
	Type           []ExperienceType `json:"type,omitempty"`
}

type PurchaseConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PurchaseConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PurchaseConnectionExec) Edges() *PurchaseEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PurchaseWhereInput", "PurchaseOrderByInput", "PurchaseEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Purchase"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &PurchaseEdgeExecArray{nodes}
}

func (instance *PurchaseConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePurchase"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PurchaseConnectionExec) Exec(ctx context.Context) (*PurchaseConnection, error) {
	var v PurchaseConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PurchaseConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PurchaseConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PurchaseConnectionExecArray) Exec(ctx context.Context) ([]PurchaseConnection, error) {
	var v []PurchaseConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PurchaseConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []PurchaseEdge `json:"edges"`
}

type ProductEntryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ProductEntryEdgeExec) Node() *ProductEntryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductEntry"},
		"node",
		[]string{"id", "parentID", "name", "description", "quantity", "cost", "currencyCode"})

	return &ProductEntryExec{ret}
}

func (instance ProductEntryEdgeExec) Exec(ctx context.Context) (*ProductEntryEdge, error) {
	var v ProductEntryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductEntryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductEntryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ProductEntryEdgeExecArray) Exec(ctx context.Context) ([]ProductEntryEdge, error) {
	var v []ProductEntryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ProductEntryEdge struct {
	Node   ProductEntry `json:"node"`
	Cursor string       `json:"cursor"`
}

type CostSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CostSubscriptionPayloadExec) Node() *CostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Cost"},
		"node",
		[]string{"id", "value"})

	return &CostExec{ret}
}

func (instance *CostSubscriptionPayloadExec) PreviousValues() *CostPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CostPreviousValues"},
		"previousValues",
		[]string{"id", "value"})

	return &CostPreviousValuesExec{ret}
}

func (instance CostSubscriptionPayloadExec) Exec(ctx context.Context) (*CostSubscriptionPayload, error) {
	var v CostSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CostSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CostSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CostSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CostSubscriptionPayload, error) {
	var v []CostSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CostSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Cost        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CostPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CostPreviousValuesExec) Exec(ctx context.Context) (*CostPreviousValues, error) {
	var v CostPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CostPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CostPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CostPreviousValuesExecArray) Exec(ctx context.Context) ([]CostPreviousValues, error) {
	var v []CostPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CostPreviousValues struct {
	ID    string  `json:"id"`
	Value float64 `json:"value"`
}

type PlaceConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PlaceConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PlaceConnectionExec) Edges() *PlaceEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PlaceWhereInput", "PlaceOrderByInput", "PlaceEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Place"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &PlaceEdgeExecArray{nodes}
}

func (instance *PlaceConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePlace"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PlaceConnectionExec) Exec(ctx context.Context) (*PlaceConnection, error) {
	var v PlaceConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PlaceConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PlaceConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PlaceConnectionExecArray) Exec(ctx context.Context) ([]PlaceConnection, error) {
	var v []PlaceConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PlaceConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []PlaceEdge `json:"edges"`
}

type CostEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CostEdgeExec) Node() *CostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Cost"},
		"node",
		[]string{"id", "value"})

	return &CostExec{ret}
}

func (instance CostEdgeExec) Exec(ctx context.Context) (*CostEdge, error) {
	var v CostEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CostEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CostEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CostEdgeExecArray) Exec(ctx context.Context) ([]CostEdge, error) {
	var v []CostEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CostEdge struct {
	Node   Cost   `json:"node"`
	Cursor string `json:"cursor"`
}

type PhoneChannelEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PhoneChannelEdgeExec) Node() *PhoneChannelExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PhoneChannel"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

func (instance PhoneChannelEdgeExec) Exec(ctx context.Context) (*PhoneChannelEdge, error) {
	var v PhoneChannelEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneChannelEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneChannelEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneChannelEdgeExecArray) Exec(ctx context.Context) ([]PhoneChannelEdge, error) {
	var v []PhoneChannelEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhoneChannelEdge struct {
	Node   PhoneChannel `json:"node"`
	Cursor string       `json:"cursor"`
}

type CredentialSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CredentialSubscriptionPayloadExec) Node() *CredentialExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Credential"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialExec{ret}
}

func (instance *CredentialSubscriptionPayloadExec) PreviousValues() *CredentialPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CredentialPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "displayName", "isMain", "type", "validated", "validationID", "value", "rawPassword", "hashedPassword"})

	return &CredentialPreviousValuesExec{ret}
}

func (instance CredentialSubscriptionPayloadExec) Exec(ctx context.Context) (*CredentialSubscriptionPayload, error) {
	var v CredentialSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CredentialSubscriptionPayload, error) {
	var v []CredentialSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CredentialSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Credential  `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CredentialPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CredentialPreviousValuesExec) Exec(ctx context.Context) (*CredentialPreviousValues, error) {
	var v CredentialPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialPreviousValuesExecArray) Exec(ctx context.Context) ([]CredentialPreviousValues, error) {
	var v []CredentialPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CredentialPreviousValues struct {
	ID             string         `json:"id"`
	CreatedAt      string         `json:"createdAt"`
	UpdatedAt      string         `json:"updatedAt"`
	DisplayName    *string        `json:"displayName,omitempty"`
	IsMain         bool           `json:"isMain"`
	Type           CredentialType `json:"type"`
	Validated      *bool          `json:"validated,omitempty"`
	ValidationId   *string        `json:"validationID,omitempty"`
	Value          string         `json:"value"`
	RawPassword    *string        `json:"rawPassword,omitempty"`
	HashedPassword string         `json:"hashedPassword"`
}

type PersonReviewsConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PersonReviewsConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PersonReviewsConnectionExec) Edges() *PersonReviewsEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PersonReviewsWhereInput", "PersonReviewsOrderByInput", "PersonReviewsEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "PersonReviews"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &PersonReviewsEdgeExecArray{nodes}
}

func (instance *PersonReviewsConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePersonReviews"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PersonReviewsConnectionExec) Exec(ctx context.Context) (*PersonReviewsConnection, error) {
	var v PersonReviewsConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonReviewsConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonReviewsConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PersonReviewsConnectionExecArray) Exec(ctx context.Context) ([]PersonReviewsConnection, error) {
	var v []PersonReviewsConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonReviewsConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []PersonReviewsEdge `json:"edges"`
}

type CostConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CostConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CostConnectionExec) Edges() *CostEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CostWhereInput", "CostOrderByInput", "CostEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Cost"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &CostEdgeExecArray{nodes}
}

func (instance *CostConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCost"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CostConnectionExec) Exec(ctx context.Context) (*CostConnection, error) {
	var v CostConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CostConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CostConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CostConnectionExecArray) Exec(ctx context.Context) ([]CostConnection, error) {
	var v []CostConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CostConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []CostEdge `json:"edges"`
}

type PersonEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PersonEdgeExec) Node() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

func (instance PersonEdgeExec) Exec(ctx context.Context) (*PersonEdge, error) {
	var v PersonEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PersonEdgeExecArray) Exec(ctx context.Context) ([]PersonEdge, error) {
	var v []PersonEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonEdge struct {
	Node   Person `json:"node"`
	Cursor string `json:"cursor"`
}

type CreditCardSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CreditCardSubscriptionPayloadExec) Node() *CreditCardExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CreditCard"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "customerToken", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExec{ret}
}

func (instance *CreditCardSubscriptionPayloadExec) PreviousValues() *CreditCardPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CreditCardPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "customerToken", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardPreviousValuesExec{ret}
}

func (instance CreditCardSubscriptionPayloadExec) Exec(ctx context.Context) (*CreditCardSubscriptionPayload, error) {
	var v CreditCardSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CreditCardSubscriptionPayload, error) {
	var v []CreditCardSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCardSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *CreditCard  `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CreditCardPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CreditCardPreviousValuesExec) Exec(ctx context.Context) (*CreditCardPreviousValues, error) {
	var v CreditCardPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardPreviousValuesExecArray) Exec(ctx context.Context) ([]CreditCardPreviousValues, error) {
	var v []CreditCardPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCardPreviousValues struct {
	ID            string         `json:"id"`
	CreatedAt     string         `json:"createdAt"`
	UpdatedAt     string         `json:"updatedAt"`
	CustomerToken string         `json:"customerToken"`
	CardNumber    string         `json:"cardNumber"`
	CardToken     string         `json:"cardToken"`
	Type          CreditCardType `json:"type"`
	LastUsed      *string        `json:"lastUsed,omitempty"`
}

type PaymentMethodConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PaymentMethodConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PaymentMethodConnectionExec) Edges() *PaymentMethodEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PaymentMethodWhereInput", "PaymentMethodOrderByInput", "PaymentMethodEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "PaymentMethod"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &PaymentMethodEdgeExecArray{nodes}
}

func (instance *PaymentMethodConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePaymentMethod"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PaymentMethodConnectionExec) Exec(ctx context.Context) (*PaymentMethodConnection, error) {
	var v PaymentMethodConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentMethodConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentMethodConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentMethodConnectionExecArray) Exec(ctx context.Context) ([]PaymentMethodConnection, error) {
	var v []PaymentMethodConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentMethodConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []PaymentMethodEdge `json:"edges"`
}

type TextExec struct {
	exec *prisma.Exec
}

func (instance TextExec) Exec(ctx context.Context) (*Text, error) {
	var v Text
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TextExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TextExecArray struct {
	exec *prisma.Exec
}

func (instance TextExecArray) Exec(ctx context.Context) ([]Text, error) {
	var v []Text
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Text struct {
	ID      string  `json:"id"`
	English string  `json:"english"`
	Spanish *string `json:"spanish,omitempty"`
}

type CurrencySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CurrencySubscriptionPayloadExec) Node() *CurrencyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Currency"},
		"node",
		[]string{"id", "code", "symbol"})

	return &CurrencyExec{ret}
}

func (instance *CurrencySubscriptionPayloadExec) PreviousValues() *CurrencyPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CurrencyPreviousValues"},
		"previousValues",
		[]string{"id", "code", "symbol"})

	return &CurrencyPreviousValuesExec{ret}
}

func (instance CurrencySubscriptionPayloadExec) Exec(ctx context.Context) (*CurrencySubscriptionPayload, error) {
	var v CurrencySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CurrencySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CurrencySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CurrencySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CurrencySubscriptionPayload, error) {
	var v []CurrencySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CurrencySubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Currency    `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PassTypeConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PassTypeConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PassTypeConnectionExec) Edges() *PassTypeEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PassTypeWhereInput", "PassTypeOrderByInput", "PassTypeEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "PassType"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &PassTypeEdgeExecArray{nodes}
}

func (instance *PassTypeConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePassType"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PassTypeConnectionExec) Exec(ctx context.Context) (*PassTypeConnection, error) {
	var v PassTypeConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PassTypeConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PassTypeConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PassTypeConnectionExecArray) Exec(ctx context.Context) ([]PassTypeConnection, error) {
	var v []PassTypeConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PassTypeConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []PassTypeEdge `json:"edges"`
}

type CurrencyPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CurrencyPreviousValuesExec) Exec(ctx context.Context) (*CurrencyPreviousValues, error) {
	var v CurrencyPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CurrencyPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CurrencyPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CurrencyPreviousValuesExecArray) Exec(ctx context.Context) ([]CurrencyPreviousValues, error) {
	var v []CurrencyPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CurrencyPreviousValues struct {
	ID     string `json:"id"`
	Code   string `json:"code"`
	Symbol string `json:"symbol"`
}

type PassEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PassEdgeExec) Node() *PassExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Pass"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "expireAt", "state"})

	return &PassExec{ret}
}

func (instance PassEdgeExec) Exec(ctx context.Context) (*PassEdge, error) {
	var v PassEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PassEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PassEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PassEdgeExecArray) Exec(ctx context.Context) ([]PassEdge, error) {
	var v []PassEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PassEdge struct {
	Node   Pass   `json:"node"`
	Cursor string `json:"cursor"`
}

type EmailChannelSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *EmailChannelSubscriptionPayloadExec) Node() *EmailChannelExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EmailChannel"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

func (instance *EmailChannelSubscriptionPayloadExec) PreviousValues() *EmailChannelPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EmailChannelPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "value", "extras"})

	return &EmailChannelPreviousValuesExec{ret}
}

func (instance EmailChannelSubscriptionPayloadExec) Exec(ctx context.Context) (*EmailChannelSubscriptionPayload, error) {
	var v EmailChannelSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailChannelSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailChannelSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance EmailChannelSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]EmailChannelSubscriptionPayload, error) {
	var v []EmailChannelSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailChannelSubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *EmailChannel `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type PartnerConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PartnerConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PartnerConnectionExec) Edges() *PartnerEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PartnerWhereInput", "PartnerOrderByInput", "PartnerEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Partner"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &PartnerEdgeExecArray{nodes}
}

func (instance *PartnerConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePartner"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PartnerConnectionExec) Exec(ctx context.Context) (*PartnerConnection, error) {
	var v PartnerConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerConnectionExecArray) Exec(ctx context.Context) ([]PartnerConnection, error) {
	var v []PartnerConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PartnerConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []PartnerEdge `json:"edges"`
}

type EmailChannelPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance EmailChannelPreviousValuesExec) Exec(ctx context.Context) (*EmailChannelPreviousValues, error) {
	var v EmailChannelPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailChannelPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailChannelPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance EmailChannelPreviousValuesExecArray) Exec(ctx context.Context) ([]EmailChannelPreviousValues, error) {
	var v []EmailChannelPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailChannelPreviousValues struct {
	ID          string   `json:"id"`
	CreatedAt   string   `json:"createdAt"`
	UpdatedAt   string   `json:"updatedAt"`
	IsMain      *bool    `json:"isMain,omitempty"`
	DisplayName string   `json:"displayName"`
	Valid       bool     `json:"valid"`
	Value       string   `json:"value"`
	Extras      []string `json:"extras,omitempty"`
}

type OpeningHoursEdgeExec struct {
	exec *prisma.Exec
}

func (instance *OpeningHoursEdgeExec) Node() *OpeningHoursExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OpeningHours"},
		"node",
		[]string{"id", "mon", "tue", "wed", "thu", "fri", "sat", "sun"})

	return &OpeningHoursExec{ret}
}

func (instance OpeningHoursEdgeExec) Exec(ctx context.Context) (*OpeningHoursEdge, error) {
	var v OpeningHoursEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OpeningHoursEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OpeningHoursEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance OpeningHoursEdgeExecArray) Exec(ctx context.Context) ([]OpeningHoursEdge, error) {
	var v []OpeningHoursEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OpeningHoursEdge struct {
	Node   OpeningHours `json:"node"`
	Cursor string       `json:"cursor"`
}

type AttractionEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AttractionEdgeExec) Node() *AttractionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Attraction"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionExec{ret}
}

func (instance AttractionEdgeExec) Exec(ctx context.Context) (*AttractionEdge, error) {
	var v AttractionEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionEdgeExecArray) Exec(ctx context.Context) ([]AttractionEdge, error) {
	var v []AttractionEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AttractionEdge struct {
	Node   Attraction `json:"node"`
	Cursor string     `json:"cursor"`
}

type TicketSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TicketSubscriptionPayloadExec) Node() *TicketExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Ticket"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "visited", "finished", "state"})

	return &TicketExec{ret}
}

func (instance *TicketSubscriptionPayloadExec) PreviousValues() *TicketPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TicketPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "visited", "finished", "state"})

	return &TicketPreviousValuesExec{ret}
}

func (instance TicketSubscriptionPayloadExec) Exec(ctx context.Context) (*TicketSubscriptionPayload, error) {
	var v TicketSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TicketSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TicketSubscriptionPayload, error) {
	var v []TicketSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TicketSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Ticket      `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type EntryTicketSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *EntryTicketSubscriptionPayloadExec) Node() *EntryTicketExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EntryTicket"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "at"})

	return &EntryTicketExec{ret}
}

func (instance *EntryTicketSubscriptionPayloadExec) PreviousValues() *EntryTicketPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EntryTicketPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "at"})

	return &EntryTicketPreviousValuesExec{ret}
}

func (instance EntryTicketSubscriptionPayloadExec) Exec(ctx context.Context) (*EntryTicketSubscriptionPayload, error) {
	var v EntryTicketSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EntryTicketSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EntryTicketSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance EntryTicketSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]EntryTicketSubscriptionPayload, error) {
	var v []EntryTicketSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EntryTicketSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *EntryTicket `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type LocationEdgeExec struct {
	exec *prisma.Exec
}

func (instance *LocationEdgeExec) Node() *LocationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Location"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "longitude", "latitude"})

	return &LocationExec{ret}
}

func (instance LocationEdgeExec) Exec(ctx context.Context) (*LocationEdge, error) {
	var v LocationEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance LocationEdgeExecArray) Exec(ctx context.Context) ([]LocationEdge, error) {
	var v []LocationEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LocationEdge struct {
	Node   Location `json:"node"`
	Cursor string   `json:"cursor"`
}

type EntryTicketPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance EntryTicketPreviousValuesExec) Exec(ctx context.Context) (*EntryTicketPreviousValues, error) {
	var v EntryTicketPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EntryTicketPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EntryTicketPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance EntryTicketPreviousValuesExecArray) Exec(ctx context.Context) ([]EntryTicketPreviousValues, error) {
	var v []EntryTicketPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EntryTicketPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	At        string `json:"at"`
}

type ActionTicketConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ActionTicketConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ActionTicketConnectionExec) Edges() *ActionTicketEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ActionTicketWhereInput", "ActionTicketOrderByInput", "ActionTicketEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "ActionTicket"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &ActionTicketEdgeExecArray{nodes}
}

func (instance *ActionTicketConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateActionTicket"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ActionTicketConnectionExec) Exec(ctx context.Context) (*ActionTicketConnection, error) {
	var v ActionTicketConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ActionTicketConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ActionTicketConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ActionTicketConnectionExecArray) Exec(ctx context.Context) ([]ActionTicketConnection, error) {
	var v []ActionTicketConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ActionTicketConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []ActionTicketEdge `json:"edges"`
}

type AttractionConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AttractionConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AttractionConnectionExec) Edges() *AttractionEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"AttractionWhereInput", "AttractionOrderByInput", "AttractionEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Attraction"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &AttractionEdgeExecArray{nodes}
}

func (instance *AttractionConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAttraction"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AttractionConnectionExec) Exec(ctx context.Context) (*AttractionConnection, error) {
	var v AttractionConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionConnectionExecArray) Exec(ctx context.Context) ([]AttractionConnection, error) {
	var v []AttractionConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AttractionConnection struct {
	PageInfo PageInfo         `json:"pageInfo"`
	Edges    []AttractionEdge `json:"edges"`
}

type LimaContactEdgeExec struct {
	exec *prisma.Exec
}

func (instance *LimaContactEdgeExec) Node() *LimaContactExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LimaContact"},
		"node",
		[]string{"id", "email", "phoneNumber"})

	return &LimaContactExec{ret}
}

func (instance LimaContactEdgeExec) Exec(ctx context.Context) (*LimaContactEdge, error) {
	var v LimaContactEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LimaContactEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LimaContactEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance LimaContactEdgeExecArray) Exec(ctx context.Context) ([]LimaContactEdge, error) {
	var v []LimaContactEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LimaContactEdge struct {
	Node   LimaContact `json:"node"`
	Cursor string      `json:"cursor"`
}

type ErrorSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ErrorSubscriptionPayloadExec) Node() *ErrorExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Error"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "code", "internal", "explain", "location"})

	return &ErrorExec{ret}
}

func (instance *ErrorSubscriptionPayloadExec) PreviousValues() *ErrorPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ErrorPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "code", "internal", "explain", "location"})

	return &ErrorPreviousValuesExec{ret}
}

func (instance ErrorSubscriptionPayloadExec) Exec(ctx context.Context) (*ErrorSubscriptionPayload, error) {
	var v ErrorSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ErrorSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ErrorSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ErrorSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ErrorSubscriptionPayload, error) {
	var v []ErrorSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ErrorSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Error       `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type ErrorPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ErrorPreviousValuesExec) Exec(ctx context.Context) (*ErrorPreviousValues, error) {
	var v ErrorPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ErrorPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ErrorPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ErrorPreviousValuesExecArray) Exec(ctx context.Context) ([]ErrorPreviousValues, error) {
	var v []ErrorPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ErrorPreviousValues struct {
	ID        string  `json:"id"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	Code      string  `json:"code"`
	Internal  *string `json:"internal,omitempty"`
	Explain   *string `json:"explain,omitempty"`
	Location  *string `json:"location,omitempty"`
}

type LimaEdgeExec struct {
	exec *prisma.Exec
}

func (instance *LimaEdgeExec) Node() *LimaExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Lima"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "version", "available"})

	return &LimaExec{ret}
}

func (instance LimaEdgeExec) Exec(ctx context.Context) (*LimaEdge, error) {
	var v LimaEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LimaEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LimaEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance LimaEdgeExecArray) Exec(ctx context.Context) ([]LimaEdge, error) {
	var v []LimaEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LimaEdge struct {
	Node   Lima   `json:"node"`
	Cursor string `json:"cursor"`
}

type PersonReviewsExec struct {
	exec *prisma.Exec
}

func (instance *PersonReviewsExec) Person() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

func (instance *PersonReviewsExec) Title() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"title",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *PersonReviewsExec) Description() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"description",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

type CommentsParamsExec struct {
	Where   *PersonReviewsWhereInput
	OrderBy *PersonReviewsOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PersonReviewsExec) Comments(params *CommentsParamsExec) *PersonReviewsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PersonReviewsWhereInput", "PersonReviewsOrderByInput", "PersonReviews"},
		"comments",
		[]string{"id", "createdAt", "updatedAt", "approveNumber", "declineNumber"})

	return &PersonReviewsExecArray{ret}
}

func (instance PersonReviewsExec) Exec(ctx context.Context) (*PersonReviews, error) {
	var v PersonReviews
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonReviewsExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonReviewsExecArray struct {
	exec *prisma.Exec
}

func (instance PersonReviewsExecArray) Exec(ctx context.Context) ([]PersonReviews, error) {
	var v []PersonReviews
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonReviews struct {
	ID            string `json:"id"`
	CreatedAt     string `json:"createdAt"`
	UpdatedAt     string `json:"updatedAt"`
	ApproveNumber *int32 `json:"approveNumber,omitempty"`
	DeclineNumber *int32 `json:"declineNumber,omitempty"`
}

type ActionTicketEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ActionTicketEdgeExec) Node() *ActionTicketExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ActionTicket"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "token", "available", "used"})

	return &ActionTicketExec{ret}
}

func (instance ActionTicketEdgeExec) Exec(ctx context.Context) (*ActionTicketEdge, error) {
	var v ActionTicketEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ActionTicketEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ActionTicketEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ActionTicketEdgeExecArray) Exec(ctx context.Context) ([]ActionTicketEdge, error) {
	var v []ActionTicketEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ActionTicketEdge struct {
	Node   ActionTicket `json:"node"`
	Cursor string       `json:"cursor"`
}

type ExpertSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ExpertSubscriptionPayloadExec) Node() *ExpertExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Expert"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "alias"})

	return &ExpertExec{ret}
}

func (instance *ExpertSubscriptionPayloadExec) PreviousValues() *ExpertPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ExpertPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "alias"})

	return &ExpertPreviousValuesExec{ret}
}

func (instance ExpertSubscriptionPayloadExec) Exec(ctx context.Context) (*ExpertSubscriptionPayload, error) {
	var v ExpertSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ExpertSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ExpertSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ExpertSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ExpertSubscriptionPayload, error) {
	var v []ExpertSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ExpertSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Expert      `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ExpertPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ExpertPreviousValuesExec) Exec(ctx context.Context) (*ExpertPreviousValues, error) {
	var v ExpertPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ExpertPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ExpertPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ExpertPreviousValuesExecArray) Exec(ctx context.Context) ([]ExpertPreviousValues, error) {
	var v []ExpertPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ExpertPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Alias     string `json:"alias"`
}

type StoryExec struct {
	exec *prisma.Exec
}

func (instance *StoryExec) Author() *ExpertExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Expert"},
		"author",
		[]string{"id", "createdAt", "updatedAt", "alias"})

	return &ExpertExec{ret}
}

func (instance *StoryExec) Title() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"title",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *StoryExec) Body() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"body",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

type ReviewsParamsExec struct {
	Where   *PersonReviewsWhereInput
	OrderBy *PersonReviewsOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *StoryExec) Reviews(params *ReviewsParamsExec) *PersonReviewsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PersonReviewsWhereInput", "PersonReviewsOrderByInput", "PersonReviews"},
		"reviews",
		[]string{"id", "createdAt", "updatedAt", "approveNumber", "declineNumber"})

	return &PersonReviewsExecArray{ret}
}

func (instance *StoryExec) LinkedRoute() *RouteExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Route"},
		"linkedRoute",
		[]string{"id", "createdAt", "updatedAt", "name", "image", "type", "extraTypes", "popularity", "color"})

	return &RouteExec{ret}
}

func (instance StoryExec) Exec(ctx context.Context) (*Story, error) {
	var v Story
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance StoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type StoryExecArray struct {
	exec *prisma.Exec
}

func (instance StoryExecArray) Exec(ctx context.Context) ([]Story, error) {
	var v []Story
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Story struct {
	ID             string    `json:"id"`
	CreatedAt      string    `json:"createdAt"`
	UpdatedAt      string    `json:"updatedAt"`
	Type           StoryType `json:"type"`
	Tags           []string  `json:"tags,omitempty"`
	PodcastLink    *string   `json:"podcastLink,omitempty"`
	AudioStream    *string   `json:"audioStream,omitempty"`
	PrincipalImage string    `json:"principalImage"`
	Likes          int32     `json:"likes"`
	Views          int32     `json:"views"`
}

type IDDocumentConnectionExec struct {
	exec *prisma.Exec
}

func (instance *IDDocumentConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *IDDocumentConnectionExec) Edges() *IDDocumentEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"IDDocumentWhereInput", "IDDocumentOrderByInput", "IDDocumentEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "IDDocument"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &IDDocumentEdgeExecArray{nodes}
}

func (instance *IDDocumentConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateIDDocument"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance IDDocumentConnectionExec) Exec(ctx context.Context) (*IDDocumentConnection, error) {
	var v IDDocumentConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDDocumentConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDDocumentConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance IDDocumentConnectionExecArray) Exec(ctx context.Context) ([]IDDocumentConnection, error) {
	var v []IDDocumentConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDDocumentConnection struct {
	PageInfo PageInfo         `json:"pageInfo"`
	Edges    []IDDocumentEdge `json:"edges"`
}

type FaqSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *FaqSubscriptionPayloadExec) Node() *FaqExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Faq"},
		"node",
		[]string{"id", "createdAt", "updatedAt"})

	return &FaqExec{ret}
}

func (instance *FaqSubscriptionPayloadExec) PreviousValues() *FaqPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FaqPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt"})

	return &FaqPreviousValuesExec{ret}
}

func (instance FaqSubscriptionPayloadExec) Exec(ctx context.Context) (*FaqSubscriptionPayload, error) {
	var v FaqSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FaqSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FaqSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance FaqSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]FaqSubscriptionPayload, error) {
	var v []FaqSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FaqSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Faq         `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type FeatureEdgeExec struct {
	exec *prisma.Exec
}

func (instance *FeatureEdgeExec) Node() *FeatureExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Feature"},
		"node",
		[]string{"id", "image"})

	return &FeatureExec{ret}
}

func (instance FeatureEdgeExec) Exec(ctx context.Context) (*FeatureEdge, error) {
	var v FeatureEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeatureEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeatureEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance FeatureEdgeExecArray) Exec(ctx context.Context) ([]FeatureEdge, error) {
	var v []FeatureEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FeatureEdge struct {
	Node   Feature `json:"node"`
	Cursor string  `json:"cursor"`
}

type FaqPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance FaqPreviousValuesExec) Exec(ctx context.Context) (*FaqPreviousValues, error) {
	var v FaqPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FaqPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FaqPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance FaqPreviousValuesExecArray) Exec(ctx context.Context) ([]FaqPreviousValues, error) {
	var v []FaqPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FaqPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type ExpertExec struct {
	exec *prisma.Exec
}

func (instance *ExpertExec) Person() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

type StoriesParamsExec struct {
	Where   *StoryWhereInput
	OrderBy *StoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *ExpertExec) Stories(params *StoriesParamsExec) *StoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"StoryWhereInput", "StoryOrderByInput", "Story"},
		"stories",
		[]string{"id", "createdAt", "updatedAt", "type", "tags", "podcastLink", "audioStream", "principalImage", "likes", "views"})

	return &StoryExecArray{ret}
}

func (instance ExpertExec) Exec(ctx context.Context) (*Expert, error) {
	var v Expert
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ExpertExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ExpertExecArray struct {
	exec *prisma.Exec
}

func (instance ExpertExecArray) Exec(ctx context.Context) ([]Expert, error) {
	var v []Expert
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Expert struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Alias     string `json:"alias"`
}

type FaqEntryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *FaqEntryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *FaqEntryConnectionExec) Edges() *FaqEntryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"FaqEntryWhereInput", "FaqEntryOrderByInput", "FaqEntryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "FaqEntry"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &FaqEntryEdgeExecArray{nodes}
}

func (instance *FaqEntryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateFaqEntry"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance FaqEntryConnectionExec) Exec(ctx context.Context) (*FaqEntryConnection, error) {
	var v FaqEntryConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FaqEntryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FaqEntryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance FaqEntryConnectionExecArray) Exec(ctx context.Context) ([]FaqEntryConnection, error) {
	var v []FaqEntryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FaqEntryConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []FaqEntryEdge `json:"edges"`
}

type FaqEntrySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *FaqEntrySubscriptionPayloadExec) Node() *FaqEntryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FaqEntry"},
		"node",
		[]string{"id"})

	return &FaqEntryExec{ret}
}

func (instance *FaqEntrySubscriptionPayloadExec) PreviousValues() *FaqEntryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FaqEntryPreviousValues"},
		"previousValues",
		[]string{"id"})

	return &FaqEntryPreviousValuesExec{ret}
}

func (instance FaqEntrySubscriptionPayloadExec) Exec(ctx context.Context) (*FaqEntrySubscriptionPayload, error) {
	var v FaqEntrySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FaqEntrySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FaqEntrySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance FaqEntrySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]FaqEntrySubscriptionPayload, error) {
	var v []FaqEntrySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FaqEntrySubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *FaqEntry    `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type FaqEdgeExec struct {
	exec *prisma.Exec
}

func (instance *FaqEdgeExec) Node() *FaqExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Faq"},
		"node",
		[]string{"id", "createdAt", "updatedAt"})

	return &FaqExec{ret}
}

func (instance FaqEdgeExec) Exec(ctx context.Context) (*FaqEdge, error) {
	var v FaqEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FaqEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FaqEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance FaqEdgeExecArray) Exec(ctx context.Context) ([]FaqEdge, error) {
	var v []FaqEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FaqEdge struct {
	Node   Faq    `json:"node"`
	Cursor string `json:"cursor"`
}

type FaqEntryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance FaqEntryPreviousValuesExec) Exec(ctx context.Context) (*FaqEntryPreviousValues, error) {
	var v FaqEntryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FaqEntryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FaqEntryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance FaqEntryPreviousValuesExecArray) Exec(ctx context.Context) ([]FaqEntryPreviousValues, error) {
	var v []FaqEntryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FaqEntryPreviousValues struct {
	ID string `json:"id"`
}

type AttractionExec struct {
	exec *prisma.Exec
}

func (instance *AttractionExec) Owner() *PartnerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Partner"},
		"owner",
		[]string{"id", "createdAt", "updatedAt", "brandName", "logo", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

func (instance *AttractionExec) Name() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"name",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *AttractionExec) Description() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"description",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *AttractionExec) ShortDescription() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"shortDescription",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *AttractionExec) Faqs() *FaqExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Faq"},
		"faqs",
		[]string{"id", "createdAt", "updatedAt"})

	return &FaqExec{ret}
}

func (instance *AttractionExec) Place() *PlaceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Place"},
		"place",
		[]string{"id", "createdAt", "updatedAt", "name", "shortName", "address", "googleLink", "website", "type", "extraTypes", "tags", "popularity", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &PlaceExec{ret}
}

func (instance AttractionExec) Exec(ctx context.Context) (*Attraction, error) {
	var v Attraction
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AttractionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AttractionExecArray struct {
	exec *prisma.Exec
}

func (instance AttractionExecArray) Exec(ctx context.Context) ([]Attraction, error) {
	var v []Attraction
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Attraction struct {
	ID             string           `json:"id"`
	CreatedAt      string           `json:"createdAt"`
	UpdatedAt      string           `json:"updatedAt"`
	PrincipalImage *string          `json:"principalImage,omitempty"`
	CoverImage     *string          `json:"coverImage,omitempty"`
	LandscapeImage *string          `json:"landscapeImage,omitempty"`
	Gallery        []string         `json:"gallery,omitempty"`
	Type           []ExperienceType `json:"type,omitempty"`
}

type RouteExec struct {
	exec *prisma.Exec
}

func (instance *RouteExec) Creator() *ExpertExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Expert"},
		"creator",
		[]string{"id", "createdAt", "updatedAt", "alias"})

	return &ExpertExec{ret}
}

type PlacesParamsExec struct {
	Where   *PlaceWhereInput
	OrderBy *PlaceOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *RouteExec) Places(params *PlacesParamsExec) *PlaceExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PlaceWhereInput", "PlaceOrderByInput", "Place"},
		"places",
		[]string{"id", "createdAt", "updatedAt", "name", "shortName", "address", "googleLink", "website", "type", "extraTypes", "tags", "popularity", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &PlaceExecArray{ret}
}

func (instance *RouteExec) LinkedStory() *StoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Story"},
		"linkedStory",
		[]string{"id", "createdAt", "updatedAt", "type", "tags", "podcastLink", "audioStream", "principalImage", "likes", "views"})

	return &StoryExec{ret}
}

type LikedByParamsExec struct {
	Where   *PersonWhereInput
	OrderBy *PersonOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *RouteExec) LikedBy(params *LikedByParamsExec) *PersonExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PersonWhereInput", "PersonOrderByInput", "Person"},
		"likedBy",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExecArray{ret}
}

func (instance *RouteExec) Reviews(params *ReviewsParamsExec) *PersonReviewsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PersonReviewsWhereInput", "PersonReviewsOrderByInput", "PersonReviews"},
		"reviews",
		[]string{"id", "createdAt", "updatedAt", "approveNumber", "declineNumber"})

	return &PersonReviewsExecArray{ret}
}

func (instance RouteExec) Exec(ctx context.Context) (*Route, error) {
	var v Route
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RouteExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RouteExecArray struct {
	exec *prisma.Exec
}

func (instance RouteExecArray) Exec(ctx context.Context) ([]Route, error) {
	var v []Route
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Route struct {
	ID         string           `json:"id"`
	CreatedAt  string           `json:"createdAt"`
	UpdatedAt  string           `json:"updatedAt"`
	Name       string           `json:"name"`
	Image      string           `json:"image"`
	Type       ExperienceType   `json:"type"`
	ExtraTypes []ExperienceType `json:"extraTypes,omitempty"`
	Popularity float64          `json:"popularity"`
	Color      string           `json:"color"`
}

type ExpertEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ExpertEdgeExec) Node() *ExpertExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Expert"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "alias"})

	return &ExpertExec{ret}
}

func (instance ExpertEdgeExec) Exec(ctx context.Context) (*ExpertEdge, error) {
	var v ExpertEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ExpertEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ExpertEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ExpertEdgeExecArray) Exec(ctx context.Context) ([]ExpertEdge, error) {
	var v []ExpertEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ExpertEdge struct {
	Node   Expert `json:"node"`
	Cursor string `json:"cursor"`
}

type FeatureSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *FeatureSubscriptionPayloadExec) Node() *FeatureExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Feature"},
		"node",
		[]string{"id", "image"})

	return &FeatureExec{ret}
}

func (instance *FeatureSubscriptionPayloadExec) PreviousValues() *FeaturePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FeaturePreviousValues"},
		"previousValues",
		[]string{"id", "image"})

	return &FeaturePreviousValuesExec{ret}
}

func (instance FeatureSubscriptionPayloadExec) Exec(ctx context.Context) (*FeatureSubscriptionPayload, error) {
	var v FeatureSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeatureSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeatureSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance FeatureSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]FeatureSubscriptionPayload, error) {
	var v []FeatureSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FeatureSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Feature     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type FeaturePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance FeaturePreviousValuesExec) Exec(ctx context.Context) (*FeaturePreviousValues, error) {
	var v FeaturePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeaturePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeaturePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance FeaturePreviousValuesExecArray) Exec(ctx context.Context) ([]FeaturePreviousValues, error) {
	var v []FeaturePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FeaturePreviousValues struct {
	ID    string  `json:"id"`
	Image *string `json:"image,omitempty"`
}

type ErrorConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ErrorConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ErrorConnectionExec) Edges() *ErrorEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ErrorWhereInput", "ErrorOrderByInput", "ErrorEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Error"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &ErrorEdgeExecArray{nodes}
}

func (instance *ErrorConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateError"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ErrorConnectionExec) Exec(ctx context.Context) (*ErrorConnection, error) {
	var v ErrorConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ErrorConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ErrorConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ErrorConnectionExecArray) Exec(ctx context.Context) ([]ErrorConnection, error) {
	var v []ErrorConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ErrorConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []ErrorEdge `json:"edges"`
}

type PlaceExec struct {
	exec *prisma.Exec
}

func (instance *PlaceExec) Description() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"description",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *PlaceExec) ShortDescription() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"shortDescription",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *PlaceExec) Location() *LocationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Location"},
		"location",
		[]string{"id", "createdAt", "updatedAt", "longitude", "latitude"})

	return &LocationExec{ret}
}

type RoutesParamsExec struct {
	Where   *RouteWhereInput
	OrderBy *RouteOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PlaceExec) Routes(params *RoutesParamsExec) *RouteExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"RouteWhereInput", "RouteOrderByInput", "Route"},
		"routes",
		[]string{"id", "createdAt", "updatedAt", "name", "image", "type", "extraTypes", "popularity", "color"})

	return &RouteExecArray{ret}
}

func (instance *PlaceExec) Reviews(params *ReviewsParamsExec) *PersonReviewsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PersonReviewsWhereInput", "PersonReviewsOrderByInput", "PersonReviews"},
		"reviews",
		[]string{"id", "createdAt", "updatedAt", "approveNumber", "declineNumber"})

	return &PersonReviewsExecArray{ret}
}

func (instance *PlaceExec) LikedBy(params *LikedByParamsExec) *PersonExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PersonWhereInput", "PersonOrderByInput", "Person"},
		"likedBy",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExecArray{ret}
}

type AmbassadorsParamsExec struct {
	Where   *ExpertWhereInput
	OrderBy *ExpertOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PlaceExec) Ambassadors(params *AmbassadorsParamsExec) *ExpertExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ExpertWhereInput", "ExpertOrderByInput", "Expert"},
		"ambassadors",
		[]string{"id", "createdAt", "updatedAt", "alias"})

	return &ExpertExecArray{ret}
}

func (instance *PlaceExec) OpeningHours() *OpeningHoursExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OpeningHours"},
		"openingHours",
		[]string{"id", "mon", "tue", "wed", "thu", "fri", "sat", "sun"})

	return &OpeningHoursExec{ret}
}

func (instance PlaceExec) Exec(ctx context.Context) (*Place, error) {
	var v Place
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PlaceExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PlaceExecArray struct {
	exec *prisma.Exec
}

func (instance PlaceExecArray) Exec(ctx context.Context) ([]Place, error) {
	var v []Place
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Place struct {
	ID               string           `json:"id"`
	CreatedAt        string           `json:"createdAt"`
	UpdatedAt        string           `json:"updatedAt"`
	Name             string           `json:"name"`
	ShortName        *string          `json:"shortName,omitempty"`
	Address          string           `json:"address"`
	GoogleLink       *string          `json:"googleLink,omitempty"`
	Website          *string          `json:"website,omitempty"`
	Type             ExperienceType   `json:"type"`
	ExtraTypes       []ExperienceType `json:"extraTypes,omitempty"`
	Tags             []string         `json:"tags,omitempty"`
	Popularity       float64          `json:"popularity"`
	ProviderWeb      *string          `json:"providerWeb,omitempty"`
	ContactPhone     *string          `json:"contactPhone,omitempty"`
	ContactEmail     *string          `json:"contactEmail,omitempty"`
	AddressReference *string          `json:"addressReference,omitempty"`
}

type ErrorExec struct {
	exec *prisma.Exec
}

func (instance *ErrorExec) Message() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"message",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance ErrorExec) Exec(ctx context.Context) (*Error, error) {
	var v Error
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ErrorExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ErrorExecArray struct {
	exec *prisma.Exec
}

func (instance ErrorExecArray) Exec(ctx context.Context) ([]Error, error) {
	var v []Error
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Error struct {
	ID        string  `json:"id"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	Code      string  `json:"code"`
	Internal  *string `json:"internal,omitempty"`
	Explain   *string `json:"explain,omitempty"`
	Location  *string `json:"location,omitempty"`
}

type IDDocumentSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *IDDocumentSubscriptionPayloadExec) Node() *IDDocumentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IDDocument"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDDocumentExec{ret}
}

func (instance *IDDocumentSubscriptionPayloadExec) PreviousValues() *IDDocumentPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IDDocumentPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDDocumentPreviousValuesExec{ret}
}

func (instance IDDocumentSubscriptionPayloadExec) Exec(ctx context.Context) (*IDDocumentSubscriptionPayload, error) {
	var v IDDocumentSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDDocumentSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDDocumentSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance IDDocumentSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]IDDocumentSubscriptionPayload, error) {
	var v []IDDocumentSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDDocumentSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *IDDocument  `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type EntryTicketEdgeExec struct {
	exec *prisma.Exec
}

func (instance *EntryTicketEdgeExec) Node() *EntryTicketExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EntryTicket"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "at"})

	return &EntryTicketExec{ret}
}

func (instance EntryTicketEdgeExec) Exec(ctx context.Context) (*EntryTicketEdge, error) {
	var v EntryTicketEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EntryTicketEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EntryTicketEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance EntryTicketEdgeExecArray) Exec(ctx context.Context) ([]EntryTicketEdge, error) {
	var v []EntryTicketEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EntryTicketEdge struct {
	Node   EntryTicket `json:"node"`
	Cursor string      `json:"cursor"`
}

type IDDocumentPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance IDDocumentPreviousValuesExec) Exec(ctx context.Context) (*IDDocumentPreviousValues, error) {
	var v IDDocumentPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDDocumentPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDDocumentPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance IDDocumentPreviousValuesExecArray) Exec(ctx context.Context) ([]IDDocumentPreviousValues, error) {
	var v []IDDocumentPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDDocumentPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Type      IDType `json:"type"`
	Value     string `json:"value"`
	Validated *bool  `json:"validated,omitempty"`
}

type FaqEntryExec struct {
	exec *prisma.Exec
}

func (instance *FaqEntryExec) Faq() *FaqExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Faq"},
		"faq",
		[]string{"id", "createdAt", "updatedAt"})

	return &FaqExec{ret}
}

func (instance *FaqEntryExec) Question() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"question",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *FaqEntryExec) Answer() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"answer",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance FaqEntryExec) Exec(ctx context.Context) (*FaqEntry, error) {
	var v FaqEntry
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FaqEntryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FaqEntryExecArray struct {
	exec *prisma.Exec
}

func (instance FaqEntryExecArray) Exec(ctx context.Context) ([]FaqEntry, error) {
	var v []FaqEntry
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FaqEntry struct {
	ID string `json:"id"`
}

type EmailChannelConnectionExec struct {
	exec *prisma.Exec
}

func (instance *EmailChannelConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *EmailChannelConnectionExec) Edges() *EmailChannelEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"EmailChannelWhereInput", "EmailChannelOrderByInput", "EmailChannelEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "EmailChannel"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &EmailChannelEdgeExecArray{nodes}
}

func (instance *EmailChannelConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateEmailChannel"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance EmailChannelConnectionExec) Exec(ctx context.Context) (*EmailChannelConnection, error) {
	var v EmailChannelConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailChannelConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailChannelConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance EmailChannelConnectionExecArray) Exec(ctx context.Context) ([]EmailChannelConnection, error) {
	var v []EmailChannelConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailChannelConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []EmailChannelEdge `json:"edges"`
}

type LimaSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *LimaSubscriptionPayloadExec) Node() *LimaExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Lima"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "version", "available"})

	return &LimaExec{ret}
}

func (instance *LimaSubscriptionPayloadExec) PreviousValues() *LimaPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LimaPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "version", "available"})

	return &LimaPreviousValuesExec{ret}
}

func (instance LimaSubscriptionPayloadExec) Exec(ctx context.Context) (*LimaSubscriptionPayload, error) {
	var v LimaSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LimaSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LimaSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance LimaSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LimaSubscriptionPayload, error) {
	var v []LimaSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LimaSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Lima        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CurrencyEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CurrencyEdgeExec) Node() *CurrencyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Currency"},
		"node",
		[]string{"id", "code", "symbol"})

	return &CurrencyExec{ret}
}

func (instance CurrencyEdgeExec) Exec(ctx context.Context) (*CurrencyEdge, error) {
	var v CurrencyEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CurrencyEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CurrencyEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CurrencyEdgeExecArray) Exec(ctx context.Context) ([]CurrencyEdge, error) {
	var v []CurrencyEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CurrencyEdge struct {
	Node   Currency `json:"node"`
	Cursor string   `json:"cursor"`
}

type LimaPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance LimaPreviousValuesExec) Exec(ctx context.Context) (*LimaPreviousValues, error) {
	var v LimaPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LimaPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LimaPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance LimaPreviousValuesExecArray) Exec(ctx context.Context) ([]LimaPreviousValues, error) {
	var v []LimaPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LimaPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Version   string `json:"version"`
	Available bool   `json:"available"`
}

type PhoneChannelExec struct {
	exec *prisma.Exec
}

func (instance *PhoneChannelExec) Person() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

func (instance PhoneChannelExec) Exec(ctx context.Context) (*PhoneChannel, error) {
	var v PhoneChannel
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneChannelExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneChannelExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneChannelExecArray) Exec(ctx context.Context) ([]PhoneChannel, error) {
	var v []PhoneChannel
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhoneChannel struct {
	ID          string  `json:"id"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
	IsMain      *bool   `json:"isMain,omitempty"`
	DisplayName string  `json:"displayName"`
	Valid       bool    `json:"valid"`
	CountryCode string  `json:"countryCode"`
	Number      *string `json:"number,omitempty"`
}

type LimaContactSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *LimaContactSubscriptionPayloadExec) Node() *LimaContactExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LimaContact"},
		"node",
		[]string{"id", "email", "phoneNumber"})

	return &LimaContactExec{ret}
}

func (instance *LimaContactSubscriptionPayloadExec) PreviousValues() *LimaContactPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LimaContactPreviousValues"},
		"previousValues",
		[]string{"id", "email", "phoneNumber"})

	return &LimaContactPreviousValuesExec{ret}
}

func (instance LimaContactSubscriptionPayloadExec) Exec(ctx context.Context) (*LimaContactSubscriptionPayload, error) {
	var v LimaContactSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LimaContactSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LimaContactSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance LimaContactSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LimaContactSubscriptionPayload, error) {
	var v []LimaContactSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LimaContactSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *LimaContact `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type TextEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TextEdgeExec) Node() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"node",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance TextEdgeExec) Exec(ctx context.Context) (*TextEdge, error) {
	var v TextEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TextEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TextEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TextEdgeExecArray) Exec(ctx context.Context) ([]TextEdge, error) {
	var v []TextEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TextEdge struct {
	Node   Text   `json:"node"`
	Cursor string `json:"cursor"`
}

type LimaContactPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance LimaContactPreviousValuesExec) Exec(ctx context.Context) (*LimaContactPreviousValues, error) {
	var v LimaContactPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LimaContactPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LimaContactPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance LimaContactPreviousValuesExecArray) Exec(ctx context.Context) ([]LimaContactPreviousValues, error) {
	var v []LimaContactPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LimaContactPreviousValues struct {
	ID          string `json:"id"`
	Email       string `json:"email"`
	PhoneNumber string `json:"phoneNumber"`
}

type StoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *StoryEdgeExec) Node() *StoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Story"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "tags", "podcastLink", "audioStream", "principalImage", "likes", "views"})

	return &StoryExec{ret}
}

func (instance StoryEdgeExec) Exec(ctx context.Context) (*StoryEdge, error) {
	var v StoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance StoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type StoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance StoryEdgeExecArray) Exec(ctx context.Context) ([]StoryEdge, error) {
	var v []StoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type StoryEdge struct {
	Node   Story  `json:"node"`
	Cursor string `json:"cursor"`
}

type FaqExec struct {
	exec *prisma.Exec
}

func (instance *FaqExec) Attraction() *AttractionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Attraction"},
		"attraction",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionExec{ret}
}

type EntriesParamsExec struct {
	Where   *FaqEntryWhereInput
	OrderBy *FaqEntryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *FaqExec) Entries(params *EntriesParamsExec) *FaqEntryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"FaqEntryWhereInput", "FaqEntryOrderByInput", "FaqEntry"},
		"entries",
		[]string{"id"})

	return &FaqEntryExecArray{ret}
}

func (instance FaqExec) Exec(ctx context.Context) (*Faq, error) {
	var v Faq
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FaqExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FaqExecArray struct {
	exec *prisma.Exec
}

func (instance FaqExecArray) Exec(ctx context.Context) ([]Faq, error) {
	var v []Faq
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Faq struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type RouteConnectionExec struct {
	exec *prisma.Exec
}

func (instance *RouteConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *RouteConnectionExec) Edges() *RouteEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"RouteWhereInput", "RouteOrderByInput", "RouteEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Route"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &RouteEdgeExecArray{nodes}
}

func (instance *RouteConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateRoute"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance RouteConnectionExec) Exec(ctx context.Context) (*RouteConnection, error) {
	var v RouteConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RouteConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RouteConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance RouteConnectionExecArray) Exec(ctx context.Context) ([]RouteConnection, error) {
	var v []RouteConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RouteConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []RouteEdge `json:"edges"`
}

type LocationSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *LocationSubscriptionPayloadExec) Node() *LocationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Location"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "longitude", "latitude"})

	return &LocationExec{ret}
}

func (instance *LocationSubscriptionPayloadExec) PreviousValues() *LocationPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LocationPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "longitude", "latitude"})

	return &LocationPreviousValuesExec{ret}
}

func (instance LocationSubscriptionPayloadExec) Exec(ctx context.Context) (*LocationSubscriptionPayload, error) {
	var v LocationSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance LocationSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]LocationSubscriptionPayload, error) {
	var v []LocationSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LocationSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Location    `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type LocationPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance LocationPreviousValuesExec) Exec(ctx context.Context) (*LocationPreviousValues, error) {
	var v LocationPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance LocationPreviousValuesExecArray) Exec(ctx context.Context) ([]LocationPreviousValues, error) {
	var v []LocationPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LocationPreviousValues struct {
	ID        string  `json:"id"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	Longitude float64 `json:"longitude"`
	Latitude  float64 `json:"latitude"`
}

type PlaceEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PlaceEdgeExec) Node() *PlaceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Place"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "shortName", "address", "googleLink", "website", "type", "extraTypes", "tags", "popularity", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &PlaceExec{ret}
}

func (instance PlaceEdgeExec) Exec(ctx context.Context) (*PlaceEdge, error) {
	var v PlaceEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PlaceEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PlaceEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PlaceEdgeExecArray) Exec(ctx context.Context) ([]PlaceEdge, error) {
	var v []PlaceEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PlaceEdge struct {
	Node   Place  `json:"node"`
	Cursor string `json:"cursor"`
}

type EmailChannelExec struct {
	exec *prisma.Exec
}

func (instance *EmailChannelExec) Person() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

func (instance EmailChannelExec) Exec(ctx context.Context) (*EmailChannel, error) {
	var v EmailChannel
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailChannelExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailChannelExecArray struct {
	exec *prisma.Exec
}

func (instance EmailChannelExecArray) Exec(ctx context.Context) ([]EmailChannel, error) {
	var v []EmailChannel
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailChannel struct {
	ID          string   `json:"id"`
	CreatedAt   string   `json:"createdAt"`
	UpdatedAt   string   `json:"updatedAt"`
	IsMain      *bool    `json:"isMain,omitempty"`
	DisplayName string   `json:"displayName"`
	Valid       bool     `json:"valid"`
	Value       string   `json:"value"`
	Extras      []string `json:"extras,omitempty"`
}

type PhoneChannelConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PhoneChannelConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PhoneChannelConnectionExec) Edges() *PhoneChannelEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PhoneChannelWhereInput", "PhoneChannelOrderByInput", "PhoneChannelEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "PhoneChannel"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &PhoneChannelEdgeExecArray{nodes}
}

func (instance *PhoneChannelConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePhoneChannel"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PhoneChannelConnectionExec) Exec(ctx context.Context) (*PhoneChannelConnection, error) {
	var v PhoneChannelConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneChannelConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneChannelConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneChannelConnectionExecArray) Exec(ctx context.Context) ([]PhoneChannelConnection, error) {
	var v []PhoneChannelConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhoneChannelConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []PhoneChannelEdge `json:"edges"`
}

type OpeningHoursSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *OpeningHoursSubscriptionPayloadExec) Node() *OpeningHoursExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OpeningHours"},
		"node",
		[]string{"id", "mon", "tue", "wed", "thu", "fri", "sat", "sun"})

	return &OpeningHoursExec{ret}
}

func (instance *OpeningHoursSubscriptionPayloadExec) PreviousValues() *OpeningHoursPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OpeningHoursPreviousValues"},
		"previousValues",
		[]string{"id", "mon", "tue", "wed", "thu", "fri", "sat", "sun"})

	return &OpeningHoursPreviousValuesExec{ret}
}

func (instance OpeningHoursSubscriptionPayloadExec) Exec(ctx context.Context) (*OpeningHoursSubscriptionPayload, error) {
	var v OpeningHoursSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OpeningHoursSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OpeningHoursSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance OpeningHoursSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]OpeningHoursSubscriptionPayload, error) {
	var v []OpeningHoursSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OpeningHoursSubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *OpeningHours `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type OpeningHoursPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance OpeningHoursPreviousValuesExec) Exec(ctx context.Context) (*OpeningHoursPreviousValues, error) {
	var v OpeningHoursPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OpeningHoursPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OpeningHoursPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance OpeningHoursPreviousValuesExecArray) Exec(ctx context.Context) ([]OpeningHoursPreviousValues, error) {
	var v []OpeningHoursPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OpeningHoursPreviousValues struct {
	ID  string  `json:"id"`
	Mon *string `json:"mon,omitempty"`
	Tue *string `json:"tue,omitempty"`
	Wed *string `json:"wed,omitempty"`
	Thu *string `json:"thu,omitempty"`
	Fri *string `json:"fri,omitempty"`
	Sat *string `json:"sat,omitempty"`
	Sun *string `json:"sun,omitempty"`
}

type PaymentMethodEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PaymentMethodEdgeExec) Node() *PaymentMethodExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentMethod"},
		"node",
		[]string{"id", "type", "value", "cardNumber", "code"})

	return &PaymentMethodExec{ret}
}

func (instance PaymentMethodEdgeExec) Exec(ctx context.Context) (*PaymentMethodEdge, error) {
	var v PaymentMethodEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentMethodEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentMethodEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentMethodEdgeExecArray) Exec(ctx context.Context) ([]PaymentMethodEdge, error) {
	var v []PaymentMethodEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentMethodEdge struct {
	Node   PaymentMethod `json:"node"`
	Cursor string        `json:"cursor"`
}

type CreditCardExec struct {
	exec *prisma.Exec
}

func (instance *CreditCardExec) Owner() *TravelerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Traveler"},
		"owner",
		[]string{"id", "createdAt", "updatedAt", "unregistered", "username"})

	return &TravelerExec{ret}
}

func (instance CreditCardExec) Exec(ctx context.Context) (*CreditCard, error) {
	var v CreditCard
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CreditCardExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CreditCardExecArray struct {
	exec *prisma.Exec
}

func (instance CreditCardExecArray) Exec(ctx context.Context) ([]CreditCard, error) {
	var v []CreditCard
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CreditCard struct {
	ID            string         `json:"id"`
	CreatedAt     string         `json:"createdAt"`
	UpdatedAt     string         `json:"updatedAt"`
	CustomerToken string         `json:"customerToken"`
	CardNumber    string         `json:"cardNumber"`
	CardToken     string         `json:"cardToken"`
	Type          CreditCardType `json:"type"`
	LastUsed      *string        `json:"lastUsed,omitempty"`
}

type PassTypeEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PassTypeEdgeExec) Node() *PassTypeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PassType"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "gallery", "creatorID", "duration"})

	return &PassTypeExec{ret}
}

func (instance PassTypeEdgeExec) Exec(ctx context.Context) (*PassTypeEdge, error) {
	var v PassTypeEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PassTypeEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PassTypeEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PassTypeEdgeExecArray) Exec(ctx context.Context) ([]PassTypeEdge, error) {
	var v []PassTypeEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PassTypeEdge struct {
	Node   PassType `json:"node"`
	Cursor string   `json:"cursor"`
}

type PartnerSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PartnerSubscriptionPayloadExec) Node() *PartnerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Partner"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "brandName", "logo", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

func (instance *PartnerSubscriptionPayloadExec) PreviousValues() *PartnerPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PartnerPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "brandName", "logo", "socialReason", "ruc", "address"})

	return &PartnerPreviousValuesExec{ret}
}

func (instance PartnerSubscriptionPayloadExec) Exec(ctx context.Context) (*PartnerSubscriptionPayload, error) {
	var v PartnerSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PartnerSubscriptionPayload, error) {
	var v []PartnerSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PartnerSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Partner     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PassConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PassConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PassConnectionExec) Edges() *PassEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PassWhereInput", "PassOrderByInput", "PassEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Pass"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &PassEdgeExecArray{nodes}
}

func (instance *PassConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePass"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PassConnectionExec) Exec(ctx context.Context) (*PassConnection, error) {
	var v PassConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PassConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PassConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PassConnectionExecArray) Exec(ctx context.Context) ([]PassConnection, error) {
	var v []PassConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PassConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []PassEdge `json:"edges"`
}

type PartnerPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PartnerPreviousValuesExec) Exec(ctx context.Context) (*PartnerPreviousValues, error) {
	var v PartnerPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerPreviousValuesExecArray) Exec(ctx context.Context) ([]PartnerPreviousValues, error) {
	var v []PartnerPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PartnerPreviousValues struct {
	ID           string `json:"id"`
	CreatedAt    string `json:"createdAt"`
	UpdatedAt    string `json:"updatedAt"`
	BrandName    string `json:"brandName"`
	Logo         string `json:"logo"`
	SocialReason string `json:"socialReason"`
	Ruc          string `json:"ruc"`
	Address      string `json:"address"`
}

type IDDocumentExec struct {
	exec *prisma.Exec
}

func (instance *IDDocumentExec) Person() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

func (instance IDDocumentExec) Exec(ctx context.Context) (*IDDocument, error) {
	var v IDDocument
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDDocumentExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDDocumentExecArray struct {
	exec *prisma.Exec
}

func (instance IDDocumentExecArray) Exec(ctx context.Context) ([]IDDocument, error) {
	var v []IDDocument
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDDocument struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Type      IDType `json:"type"`
	Value     string `json:"value"`
	Validated *bool  `json:"validated,omitempty"`
}

type PassSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PassSubscriptionPayloadExec) Node() *PassExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Pass"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "expireAt", "state"})

	return &PassExec{ret}
}

func (instance *PassSubscriptionPayloadExec) PreviousValues() *PassPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PassPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "expireAt", "state"})

	return &PassPreviousValuesExec{ret}
}

func (instance PassSubscriptionPayloadExec) Exec(ctx context.Context) (*PassSubscriptionPayload, error) {
	var v PassSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PassSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PassSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PassSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PassSubscriptionPayload, error) {
	var v []PassSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PassSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Pass        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PassPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PassPreviousValuesExec) Exec(ctx context.Context) (*PassPreviousValues, error) {
	var v PassPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PassPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PassPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PassPreviousValuesExecArray) Exec(ctx context.Context) ([]PassPreviousValues, error) {
	var v []PassPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PassPreviousValues struct {
	ID        string    `json:"id"`
	CreatedAt string    `json:"createdAt"`
	UpdatedAt string    `json:"updatedAt"`
	ExpireAt  string    `json:"expireAt"`
	State     PassState `json:"state"`
}

type TravelerExec struct {
	exec *prisma.Exec
}

func (instance *TravelerExec) RegistrationTicket() *ActionTicketExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ActionTicket"},
		"registrationTicket",
		[]string{"id", "createdAt", "updatedAt", "type", "token", "available", "used"})

	return &ActionTicketExec{ret}
}

func (instance *TravelerExec) Person() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"person",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

type CardsParamsExec struct {
	Where   *CreditCardWhereInput
	OrderBy *CreditCardOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *TravelerExec) Cards(params *CardsParamsExec) *CreditCardExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CreditCardWhereInput", "CreditCardOrderByInput", "CreditCard"},
		"cards",
		[]string{"id", "createdAt", "updatedAt", "customerToken", "cardNumber", "cardToken", "type", "lastUsed"})

	return &CreditCardExecArray{ret}
}

type PurchasesParamsExec struct {
	Where   *PurchaseWhereInput
	OrderBy *PurchaseOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *TravelerExec) Purchases(params *PurchasesParamsExec) *PurchaseExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PurchaseWhereInput", "PurchaseOrderByInput", "Purchase"},
		"purchases",
		[]string{"id", "createdAt", "updatedAt", "chargeToken", "gatewayResponse", "discountID", "discount"})

	return &PurchaseExecArray{ret}
}

type PassesParamsExec struct {
	Where   *PassWhereInput
	OrderBy *PassOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *TravelerExec) Passes(params *PassesParamsExec) *PassExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PassWhereInput", "PassOrderByInput", "Pass"},
		"passes",
		[]string{"id", "createdAt", "updatedAt", "expireAt", "state"})

	return &PassExecArray{ret}
}

type RegistryParamsExec struct {
	Where   *EntryTicketWhereInput
	OrderBy *EntryTicketOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *TravelerExec) Registry(params *RegistryParamsExec) *EntryTicketExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"EntryTicketWhereInput", "EntryTicketOrderByInput", "EntryTicket"},
		"registry",
		[]string{"id", "createdAt", "updatedAt", "at"})

	return &EntryTicketExecArray{ret}
}

func (instance TravelerExec) Exec(ctx context.Context) (*Traveler, error) {
	var v Traveler
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerExecArray) Exec(ctx context.Context) ([]Traveler, error) {
	var v []Traveler
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Traveler struct {
	ID           string `json:"id"`
	CreatedAt    string `json:"createdAt"`
	UpdatedAt    string `json:"updatedAt"`
	Unregistered bool   `json:"unregistered"`
	Username     string `json:"username"`
}

type LimaContactExec struct {
	exec *prisma.Exec
}

func (instance *LimaContactExec) Message() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"message",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance LimaContactExec) Exec(ctx context.Context) (*LimaContact, error) {
	var v LimaContact
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LimaContactExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LimaContactExecArray struct {
	exec *prisma.Exec
}

func (instance LimaContactExecArray) Exec(ctx context.Context) ([]LimaContact, error) {
	var v []LimaContact
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LimaContact struct {
	ID          string `json:"id"`
	Email       string `json:"email"`
	PhoneNumber string `json:"phoneNumber"`
}

type PassTypeSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PassTypeSubscriptionPayloadExec) Node() *PassTypeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PassType"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "gallery", "creatorID", "duration"})

	return &PassTypeExec{ret}
}

func (instance *PassTypeSubscriptionPayloadExec) PreviousValues() *PassTypePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PassTypePreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "gallery", "creatorID", "duration"})

	return &PassTypePreviousValuesExec{ret}
}

func (instance PassTypeSubscriptionPayloadExec) Exec(ctx context.Context) (*PassTypeSubscriptionPayload, error) {
	var v PassTypeSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PassTypeSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PassTypeSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PassTypeSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PassTypeSubscriptionPayload, error) {
	var v []PassTypeSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PassTypeSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *PassType    `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type IDDocumentEdgeExec struct {
	exec *prisma.Exec
}

func (instance *IDDocumentEdgeExec) Node() *IDDocumentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "IDDocument"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "value", "validated"})

	return &IDDocumentExec{ret}
}

func (instance IDDocumentEdgeExec) Exec(ctx context.Context) (*IDDocumentEdge, error) {
	var v IDDocumentEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance IDDocumentEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type IDDocumentEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance IDDocumentEdgeExecArray) Exec(ctx context.Context) ([]IDDocumentEdge, error) {
	var v []IDDocumentEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type IDDocumentEdge struct {
	Node   IDDocument `json:"node"`
	Cursor string     `json:"cursor"`
}

type PassTypePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PassTypePreviousValuesExec) Exec(ctx context.Context) (*PassTypePreviousValues, error) {
	var v PassTypePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PassTypePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PassTypePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PassTypePreviousValuesExecArray) Exec(ctx context.Context) ([]PassTypePreviousValues, error) {
	var v []PassTypePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PassTypePreviousValues struct {
	ID        string   `json:"id"`
	CreatedAt string   `json:"createdAt"`
	UpdatedAt string   `json:"updatedAt"`
	Gallery   []string `json:"gallery,omitempty"`
	CreatorId string   `json:"creatorID"`
	Duration  int32    `json:"duration"`
}

type FeatureConnectionExec struct {
	exec *prisma.Exec
}

func (instance *FeatureConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *FeatureConnectionExec) Edges() *FeatureEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"FeatureWhereInput", "FeatureOrderByInput", "FeatureEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Feature"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &FeatureEdgeExecArray{nodes}
}

func (instance *FeatureConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateFeature"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance FeatureConnectionExec) Exec(ctx context.Context) (*FeatureConnection, error) {
	var v FeatureConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeatureConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeatureConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance FeatureConnectionExecArray) Exec(ctx context.Context) ([]FeatureConnection, error) {
	var v []FeatureConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FeatureConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []FeatureEdge `json:"edges"`
}

type CredentialExec struct {
	exec *prisma.Exec
}

func (instance *CredentialExec) Owner() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"owner",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

func (instance CredentialExec) Exec(ctx context.Context) (*Credential, error) {
	var v Credential
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CredentialExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CredentialExecArray struct {
	exec *prisma.Exec
}

func (instance CredentialExecArray) Exec(ctx context.Context) ([]Credential, error) {
	var v []Credential
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Credential struct {
	ID             string         `json:"id"`
	CreatedAt      string         `json:"createdAt"`
	UpdatedAt      string         `json:"updatedAt"`
	DisplayName    *string        `json:"displayName,omitempty"`
	IsMain         bool           `json:"isMain"`
	Type           CredentialType `json:"type"`
	Validated      *bool          `json:"validated,omitempty"`
	ValidationId   *string        `json:"validationID,omitempty"`
	Value          string         `json:"value"`
	RawPassword    *string        `json:"rawPassword,omitempty"`
	HashedPassword string         `json:"hashedPassword"`
}

type PaymentMethodSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PaymentMethodSubscriptionPayloadExec) Node() *PaymentMethodExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentMethod"},
		"node",
		[]string{"id", "type", "value", "cardNumber", "code"})

	return &PaymentMethodExec{ret}
}

func (instance *PaymentMethodSubscriptionPayloadExec) PreviousValues() *PaymentMethodPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentMethodPreviousValues"},
		"previousValues",
		[]string{"id", "type", "value", "cardNumber", "code"})

	return &PaymentMethodPreviousValuesExec{ret}
}

func (instance PaymentMethodSubscriptionPayloadExec) Exec(ctx context.Context) (*PaymentMethodSubscriptionPayload, error) {
	var v PaymentMethodSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentMethodSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentMethodSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentMethodSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PaymentMethodSubscriptionPayload, error) {
	var v []PaymentMethodSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentMethodSubscriptionPayload struct {
	Mutation      MutationType   `json:"mutation"`
	Node          *PaymentMethod `json:"node,omitempty"`
	UpdatedFields []string       `json:"updatedFields,omitempty"`
}

type PaymentMethodPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PaymentMethodPreviousValuesExec) Exec(ctx context.Context) (*PaymentMethodPreviousValues, error) {
	var v PaymentMethodPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentMethodPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentMethodPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentMethodPreviousValuesExecArray) Exec(ctx context.Context) ([]PaymentMethodPreviousValues, error) {
	var v []PaymentMethodPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentMethodPreviousValues struct {
	ID         string            `json:"id"`
	Type       PaymentMethodType `json:"type"`
	Value      *string           `json:"value,omitempty"`
	CardNumber *string           `json:"cardNumber,omitempty"`
	Code       *string           `json:"code,omitempty"`
}

type ErrorEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ErrorEdgeExec) Node() *ErrorExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Error"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "code", "internal", "explain", "location"})

	return &ErrorExec{ret}
}

func (instance ErrorEdgeExec) Exec(ctx context.Context) (*ErrorEdge, error) {
	var v ErrorEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ErrorEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ErrorEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ErrorEdgeExecArray) Exec(ctx context.Context) ([]ErrorEdge, error) {
	var v []ErrorEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ErrorEdge struct {
	Node   Error  `json:"node"`
	Cursor string `json:"cursor"`
}

type PaymentMethodExec struct {
	exec *prisma.Exec
}

func (instance PaymentMethodExec) Exec(ctx context.Context) (*PaymentMethod, error) {
	var v PaymentMethod
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentMethodExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentMethodExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentMethodExecArray) Exec(ctx context.Context) ([]PaymentMethod, error) {
	var v []PaymentMethod
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PaymentMethod struct {
	ID         string            `json:"id"`
	Type       PaymentMethodType `json:"type"`
	Value      *string           `json:"value,omitempty"`
	CardNumber *string           `json:"cardNumber,omitempty"`
	Code       *string           `json:"code,omitempty"`
}

type PersonSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PersonSubscriptionPayloadExec) Node() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

func (instance *PersonSubscriptionPayloadExec) PreviousValues() *PersonPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PersonPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonPreviousValuesExec{ret}
}

func (instance PersonSubscriptionPayloadExec) Exec(ctx context.Context) (*PersonSubscriptionPayload, error) {
	var v PersonSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PersonSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PersonSubscriptionPayload, error) {
	var v []PersonSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Person      `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type EmailChannelEdgeExec struct {
	exec *prisma.Exec
}

func (instance *EmailChannelEdgeExec) Node() *EmailChannelExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "EmailChannel"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "value", "extras"})

	return &EmailChannelExec{ret}
}

func (instance EmailChannelEdgeExec) Exec(ctx context.Context) (*EmailChannelEdge, error) {
	var v EmailChannelEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EmailChannelEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EmailChannelEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance EmailChannelEdgeExecArray) Exec(ctx context.Context) ([]EmailChannelEdge, error) {
	var v []EmailChannelEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EmailChannelEdge struct {
	Node   EmailChannel `json:"node"`
	Cursor string       `json:"cursor"`
}

type PersonPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PersonPreviousValuesExec) Exec(ctx context.Context) (*PersonPreviousValues, error) {
	var v PersonPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PersonPreviousValuesExecArray) Exec(ctx context.Context) ([]PersonPreviousValues, error) {
	var v []PersonPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonPreviousValues struct {
	ID        string   `json:"id"`
	CreatedAt string   `json:"createdAt"`
	UpdatedAt string   `json:"updatedAt"`
	QmId      *string  `json:"qmID,omitempty"`
	Name      string   `json:"name"`
	Photo     *string  `json:"photo,omitempty"`
	Birthdate *string  `json:"birthdate,omitempty"`
	Tags      []string `json:"tags,omitempty"`
}

type CurrencyConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CurrencyConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CurrencyConnectionExec) Edges() *CurrencyEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CurrencyWhereInput", "CurrencyOrderByInput", "CurrencyEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Currency"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &CurrencyEdgeExecArray{nodes}
}

func (instance *CurrencyConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCurrency"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CurrencyConnectionExec) Exec(ctx context.Context) (*CurrencyConnection, error) {
	var v CurrencyConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CurrencyConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CurrencyConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CurrencyConnectionExecArray) Exec(ctx context.Context) ([]CurrencyConnection, error) {
	var v []CurrencyConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type CurrencyConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []CurrencyEdge `json:"edges"`
}

type ProductEntryExec struct {
	exec *prisma.Exec
}

func (instance ProductEntryExec) Exec(ctx context.Context) (*ProductEntry, error) {
	var v ProductEntry
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductEntryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductEntryExecArray struct {
	exec *prisma.Exec
}

func (instance ProductEntryExecArray) Exec(ctx context.Context) ([]ProductEntry, error) {
	var v []ProductEntry
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ProductEntry struct {
	ID           string  `json:"id"`
	ParentId     string  `json:"parentID"`
	Name         string  `json:"name"`
	Description  *string `json:"description,omitempty"`
	Quantity     int32   `json:"quantity"`
	Cost         float64 `json:"cost"`
	CurrencyCode string  `json:"currencyCode"`
}

type TicketConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TicketConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TicketConnectionExec) Edges() *TicketEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"TicketWhereInput", "TicketOrderByInput", "TicketEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Ticket"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &TicketEdgeExecArray{nodes}
}

func (instance *TicketConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTicket"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance TicketConnectionExec) Exec(ctx context.Context) (*TicketConnection, error) {
	var v TicketConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TicketConnectionExecArray) Exec(ctx context.Context) ([]TicketConnection, error) {
	var v []TicketConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TicketConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []TicketEdge `json:"edges"`
}

type PersonReviewsSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PersonReviewsSubscriptionPayloadExec) Node() *PersonReviewsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PersonReviews"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "approveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

func (instance *PersonReviewsSubscriptionPayloadExec) PreviousValues() *PersonReviewsPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PersonReviewsPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "approveNumber", "declineNumber"})

	return &PersonReviewsPreviousValuesExec{ret}
}

func (instance PersonReviewsSubscriptionPayloadExec) Exec(ctx context.Context) (*PersonReviewsSubscriptionPayload, error) {
	var v PersonReviewsSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonReviewsSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonReviewsSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PersonReviewsSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PersonReviewsSubscriptionPayload, error) {
	var v []PersonReviewsSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonReviewsSubscriptionPayload struct {
	Mutation      MutationType   `json:"mutation"`
	Node          *PersonReviews `json:"node,omitempty"`
	UpdatedFields []string       `json:"updatedFields,omitempty"`
}

type PersonReviewsPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PersonReviewsPreviousValuesExec) Exec(ctx context.Context) (*PersonReviewsPreviousValues, error) {
	var v PersonReviewsPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonReviewsPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonReviewsPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PersonReviewsPreviousValuesExecArray) Exec(ctx context.Context) ([]PersonReviewsPreviousValues, error) {
	var v []PersonReviewsPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonReviewsPreviousValues struct {
	ID            string `json:"id"`
	CreatedAt     string `json:"createdAt"`
	UpdatedAt     string `json:"updatedAt"`
	ApproveNumber *int32 `json:"approveNumber,omitempty"`
	DeclineNumber *int32 `json:"declineNumber,omitempty"`
}

type ProductEntryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ProductEntryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ProductEntryConnectionExec) Edges() *ProductEntryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ProductEntryWhereInput", "ProductEntryOrderByInput", "ProductEntryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "ProductEntry"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &ProductEntryEdgeExecArray{nodes}
}

func (instance *ProductEntryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateProductEntry"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ProductEntryConnectionExec) Exec(ctx context.Context) (*ProductEntryConnection, error) {
	var v ProductEntryConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductEntryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductEntryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ProductEntryConnectionExecArray) Exec(ctx context.Context) ([]ProductEntryConnection, error) {
	var v []ProductEntryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ProductEntryConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []ProductEntryEdge `json:"edges"`
}

type PurchaseExec struct {
	exec *prisma.Exec
}

type ProductsParamsExec struct {
	Where   *ProductEntryWhereInput
	OrderBy *ProductEntryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PurchaseExec) Products(params *ProductsParamsExec) *ProductEntryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ProductEntryWhereInput", "ProductEntryOrderByInput", "ProductEntry"},
		"products",
		[]string{"id", "parentID", "name", "description", "quantity", "cost", "currencyCode"})

	return &ProductEntryExecArray{ret}
}

func (instance *PurchaseExec) PaymentMethod() *PaymentMethodExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentMethod"},
		"paymentMethod",
		[]string{"id", "type", "value", "cardNumber", "code"})

	return &PaymentMethodExec{ret}
}

func (instance PurchaseExec) Exec(ctx context.Context) (*Purchase, error) {
	var v Purchase
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PurchaseExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PurchaseExecArray struct {
	exec *prisma.Exec
}

func (instance PurchaseExecArray) Exec(ctx context.Context) ([]Purchase, error) {
	var v []Purchase
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Purchase struct {
	ID              string  `json:"id"`
	CreatedAt       string  `json:"createdAt"`
	UpdatedAt       string  `json:"updatedAt"`
	ChargeToken     string  `json:"chargeToken"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type PersonReviewsEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PersonReviewsEdgeExec) Node() *PersonReviewsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PersonReviews"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "approveNumber", "declineNumber"})

	return &PersonReviewsExec{ret}
}

func (instance PersonReviewsEdgeExec) Exec(ctx context.Context) (*PersonReviewsEdge, error) {
	var v PersonReviewsEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonReviewsEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonReviewsEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PersonReviewsEdgeExecArray) Exec(ctx context.Context) ([]PersonReviewsEdge, error) {
	var v []PersonReviewsEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonReviewsEdge struct {
	Node   PersonReviews `json:"node"`
	Cursor string        `json:"cursor"`
}

type PhoneChannelSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PhoneChannelSubscriptionPayloadExec) Node() *PhoneChannelExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PhoneChannel"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelExec{ret}
}

func (instance *PhoneChannelSubscriptionPayloadExec) PreviousValues() *PhoneChannelPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PhoneChannelPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "isMain", "displayName", "valid", "countryCode", "number"})

	return &PhoneChannelPreviousValuesExec{ret}
}

func (instance PhoneChannelSubscriptionPayloadExec) Exec(ctx context.Context) (*PhoneChannelSubscriptionPayload, error) {
	var v PhoneChannelSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneChannelSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneChannelSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneChannelSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PhoneChannelSubscriptionPayload, error) {
	var v []PhoneChannelSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhoneChannelSubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *PhoneChannel `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type TicketPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TicketPreviousValuesExec) Exec(ctx context.Context) (*TicketPreviousValues, error) {
	var v TicketPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TicketPreviousValuesExecArray) Exec(ctx context.Context) ([]TicketPreviousValues, error) {
	var v []TicketPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TicketPreviousValues struct {
	ID        string      `json:"id"`
	CreatedAt string      `json:"createdAt"`
	UpdatedAt string      `json:"updatedAt"`
	MaxUses   int32       `json:"maxUses"`
	Visited   bool        `json:"visited"`
	Finished  bool        `json:"finished"`
	State     TicketState `json:"state"`
}

type PhoneChannelPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PhoneChannelPreviousValuesExec) Exec(ctx context.Context) (*PhoneChannelPreviousValues, error) {
	var v PhoneChannelPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneChannelPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneChannelPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneChannelPreviousValuesExecArray) Exec(ctx context.Context) ([]PhoneChannelPreviousValues, error) {
	var v []PhoneChannelPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PhoneChannelPreviousValues struct {
	ID          string  `json:"id"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
	IsMain      *bool   `json:"isMain,omitempty"`
	DisplayName string  `json:"displayName"`
	Valid       bool    `json:"valid"`
	CountryCode string  `json:"countryCode"`
	Number      *string `json:"number,omitempty"`
}

type PartnerEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PartnerEdgeExec) Node() *PartnerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Partner"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "brandName", "logo", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

func (instance PartnerEdgeExec) Exec(ctx context.Context) (*PartnerEdge, error) {
	var v PartnerEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerEdgeExecArray) Exec(ctx context.Context) ([]PartnerEdge, error) {
	var v []PartnerEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PartnerEdge struct {
	Node   Partner `json:"node"`
	Cursor string  `json:"cursor"`
}

type CurrencyExec struct {
	exec *prisma.Exec
}

func (instance *CurrencyExec) Name() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"name",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance CurrencyExec) Exec(ctx context.Context) (*Currency, error) {
	var v Currency
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CurrencyExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CurrencyExecArray struct {
	exec *prisma.Exec
}

func (instance CurrencyExecArray) Exec(ctx context.Context) ([]Currency, error) {
	var v []Currency
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Currency struct {
	ID     string `json:"id"`
	Code   string `json:"code"`
	Symbol string `json:"symbol"`
}

type LocationConnectionExec struct {
	exec *prisma.Exec
}

func (instance *LocationConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *LocationConnectionExec) Edges() *LocationEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"LocationWhereInput", "LocationOrderByInput", "LocationEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Location"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &LocationEdgeExecArray{nodes}
}

func (instance *LocationConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateLocation"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance LocationConnectionExec) Exec(ctx context.Context) (*LocationConnection, error) {
	var v LocationConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LocationConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LocationConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance LocationConnectionExecArray) Exec(ctx context.Context) ([]LocationConnection, error) {
	var v []LocationConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LocationConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []LocationEdge `json:"edges"`
}

type PlaceSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PlaceSubscriptionPayloadExec) Node() *PlaceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Place"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "shortName", "address", "googleLink", "website", "type", "extraTypes", "tags", "popularity", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &PlaceExec{ret}
}

func (instance *PlaceSubscriptionPayloadExec) PreviousValues() *PlacePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PlacePreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "name", "shortName", "address", "googleLink", "website", "type", "extraTypes", "tags", "popularity", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &PlacePreviousValuesExec{ret}
}

func (instance PlaceSubscriptionPayloadExec) Exec(ctx context.Context) (*PlaceSubscriptionPayload, error) {
	var v PlaceSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PlaceSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PlaceSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PlaceSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PlaceSubscriptionPayload, error) {
	var v []PlaceSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PlaceSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Place       `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type LimaConnectionExec struct {
	exec *prisma.Exec
}

func (instance *LimaConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *LimaConnectionExec) Edges() *LimaEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"LimaWhereInput", "LimaOrderByInput", "LimaEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Lima"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &LimaEdgeExecArray{nodes}
}

func (instance *LimaConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateLima"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance LimaConnectionExec) Exec(ctx context.Context) (*LimaConnection, error) {
	var v LimaConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LimaConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LimaConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance LimaConnectionExecArray) Exec(ctx context.Context) ([]LimaConnection, error) {
	var v []LimaConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LimaConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []LimaEdge `json:"edges"`
}

type PlacePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PlacePreviousValuesExec) Exec(ctx context.Context) (*PlacePreviousValues, error) {
	var v PlacePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PlacePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PlacePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PlacePreviousValuesExecArray) Exec(ctx context.Context) ([]PlacePreviousValues, error) {
	var v []PlacePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PlacePreviousValues struct {
	ID               string           `json:"id"`
	CreatedAt        string           `json:"createdAt"`
	UpdatedAt        string           `json:"updatedAt"`
	Name             string           `json:"name"`
	ShortName        *string          `json:"shortName,omitempty"`
	Address          string           `json:"address"`
	GoogleLink       *string          `json:"googleLink,omitempty"`
	Website          *string          `json:"website,omitempty"`
	Type             ExperienceType   `json:"type"`
	ExtraTypes       []ExperienceType `json:"extraTypes,omitempty"`
	Tags             []string         `json:"tags,omitempty"`
	Popularity       float64          `json:"popularity"`
	ProviderWeb      *string          `json:"providerWeb,omitempty"`
	ContactPhone     *string          `json:"contactPhone,omitempty"`
	ContactEmail     *string          `json:"contactEmail,omitempty"`
	AddressReference *string          `json:"addressReference,omitempty"`
}

type CostExec struct {
	exec *prisma.Exec
}

func (instance *CostExec) Currency() *CurrencyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Currency"},
		"currency",
		[]string{"id", "code", "symbol"})

	return &CurrencyExec{ret}
}

func (instance CostExec) Exec(ctx context.Context) (*Cost, error) {
	var v Cost
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CostExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CostExecArray struct {
	exec *prisma.Exec
}

func (instance CostExecArray) Exec(ctx context.Context) ([]Cost, error) {
	var v []Cost
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Cost struct {
	ID    string  `json:"id"`
	Value float64 `json:"value"`
}

type FaqConnectionExec struct {
	exec *prisma.Exec
}

func (instance *FaqConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *FaqConnectionExec) Edges() *FaqEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"FaqWhereInput", "FaqOrderByInput", "FaqEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Faq"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &FaqEdgeExecArray{nodes}
}

func (instance *FaqConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateFaq"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance FaqConnectionExec) Exec(ctx context.Context) (*FaqConnection, error) {
	var v FaqConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FaqConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FaqConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance FaqConnectionExecArray) Exec(ctx context.Context) ([]FaqConnection, error) {
	var v []FaqConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FaqConnection struct {
	PageInfo PageInfo  `json:"pageInfo"`
	Edges    []FaqEdge `json:"edges"`
}

type ProductEntrySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ProductEntrySubscriptionPayloadExec) Node() *ProductEntryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductEntry"},
		"node",
		[]string{"id", "parentID", "name", "description", "quantity", "cost", "currencyCode"})

	return &ProductEntryExec{ret}
}

func (instance *ProductEntrySubscriptionPayloadExec) PreviousValues() *ProductEntryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ProductEntryPreviousValues"},
		"previousValues",
		[]string{"id", "parentID", "name", "description", "quantity", "cost", "currencyCode"})

	return &ProductEntryPreviousValuesExec{ret}
}

func (instance ProductEntrySubscriptionPayloadExec) Exec(ctx context.Context) (*ProductEntrySubscriptionPayload, error) {
	var v ProductEntrySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductEntrySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductEntrySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ProductEntrySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ProductEntrySubscriptionPayload, error) {
	var v []ProductEntrySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ProductEntrySubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *ProductEntry `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type PartnerExec struct {
	exec *prisma.Exec
}

func (instance *PartnerExec) Attender() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"attender",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

func (instance *PartnerExec) Owner() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"owner",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

type AttractionsParamsExec struct {
	Where   *AttractionWhereInput
	OrderBy *AttractionOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PartnerExec) Attractions(params *AttractionsParamsExec) *AttractionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AttractionWhereInput", "AttractionOrderByInput", "Attraction"},
		"attractions",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionExecArray{ret}
}

func (instance *PartnerExec) Location() *LocationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Location"},
		"location",
		[]string{"id", "createdAt", "updatedAt", "longitude", "latitude"})

	return &LocationExec{ret}
}

type FeaturesParamsExec struct {
	Where   *FeatureWhereInput
	OrderBy *FeatureOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PartnerExec) Features(params *FeaturesParamsExec) *FeatureExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"FeatureWhereInput", "FeatureOrderByInput", "Feature"},
		"features",
		[]string{"id", "image"})

	return &FeatureExecArray{ret}
}

func (instance *PartnerExec) ServiceHours() *OpeningHoursExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OpeningHours"},
		"serviceHours",
		[]string{"id", "mon", "tue", "wed", "thu", "fri", "sat", "sun"})

	return &OpeningHoursExec{ret}
}

func (instance *PartnerExec) Registry(params *RegistryParamsExec) *EntryTicketExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"EntryTicketWhereInput", "EntryTicketOrderByInput", "EntryTicket"},
		"registry",
		[]string{"id", "createdAt", "updatedAt", "at"})

	return &EntryTicketExecArray{ret}
}

func (instance PartnerExec) Exec(ctx context.Context) (*Partner, error) {
	var v Partner
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PartnerExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PartnerExecArray struct {
	exec *prisma.Exec
}

func (instance PartnerExecArray) Exec(ctx context.Context) ([]Partner, error) {
	var v []Partner
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Partner struct {
	ID           string `json:"id"`
	CreatedAt    string `json:"createdAt"`
	UpdatedAt    string `json:"updatedAt"`
	BrandName    string `json:"brandName"`
	Logo         string `json:"logo"`
	SocialReason string `json:"socialReason"`
	Ruc          string `json:"ruc"`
	Address      string `json:"address"`
}

type ProductEntryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ProductEntryPreviousValuesExec) Exec(ctx context.Context) (*ProductEntryPreviousValues, error) {
	var v ProductEntryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ProductEntryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ProductEntryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ProductEntryPreviousValuesExecArray) Exec(ctx context.Context) ([]ProductEntryPreviousValues, error) {
	var v []ProductEntryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ProductEntryPreviousValues struct {
	ID           string  `json:"id"`
	ParentId     string  `json:"parentID"`
	Name         string  `json:"name"`
	Description  *string `json:"description,omitempty"`
	Quantity     int32   `json:"quantity"`
	Cost         float64 `json:"cost"`
	CurrencyCode string  `json:"currencyCode"`
}

type PassTypeExec struct {
	exec *prisma.Exec
}

func (instance *PassTypeExec) Name() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"name",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *PassTypeExec) ShortDescription() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"shortDescription",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *PassTypeExec) Description() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"description",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *PassTypeExec) Disclaimer() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"disclaimer",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *PassTypeExec) Attractions(params *AttractionsParamsExec) *AttractionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AttractionWhereInput", "AttractionOrderByInput", "Attraction"},
		"attractions",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionExecArray{ret}
}

func (instance *PassTypeExec) Cost() *CostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Cost"},
		"cost",
		[]string{"id", "value"})

	return &CostExec{ret}
}

type ChildrenParamsExec struct {
	Where   *PassWhereInput
	OrderBy *PassOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PassTypeExec) Children(params *ChildrenParamsExec) *PassExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PassWhereInput", "PassOrderByInput", "Pass"},
		"children",
		[]string{"id", "createdAt", "updatedAt", "expireAt", "state"})

	return &PassExecArray{ret}
}

func (instance PassTypeExec) Exec(ctx context.Context) (*PassType, error) {
	var v PassType
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PassTypeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PassTypeExecArray struct {
	exec *prisma.Exec
}

func (instance PassTypeExecArray) Exec(ctx context.Context) ([]PassType, error) {
	var v []PassType
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PassType struct {
	ID        string   `json:"id"`
	CreatedAt string   `json:"createdAt"`
	UpdatedAt string   `json:"updatedAt"`
	Gallery   []string `json:"gallery,omitempty"`
	CreatorId string   `json:"creatorID"`
	Duration  int32    `json:"duration"`
}

type FeatureExec struct {
	exec *prisma.Exec
}

func (instance *FeatureExec) Name() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"name",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance FeatureExec) Exec(ctx context.Context) (*Feature, error) {
	var v Feature
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeatureExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeatureExecArray struct {
	exec *prisma.Exec
}

func (instance FeatureExecArray) Exec(ctx context.Context) ([]Feature, error) {
	var v []Feature
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Feature struct {
	ID    string  `json:"id"`
	Image *string `json:"image,omitempty"`
}

type PurchaseSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PurchaseSubscriptionPayloadExec) Node() *PurchaseExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Purchase"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "chargeToken", "gatewayResponse", "discountID", "discount"})

	return &PurchaseExec{ret}
}

func (instance *PurchaseSubscriptionPayloadExec) PreviousValues() *PurchasePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PurchasePreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "chargeToken", "gatewayResponse", "discountID", "discount"})

	return &PurchasePreviousValuesExec{ret}
}

func (instance PurchaseSubscriptionPayloadExec) Exec(ctx context.Context) (*PurchaseSubscriptionPayload, error) {
	var v PurchaseSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PurchaseSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PurchaseSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PurchaseSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PurchaseSubscriptionPayload, error) {
	var v []PurchaseSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PurchaseSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Purchase    `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PurchasePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PurchasePreviousValuesExec) Exec(ctx context.Context) (*PurchasePreviousValues, error) {
	var v PurchasePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PurchasePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PurchasePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PurchasePreviousValuesExecArray) Exec(ctx context.Context) ([]PurchasePreviousValues, error) {
	var v []PurchasePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PurchasePreviousValues struct {
	ID              string  `json:"id"`
	CreatedAt       string  `json:"createdAt"`
	UpdatedAt       string  `json:"updatedAt"`
	ChargeToken     string  `json:"chargeToken"`
	GatewayResponse *string `json:"gatewayResponse,omitempty"`
	DiscountId      *string `json:"discountID,omitempty"`
	Discount        *int32  `json:"discount,omitempty"`
}

type PassExec struct {
	exec *prisma.Exec
}

func (instance *PassExec) Type() *PassTypeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PassType"},
		"type",
		[]string{"id", "createdAt", "updatedAt", "gallery", "creatorID", "duration"})

	return &PassTypeExec{ret}
}

func (instance *PassExec) Owner() *PersonExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Person"},
		"owner",
		[]string{"id", "createdAt", "updatedAt", "qmID", "name", "photo", "birthdate", "tags"})

	return &PersonExec{ret}
}

func (instance *PassExec) PurchaseReceive() *PurchaseExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Purchase"},
		"purchaseReceive",
		[]string{"id", "createdAt", "updatedAt", "chargeToken", "gatewayResponse", "discountID", "discount"})

	return &PurchaseExec{ret}
}

type TicketsParamsExec struct {
	Where   *TicketWhereInput
	OrderBy *TicketOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PassExec) Tickets(params *TicketsParamsExec) *TicketExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"TicketWhereInput", "TicketOrderByInput", "Ticket"},
		"tickets",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "visited", "finished", "state"})

	return &TicketExecArray{ret}
}

func (instance PassExec) Exec(ctx context.Context) (*Pass, error) {
	var v Pass
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PassExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PassExecArray struct {
	exec *prisma.Exec
}

func (instance PassExecArray) Exec(ctx context.Context) ([]Pass, error) {
	var v []Pass
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Pass struct {
	ID        string    `json:"id"`
	CreatedAt string    `json:"createdAt"`
	UpdatedAt string    `json:"updatedAt"`
	ExpireAt  string    `json:"expireAt"`
	State     PassState `json:"state"`
}

type LimaContactConnectionExec struct {
	exec *prisma.Exec
}

func (instance *LimaContactConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *LimaContactConnectionExec) Edges() *LimaContactEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"LimaContactWhereInput", "LimaContactOrderByInput", "LimaContactEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "LimaContact"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &LimaContactEdgeExecArray{nodes}
}

func (instance *LimaContactConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateLimaContact"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance LimaContactConnectionExec) Exec(ctx context.Context) (*LimaContactConnection, error) {
	var v LimaContactConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LimaContactConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LimaContactConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance LimaContactConnectionExecArray) Exec(ctx context.Context) ([]LimaContactConnection, error) {
	var v []LimaContactConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type LimaContactConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []LimaContactEdge `json:"edges"`
}

type RouteSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *RouteSubscriptionPayloadExec) Node() *RouteExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Route"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "image", "type", "extraTypes", "popularity", "color"})

	return &RouteExec{ret}
}

func (instance *RouteSubscriptionPayloadExec) PreviousValues() *RoutePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RoutePreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "name", "image", "type", "extraTypes", "popularity", "color"})

	return &RoutePreviousValuesExec{ret}
}

func (instance RouteSubscriptionPayloadExec) Exec(ctx context.Context) (*RouteSubscriptionPayload, error) {
	var v RouteSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RouteSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RouteSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance RouteSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]RouteSubscriptionPayload, error) {
	var v []RouteSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RouteSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Route       `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type FaqEntryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *FaqEntryEdgeExec) Node() *FaqEntryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FaqEntry"},
		"node",
		[]string{"id"})

	return &FaqEntryExec{ret}
}

func (instance FaqEntryEdgeExec) Exec(ctx context.Context) (*FaqEntryEdge, error) {
	var v FaqEntryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FaqEntryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FaqEntryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance FaqEntryEdgeExecArray) Exec(ctx context.Context) ([]FaqEntryEdge, error) {
	var v []FaqEntryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type FaqEntryEdge struct {
	Node   FaqEntry `json:"node"`
	Cursor string   `json:"cursor"`
}

type RoutePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance RoutePreviousValuesExec) Exec(ctx context.Context) (*RoutePreviousValues, error) {
	var v RoutePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RoutePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RoutePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance RoutePreviousValuesExecArray) Exec(ctx context.Context) ([]RoutePreviousValues, error) {
	var v []RoutePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type RoutePreviousValues struct {
	ID         string           `json:"id"`
	CreatedAt  string           `json:"createdAt"`
	UpdatedAt  string           `json:"updatedAt"`
	Name       string           `json:"name"`
	Image      string           `json:"image"`
	Type       ExperienceType   `json:"type"`
	ExtraTypes []ExperienceType `json:"extraTypes,omitempty"`
	Popularity float64          `json:"popularity"`
	Color      string           `json:"color"`
}

type EntryTicketConnectionExec struct {
	exec *prisma.Exec
}

func (instance *EntryTicketConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *EntryTicketConnectionExec) Edges() *EntryTicketEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"EntryTicketWhereInput", "EntryTicketOrderByInput", "EntryTicketEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "EntryTicket"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &EntryTicketEdgeExecArray{nodes}
}

func (instance *EntryTicketConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateEntryTicket"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance EntryTicketConnectionExec) Exec(ctx context.Context) (*EntryTicketConnection, error) {
	var v EntryTicketConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EntryTicketConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EntryTicketConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance EntryTicketConnectionExecArray) Exec(ctx context.Context) ([]EntryTicketConnection, error) {
	var v []EntryTicketConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EntryTicketConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []EntryTicketEdge `json:"edges"`
}

type TicketExec struct {
	exec *prisma.Exec
}

func (instance *TicketExec) Parent() *PassExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Pass"},
		"parent",
		[]string{"id", "createdAt", "updatedAt", "expireAt", "state"})

	return &PassExec{ret}
}

func (instance *TicketExec) Attraction() *AttractionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Attraction"},
		"attraction",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionExec{ret}
}

func (instance *TicketExec) Description() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"description",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *TicketExec) AvailableTime() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"availableTime",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance TicketExec) Exec(ctx context.Context) (*Ticket, error) {
	var v Ticket
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TicketExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TicketExecArray struct {
	exec *prisma.Exec
}

func (instance TicketExecArray) Exec(ctx context.Context) ([]Ticket, error) {
	var v []Ticket
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Ticket struct {
	ID        string      `json:"id"`
	CreatedAt string      `json:"createdAt"`
	UpdatedAt string      `json:"updatedAt"`
	MaxUses   int32       `json:"maxUses"`
	Visited   bool        `json:"visited"`
	Finished  bool        `json:"finished"`
	State     TicketState `json:"state"`
}

type PurchaseEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PurchaseEdgeExec) Node() *PurchaseExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Purchase"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "chargeToken", "gatewayResponse", "discountID", "discount"})

	return &PurchaseExec{ret}
}

func (instance PurchaseEdgeExec) Exec(ctx context.Context) (*PurchaseEdge, error) {
	var v PurchaseEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PurchaseEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PurchaseEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PurchaseEdgeExecArray) Exec(ctx context.Context) ([]PurchaseEdge, error) {
	var v []PurchaseEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PurchaseEdge struct {
	Node   Purchase `json:"node"`
	Cursor string   `json:"cursor"`
}

type OpeningHoursConnectionExec struct {
	exec *prisma.Exec
}

func (instance *OpeningHoursConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *OpeningHoursConnectionExec) Edges() *OpeningHoursEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"OpeningHoursWhereInput", "OpeningHoursOrderByInput", "OpeningHoursEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "OpeningHours"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &OpeningHoursEdgeExecArray{nodes}
}

func (instance *OpeningHoursConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateOpeningHours"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance OpeningHoursConnectionExec) Exec(ctx context.Context) (*OpeningHoursConnection, error) {
	var v OpeningHoursConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OpeningHoursConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OpeningHoursConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance OpeningHoursConnectionExecArray) Exec(ctx context.Context) ([]OpeningHoursConnection, error) {
	var v []OpeningHoursConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type OpeningHoursConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []OpeningHoursEdge `json:"edges"`
}

type TextSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TextSubscriptionPayloadExec) Node() *TextExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Text"},
		"node",
		[]string{"id", "english", "spanish"})

	return &TextExec{ret}
}

func (instance *TextSubscriptionPayloadExec) PreviousValues() *TextPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TextPreviousValues"},
		"previousValues",
		[]string{"id", "english", "spanish"})

	return &TextPreviousValuesExec{ret}
}

func (instance TextSubscriptionPayloadExec) Exec(ctx context.Context) (*TextSubscriptionPayload, error) {
	var v TextSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TextSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TextSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TextSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TextSubscriptionPayload, error) {
	var v []TextSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TextSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Text        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type EntryTicketExec struct {
	exec *prisma.Exec
}

func (instance *EntryTicketExec) Ticket() *TicketExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Ticket"},
		"ticket",
		[]string{"id", "createdAt", "updatedAt", "maxUses", "visited", "finished", "state"})

	return &TicketExec{ret}
}

func (instance *EntryTicketExec) Partner() *PartnerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Partner"},
		"partner",
		[]string{"id", "createdAt", "updatedAt", "brandName", "logo", "socialReason", "ruc", "address"})

	return &PartnerExec{ret}
}

func (instance *EntryTicketExec) Traveler() *TravelerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Traveler"},
		"traveler",
		[]string{"id", "createdAt", "updatedAt", "unregistered", "username"})

	return &TravelerExec{ret}
}

func (instance EntryTicketExec) Exec(ctx context.Context) (*EntryTicket, error) {
	var v EntryTicket
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance EntryTicketExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type EntryTicketExecArray struct {
	exec *prisma.Exec
}

func (instance EntryTicketExecArray) Exec(ctx context.Context) ([]EntryTicket, error) {
	var v []EntryTicket
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type EntryTicket struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	At        string `json:"at"`
}

type StoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance StoryPreviousValuesExec) Exec(ctx context.Context) (*StoryPreviousValues, error) {
	var v StoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance StoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type StoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance StoryPreviousValuesExecArray) Exec(ctx context.Context) ([]StoryPreviousValues, error) {
	var v []StoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type StoryPreviousValues struct {
	ID             string    `json:"id"`
	CreatedAt      string    `json:"createdAt"`
	UpdatedAt      string    `json:"updatedAt"`
	Type           StoryType `json:"type"`
	Tags           []string  `json:"tags,omitempty"`
	PodcastLink    *string   `json:"podcastLink,omitempty"`
	AudioStream    *string   `json:"audioStream,omitempty"`
	PrincipalImage string    `json:"principalImage"`
	Likes          int32     `json:"likes"`
	Views          int32     `json:"views"`
}

type StorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *StorySubscriptionPayloadExec) Node() *StoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Story"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "type", "tags", "podcastLink", "audioStream", "principalImage", "likes", "views"})

	return &StoryExec{ret}
}

func (instance *StorySubscriptionPayloadExec) PreviousValues() *StoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "StoryPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "type", "tags", "podcastLink", "audioStream", "principalImage", "likes", "views"})

	return &StoryPreviousValuesExec{ret}
}

func (instance StorySubscriptionPayloadExec) Exec(ctx context.Context) (*StorySubscriptionPayload, error) {
	var v StorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance StorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type StorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance StorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]StorySubscriptionPayload, error) {
	var v []StorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type StorySubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Story       `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type LimaExec struct {
	exec *prisma.Exec
}

type MainAttractionsParamsExec struct {
	Where   *AttractionWhereInput
	OrderBy *AttractionOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *LimaExec) MainAttractions(params *MainAttractionsParamsExec) *AttractionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AttractionWhereInput", "AttractionOrderByInput", "Attraction"},
		"mainAttractions",
		[]string{"id", "createdAt", "updatedAt", "principalImage", "coverImage", "landscapeImage", "gallery", "type"})

	return &AttractionExecArray{ret}
}

type MainPlacesParamsExec struct {
	Where   *PlaceWhereInput
	OrderBy *PlaceOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *LimaExec) MainPlaces(params *MainPlacesParamsExec) *PlaceExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PlaceWhereInput", "PlaceOrderByInput", "Place"},
		"mainPlaces",
		[]string{"id", "createdAt", "updatedAt", "name", "shortName", "address", "googleLink", "website", "type", "extraTypes", "tags", "popularity", "providerWeb", "contactPhone", "contactEmail", "addressReference"})

	return &PlaceExecArray{ret}
}

type MainPartnersParamsExec struct {
	Where   *PartnerWhereInput
	OrderBy *PartnerOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *LimaExec) MainPartners(params *MainPartnersParamsExec) *PartnerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PartnerWhereInput", "PartnerOrderByInput", "Partner"},
		"mainPartners",
		[]string{"id", "createdAt", "updatedAt", "brandName", "logo", "socialReason", "ruc", "address"})

	return &PartnerExecArray{ret}
}

type HotStoriesParamsExec struct {
	Where   *StoryWhereInput
	OrderBy *StoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *LimaExec) HotStories(params *HotStoriesParamsExec) *StoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"StoryWhereInput", "StoryOrderByInput", "Story"},
		"hotStories",
		[]string{"id", "createdAt", "updatedAt", "type", "tags", "podcastLink", "audioStream", "principalImage", "likes", "views"})

	return &StoryExecArray{ret}
}

func (instance *LimaExec) Contact() *LimaContactExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "LimaContact"},
		"contact",
		[]string{"id", "email", "phoneNumber"})

	return &LimaContactExec{ret}
}

func (instance *LimaExec) Faq() *FaqExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Faq"},
		"faq",
		[]string{"id", "createdAt", "updatedAt"})

	return &FaqExec{ret}
}

func (instance LimaExec) Exec(ctx context.Context) (*Lima, error) {
	var v Lima
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LimaExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LimaExecArray struct {
	exec *prisma.Exec
}

func (instance LimaExecArray) Exec(ctx context.Context) ([]Lima, error) {
	var v []Lima
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Lima struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	Version   string `json:"version"`
	Available bool   `json:"available"`
}

type PersonConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PersonConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PersonConnectionExec) Edges() *PersonEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PersonWhereInput", "PersonOrderByInput", "PersonEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Person"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &PersonEdgeExecArray{nodes}
}

func (instance *PersonConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePerson"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PersonConnectionExec) Exec(ctx context.Context) (*PersonConnection, error) {
	var v PersonConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PersonConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PersonConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PersonConnectionExecArray) Exec(ctx context.Context) ([]PersonConnection, error) {
	var v []PersonConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PersonConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []PersonEdge `json:"edges"`
}

type TravelerConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TravelerConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TravelerConnectionExec) Edges() *TravelerEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"TravelerWhereInput", "TravelerOrderByInput", "TravelerEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Traveler"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &TravelerEdgeExecArray{nodes}
}

func (instance *TravelerConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTraveler"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance TravelerConnectionExec) Exec(ctx context.Context) (*TravelerConnection, error) {
	var v TravelerConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TravelerConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TravelerConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TravelerConnectionExecArray) Exec(ctx context.Context) ([]TravelerConnection, error) {
	var v []TravelerConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TravelerConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []TravelerEdge `json:"edges"`
}

type ExpertConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ExpertConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ExpertConnectionExec) Edges() *ExpertEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ExpertWhereInput", "ExpertOrderByInput", "ExpertEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetMany(
		edges,
		nil,
		[3]string{"", "", "Expert"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "name", "desc"})

	return &ExpertEdgeExecArray{nodes}
}

func (instance *ExpertConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateExpert"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ExpertConnectionExec) Exec(ctx context.Context) (*ExpertConnection, error) {
	var v ExpertConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ExpertConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ExpertConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ExpertConnectionExecArray) Exec(ctx context.Context) ([]ExpertConnection, error) {
	var v []ExpertConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ExpertConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []ExpertEdge `json:"edges"`
}
